show user;
-- USER이(가) "HR"입니다.

select * from dba_users;
-- 오라클 서버에 존재하는 모든 사용자 계정 정보를 조회해주는 것이다.
-- ORA-00942: table or view does not exist
-- 관리자 권한이 없으므로 조회할 수 없다.

select * from tab;
-- 현재 오라클 서버에 접속한 사용자(지금은 HR) 소유의 테이블명과 뷰명을 조회해주는 것이다.

select *
from departments; -- 부서 테이블 / 오라클은 데이터 값에서 영문의 첫글자만 대문자로 작성하며, 나머지는 대소문자 구분하지 않는다.
/*
    department_id   => 부서번호 컬럼(column == field == attribute == 열)
    department_name => 부서명 컬럼
    manager_id      => 부서장의 사원번호 컬럼
    location_id     => 부서위치
    
    10	Administration	200	1700 => row == record == tuple == 행
    
    departments  => (전체를 통틀어) table = entity(개체) = 테이블
*/

describe departments; -- departments 테이블의 컬럼 구성 타입을 조회
/*
-------------------------------------------------
컬럼명           널여부                데이터타입
-------------------------------------------------
DEPARTMENT_ID   NOT NULL(필수입력사항) NUMBER(4)      => 숫자타입
DEPARTMENT_NAME NOT NULL(필수입력사항) VARCHAR2(30)   => 문자열타입
MANAGER_ID              (선택입력사항) NUMBER(6)      **date: 날짜타입
LOCATION_ID             (선택입력사항) NUMBER(4)
*/

select *
from employees; -- 사원테이블

desc employees; -- describe 줄여서 쓸 수 있다.
/*
EMPLOYEE_ID    NOT NULL NUMBER(6)    => 사원번호
FIRST_NAME              VARCHAR2(20) => 성
LAST_NAME      NOT NULL VARCHAR2(25) => 이름
EMAIL          NOT NULL VARCHAR2(25) => 이메일
PHONE_NUMBER            VARCHAR2(20) => 전화번호
HIRE_DATE      NOT NULL DATE         => 입사일자
JOB_ID         NOT NULL VARCHAR2(10) => 직종아이디
SALARY                  NUMBER(8,2)  => 기본급여
COMMISSION_PCT          NUMBER(2,2)  => 커미션(수당)퍼센티지(본인 급여에 대한 비율: 0.2는 기본급여(salary)의 20% 라는 의미)
MANAGER_ID              NUMBER(6)    => 직속상관(사수)의 사원번호
DEPARTMENT_ID           NUMBER(4)    => 본인이 근무하는 부서번호
*/

select *
from locations; -- 부서의 위치를 알려주는 테이블

select *
from countries; -- 국가 정보를 알려주는 테이블

select *
from regions; -- 대륙 정보를 알려주는 테이블

/*
    ==== 아주아주아주아주아주아주아주아주아주아주 중요함(필수암기!!!!!!!!!!) ====
    >>>> select문의 처리 순서 <<<<
    
    select 컬럼명          -- 5 컬럼명 대신에 * 을 쓰면 * 은 모든 컬럼을 뜻하는 것이다.
    from 테이블명(뷰명)     -- 1
    where 조건절           -- 2 where 절이 뜻하는 것은 해당 테이블(뷰)에서 조건에 만족하는 행을 메모리(RAM)에 로딩(올리는 것)해주는 것이다.
    group by절            -- 3
    having 그룹함수 조건절  -- 4
    order by절            -- 6
*/

------ *** NULL 을 처리해주는 함수 *** ------
---- NULL 은 존재하지 않는 것이므로 사칙연산( + - * / )에 NULL 이 포함되어지면 그 결과는 무조건 NULL 이다.
1. nvl
    select 1+2
    from departments; -- departments 수 만큼 값 로딩
    
    select 1+2, 1+null, 3*0, null*0, 2-1, 2-null, 5/2, 5/null
    from dual; -- 한 번만 로딩
    
    select nvl(7,3), nvl(null,3), -- nvl(a,b): a 값이 null이 아니라면 a 값을 주고, null이라면 두 번째인 b 값을 준다.
           nvl('이순신','거북선'), nvl(null,'거북선')
    from dual;
    
2. nvl2
    select nvl2(7,3,2), nvl2(null,3,2), -- nvl2(a,b,c): a 값이 null이 아니라면 b 값을 주고, null이라면 c 값을 준다.
           nvl2('이순신','거북선','구국영웅'), nvl2(null,'거북선','구국영웅')
    from dual;
    
    
    select employee_id as "사원번호" -- (as) 별칭(alias)
         , first_name "성"
         , last_name 이름
         , salary "기본 급여" -- 공백이 있는 글자를 쓸 때는 ""를 붙여야한다(없으면 생략 가능).
         , commission_pct as "수당퍼센티지"
         , nvl(salary + (salary * commission_pct), salary) as "월급"
         , nvl2(commission_pct, salary + (salary * commission_pct), salary) as "월급2"
    from employees;
    
------ *** 비교연산자 *** ------
1. 같다.        =
2. 같지않다.    !=  <>  ^=
3. 크다, 작다.  >   <
4. 같거나크다, 같거나작다. >= <=
5. NULL 은 존재하지 않는 것이므로 비교대상이 될 수가 없다.
   그러므로 비교연산( = != <> ^= > < >= <= )을 할 수가 없다.
   그래서 비교연산을 하려면 nvl()함수, nvl2()함수를 사용하여 처리한다.
   
-- employees 테이블에서 부서번호 30번에 근무하는 사원들만
-- 사원번호, 사원명, 월급, 부서번호를 나타내세요.

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명 -- a || b : a 컬럼과 b 컬럼을 합친다.
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호 -- 일단 메모리에는 where 조건을 만족하는 모든 테이블의 값이 올라간다. 그 후 select를 거쳐 원하는 값만 뽑아낸다.
    from employees
    where department_id = 30;
    
    
-- employees 테이블에서 부서번호가 null 인 사원들만
-- 사원번호, 사원명, 월급, 부서번호를 나타내세요.

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명 -- a || b : a 컬럼과 b 컬럼을 합친다.
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where department_id = null; --> 데이터가 출력되지 않는다.
                                --> 왜냐하면 NULL 은 존재하지 않는 것이므로 비교대상이 될 수가 없다.
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호 -- 꺼낼 때는 원래 값인 null을 뽑아낸다.
    from employees
    where nvl(department_id, -9999) = -9999 -- 회사에 존재하지 않는 임의의 값 부여해 비교할 수 있도록 한다.
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명 -- a || b : a 컬럼과 b 컬럼 값을 합친다.
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where department_id is null; -- null 은 is 연산자를 사용하여 구한다.
                                 -- department_id 가 null 인 행들만 보고자 할 경우.
    
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명 -- a || b : a 컬럼과 b 컬럼 값을 합친다.
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where department_id is not null; -- null 은 is 연산자를 사용하여 구한다.
                                     -- department_id 가 null 이 아닌 행들만 보고자 할 경우.
    
    
-- 정렬(오름차순정렬, 내림차순정렬)을 할때 null 은 존재하지 않는 것이므로
-- 오라클에서는 가장 큰것으로 간주를 하고, MS-SQL 에서는 가장 작은것으로 간주한다.
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
--  order by nvl(salary + (salary*commission_pct), salary); -- asc; -- 오름차순은 asc 을 생략할 수 있다.
    order by nvl(salary + (salary*commission_pct), salary) desc; -- 내림차순은 desc 을 생략할 수 없다.
    
    -- 또는
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
--  order by 월급 -- asc; -- 오름차순 -- select 다음 순서이기 때문에 월급(alias)을 받아온다.
    order by 월급 desc; -- 내림차순 -- select 다음 순서이기 때문에 월급(alias)을 받아온다.
    
    -- 또는
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
--  order by 3 -- asc; -- 오름차순 -- 3번째 컬럼을 의미한다.
    order by 3 desc; -- 내림차순 -- 3번째 컬럼을 의미한다.
    
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    order by department_id; -- 부서번호의 오름차순 정렬 / null 가장 큰 값으로 정렬
    
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    order by department_id asc, 3 desc; -- 1차정렬은 department_id(부서번호)의 오름차순으로 정렬시킨 후
                                        -- 2차정렬은 동일한 부서번호내에서는 월급의 내림차순으로 정렬하겠다.
                                        -- order by department_id, 3 desc; => 부서번호 오름차순(생략), 월급 내림차순 (O)
                                                                    --     => 모두 내림차순 (X)
                                                                    
-- employees 테이블에서 수당퍼센티지가 null 인 사원들만
-- 사원번호, 사원명, 월급(기본급여+수당금액), 부서번호를 나타내되
-- 부서번호의 오름차순으로 정렬한 후 동일한 부서번호내에서는 월급의 내림차순으로 나타내세요.

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where commission_pct is null
    order by department_id, 3 desc;
    
-- employees 테이블에서 수당퍼센티지가 null 이 아닌 사원들만
-- 사원번호, 사원명, 월급(기본급여+수당금액), 부서번호를 나타내되
-- 부서번호의 오름차순으로 정렬한 후 동일한 부서번호내에서는 월급의 내림차순으로 나타내세요.

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where commission_pct is not null
    order by department_id, 3 desc;
    
    -- 또는
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where not commission_pct is null -- 컬럼명 앞에 not => 부정
    order by department_id, 3 desc;
    
-- employees 테이블에서 월급(기본급여+수당금액)이 10000 보다 큰 사원들만
-- 사원번호, 사원명, 월급(기본급여+수당금액), 부서번호를 나타내되
-- 부서번호의 오름차순으로 정렬한 후 동일한 부서번호내에서는 월급의 내림차순으로 나타내세요.
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where nvl(salary + (salary*commission_pct), salary) > 10000
    order by 부서번호, nvl(salary + (salary*commission_pct), salary) desc;

-- employees 테이블에서 부서번호가 50번 부서가 아닌 사원들만
-- 사원번호, 사원명, 월급(기본급여+수당금액), 부서번호를 나타내되
-- 부서번호의 오름차순으로 정렬한 후 동일한 부서번호내에서는 월급의 내림차순으로 나타내세요.
    desc employees; -- 데이터 구조 확인(조건을 따지기 위해)

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where nvl(department_id, -9999) <> 50
    order by 4, 월급 desc;
    
    -- 또는
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where not nvl(department_id, -9999) = 50
    order by 4, 월급 desc;
    
/*
    === AND, OR, NOT 연산자가 혼용되어지면 우선순위를 따르는데
        NOT > AND > OR 의 순위를 따라간다.
        우선순위에 있어서 최우선은 ( ) 괄호이다. ===
        
        OR 연산자와 같은 것이 IN() 이다. IN()는 괄호가 있는 OR 이다.
        범위연산자가 있는데 between A and B 가 A 이상 B 이하를 나타내는 것이다.
*/

    select 2+3*4
    from dual; -- 한 개만 보기 위한 가상테이블
    
/*
    employees 테이블에서 부서번호가 30, 50, 60번 부서에서 근무하는 사원들 중에
    연봉(월급*12)이 20000 이상 60000 이하인 사원들만
    사원번호, 사원명, 연봉(월급*12), 부서번호를 나타내되
    부서번호의 오름차순으로 정렬한 후, 연봉의 내림차순으로 정렬하여 출력하세요.
*/

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary)*12 as 연봉
         , department_id as 부서번호
    from employees
    where department_id = 30 or department_id = 50 or department_id = 60 and -- and 우선순위에 따라 부서번호가 60번인 사람만 아래 조건을 검색한다.
          20000 <= nvl(salary + (salary*commission_pct), salary)*12 and
          nvl(salary + (salary*commission_pct), salary)*12 <= 60000
    order by 4, 3 desc;
    
    /*
        !!! and 와 or 가 혼용되어지면 우선순위는 and 가 먼저 한다. !!!
    */
        
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary)*12 as 연봉
         , department_id as 부서번호
    from employees
    where (department_id = 30 or department_id = 50 or department_id = 60) and -- or 조건을 우선 수행하기 위해 괄호를 써야한다.
          20000 <= nvl(salary + (salary*commission_pct), salary)*12 and
          nvl(salary + (salary*commission_pct), salary)*12 <= 60000
    order by 4, 3 desc;
    
    /*
        !!! 연산자의 우선순위에서 괄호() 가 제일 우선한다. !!!
    */
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary)*12 as 연봉
         , department_id as 부서번호
    from employees
    where department_id in(30,50,60) and -- 부서번호 30 또는 50 또는 60
          nvl(salary + (salary*commission_pct), salary)*12 between 20000 and 60000 -- 연봉 20000 이상 60000 이하
    order by 4, 3 desc;
    
    -- 대용량 데이터베이스인 경우 in() 보다는 or를, between A and B 보다는 <= >= 를 사용할 것을 권장한다.
    -- 왜냐하면 in 은 내부적으로 or 로 변경되어서 사용되고, 
    -- 또한 between A and B 도 <= >= 로 변경되어서 사용되기 때문이다.
    -- 대용량 데이터베이스의 기준은 어떤 테이블의 행의 갯수가 100만건을 넘을 경우를 말한다.
    -- 소규모 데이터베이스의 기준은 어떤 테이블의 행의 갯수가 1만건 미만인 경우를 말한다.
    

/*
    employees 테이블에서 부서번호가 50, 80번 부서에서 근무하지 않는 사원들 중에
    월급이 4000 이상인 사원들만
    사원번호, 사원명, 월급, 부서번호를 나타내되
    부서번호의 오름차순으로 정렬한 후, 월급의 내림차순으로 정렬하여 출력하세요.
*/

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where nvl(department_id, -9999) != 50 and nvl(department_id, -9999) != 80 and
          nvl(salary + (salary*commission_pct), salary) >= 4000
    order by 4, 3 desc;
    
    -- 또는
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where not nvl(department_id, -9999) in(50,80) and -- 부서번호가 50 또는 80이 아닌 / >= 4000 까지 전체에 not 이 적용되지 않는다.
          nvl(salary + (salary*commission_pct), salary) >= 4000
    order by 4, 3 desc;
    
    -- 또는
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where nvl(department_id, -9999) not in(50,80) and -- 부서번호가 50 또는 80이 아닌 / 부정하고자 하는 표현 앞에 붙여 조금 더 명확하게 표현
          nvl(salary + (salary*commission_pct), salary) >= 4000
    order by 4, 3 desc;
    /*
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where nvl(department_id, -9999) != 50 and
          nvl(department_id, -9999) != 80 and
          nvl(salary + (salary*commission_pct), salary) >= 4000
    order by 4, 3 desc;
    */
    
--- *** ===== 범위 연산자 ===== *** ---
--      >  <  >=  <==
--      between A and B
--      범위 연산자에는 데이터가 숫자 뿐만 아니라 문자, 날짜까지 모두 사용가능하다.
    desc employees;
    -- HIRE_DATE    DATE => DATE 타입의 기본적인 표현방식은 'YY/MM/DD' 으로 나타내어진다.
    --                      YY 은 년도의 2자리만 나타낸다. 50 ~ 99 은 1950 ~ 1999 이다.
    --                      YY 은 년도의 2자리만 나타낸다. 00 ~ 49 은 2000 ~ 2049 이다.
    --                      MM 은 월이고, DD 는 일이다.
    
    -- **** ==== 현재 시각을 알려주는 것 ==== **** --
    select sysdate, current_date, localtimestamp, current_timestamp, systimestamp
    from dual;

    select sysdate, to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss')
    from dual;
    
    select sysdate - 1, sysdate, sysdate + 1 -- 숫자의 단위는 일수이다.
    from dual;

    select to_char(sysdate - 1, 'yyyy-mm-dd'), to_char(sysdate, 'yyyy-mm-dd'), to_char(sysdate + 1, 'yyyy-mm-dd')
    from dual;

    select to_char(sysdate - 1/24, 'yyyy-mm-dd hh24:mi:ss'), to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss'), to_char(sysdate + 1/24, 'yyyy-mm-dd hh24:mi:ss') -- 1시간 전, 현재, 1시간 후
    from dual;

--  select '2020-08-01' + 2 -- 날짜 타입이 아닌 문자 타입이기 때문에 연산 불가
--  from dual;
    select to_date('2020/08/01', 'yyyy/mm/dd') + 2, -- 문자 타입을 날짜 타입으로 (형식에 맞춰서) 변환 => 변환된 날짜는 기본형식으로 출력된다. / 기본적으로 없는 날짜는 변환할 수 없다.
           to_char(to_date('2020-08-01', 'yyyy-mm-dd') + 2, 'yyyy-mm-dd')
    from dual;

    select employee_id, first_name, last_name, hire_date, to_char(hire_date, 'yyyy-mm-dd') -- 날짜의 형식을 지정한 문자열로 바꾸는 것
    from employees
    where '2005-01-01' <= hire_date and hire_date <= '2006-12-31'; -- 날짜로 자동으로 형변환해 비교한다.
    --원래는
    select employee_id, first_name, last_name, hire_date, to_char(hire_date, 'yyyy-mm-dd') -- 날짜의 형식을 지정한 문자열로 바꾸는 것
    from employees
    where to_date('2005-01-01', 'yyyy-mm-dd') <= hire_date and hire_date <= to_date('2006-12-31', 'yyyy-mm-dd');
    
    
    'A' --> 65(문자의 10진수 값)
    'a' --> 97
    '0' --> 48
    ' ' --> 32
    select ascii('A'), ascii('a'), ascii('0'), ascii(' ')
    from dual;
    
    select chr(65), chr(97), chr(48), chr(32)
    from dual;
    
    select first_name
    from employees
    where 'Elj' <= first_name and first_name <= 'H'; -- Elizabeth Elj Ellen
    
    
---- **** employees 테이블에 jubun(주민번호) 이라는 컬럼을 추가하겠다 **** ----
---- jubun(주민번호, - 제외) 이라는 컬럼은 숫자 타입이 아니라 문자 타입이어야 한다.!!!!!!!
    select 9710201234567, '9710201234567' -- 출력 시 숫자는 오른쪽 정렬, 문자는 왼쪽 정렬
    from dual;
    
    select 0110204234567, '0110204234567' -- 숫자는 맨 앞에 0 일 경우 생략된다. => 문자 타입으로 해야 한다.
    from dual;
    
    desc employees;
    
    alter table employees
    add jubun varchar2(13);
    -- 주민번호 열 추가 자료형(길이)
    
    select *
    from employees;
    
    update employees set jubun = '6010151234567'
    where employee_id = 100;
    
    update employees set jubun = '8510151234567'
    where employee_id = 101;
    
    update employees set jubun = '6510152234567'
    where employee_id = 102;
    
    update employees set jubun = '7510151234567'
    where employee_id = 103;
    
    update employees set jubun = '6110152234567'
    where employee_id = 104;
    
    update employees set jubun = '6510151234567'
    where employee_id = 105;
    
    update employees set jubun = '6009201234567'
    where employee_id = 106;
    
    update employees set jubun = '0803153234567'
    where employee_id = 107;
    
    update employees set jubun = '0712154234567'
    where employee_id = 108;
    
    update employees set jubun = '8810151234567'
    where employee_id = 109;
    
    update employees set jubun = '8908152234567'
    where employee_id = 110;
    
    update employees set jubun = '9005052234567'
    where employee_id = 111;
    
    update employees set jubun = '6610151234567'
    where employee_id = 112;
    
    update employees set jubun = '6710151234567'
    where employee_id = 113;
    
    update employees set jubun = '6709152234567'
    where employee_id = 114;
    
    update employees set jubun = '6110151234567'
    where employee_id = 115;
    
    update employees set jubun = '6009301234567'
    where employee_id = 116;
    
    update employees set jubun = '6110152234567'
    where employee_id = 117;
    
    update employees set jubun = '7810151234567'
    where employee_id = 118;
    
    update employees set jubun = '7909151234567'
    where employee_id = 119;
    
    update employees set jubun = '7702152234567'
    where employee_id = 120;
    
    update employees set jubun = '7009151234567'
    where employee_id = 121;
    
    update employees set jubun = '7111011234567'
    where employee_id = 122;
    
    update employees set jubun = '8010131234567'
    where employee_id = 123;
    
    update employees set jubun = '8110191234567'
    where employee_id = 124;
    
    update employees set jubun = '9012132234567'
    where employee_id = 125;
    
    update employees set jubun = '9406251234567'
    where employee_id = 126;
    
    update employees set jubun = '9408252234567'
    where employee_id = 127;
    
    update employees set jubun = '9204152234567'
    where employee_id = 128;
    
    update employees set jubun = '8507251234567'
    where employee_id = 129;
    
    update employees set jubun = '6511111234567'
    where employee_id = 130;
    
    update employees set jubun = '0010153234567'
    where employee_id = 131;
    
    update employees set jubun = '0005254234567'
    where employee_id = 132;
    
    update employees set jubun = '0110194234567'
    where employee_id = 133;
    
    update employees set jubun = '0412154234567'
    where employee_id = 134;
    
    update employees set jubun = '0503253234567'
    where employee_id = 135;
    
    update employees set jubun = '9510012234567'
    where employee_id = 136;
    
    update employees set jubun = '9510021234567'
    where employee_id = 137;
    
    update employees set jubun = '9610041234567'
    where employee_id = 138;
    
    update employees set jubun = '9610052234567'
    where employee_id = 139;
    
    update employees set jubun = '7310011234567'
    where employee_id = 140;
    
    update employees set jubun = '7310092234567'
    where employee_id = 141;
    
    update employees set jubun = '7510121234567'
    where employee_id = 142;
    
    update employees set jubun = '7612012234567'
    where employee_id = 143;
    
    update employees set jubun = '7710061234567'
    where employee_id = 144;
    
    update employees set jubun = '7810052234567'
    where employee_id = 145;
    
    update employees set jubun = '6810251234567'
    where employee_id = 146;
    
    update employees set jubun = '6811062234567'
    where employee_id = 147;
    
    update employees set jubun = '6712052234567'
    where employee_id = 148;
    
    update employees set jubun = '6011251234567'
    where employee_id = 149;
    
    update employees set jubun = '6210062234567'
    where employee_id = 150;
    
    update employees set jubun = '6110191234567'
    where employee_id = 151;
    
    update employees set jubun = '5712062234567'
    where employee_id = 152;
    
    update employees set jubun = '5810231234567'
    where employee_id = 153;
    
    update employees set jubun = '6311051234567'
    where employee_id = 154;
    
    update employees set jubun = '6010182234567'
    where employee_id = 155;
    
    update employees set jubun = '6110191234567'
    where employee_id = 156;
    
    update employees set jubun = '6210112234567'
    where employee_id = 157;
    
    update employees set jubun = '6311132234567'
    where employee_id = 158;
    
    update employees set jubun = '8511112234567'
    where employee_id = 159;
    
    update employees set jubun = '8710131234567'
    where employee_id = 160;
    
    update employees set jubun = '8710072234567'
    where employee_id = 161;
    
    update employees set jubun = '9010171234567'
    where employee_id = 162;
    
    update employees set jubun = '9112072234567'
    where employee_id = 163;
    
    update employees set jubun = '9110241234567'
    where employee_id = 164;
    
    update employees set jubun = '9212251234567'
    where employee_id = 165;
    
    update employees set jubun = '9310232234567'
    where employee_id = 166;
    
    update employees set jubun = '9811151234567'
    where employee_id = 167;
    
    update employees set jubun = '9810252234567'
    where employee_id = 168;
    
    update employees set jubun = '9910301234567'
    where employee_id = 169;
    
    update employees set jubun = '0910153234567'
    where employee_id = 170;
    
    update employees set jubun = '1011153234567'
    where employee_id = 171;
    
    update employees set jubun = '1006153234567'
    where employee_id = 172;
    
    update employees set jubun = '1111154234567'
    where employee_id = 173;
    
    update employees set jubun = '1209103234567'
    where employee_id = 174;
    
    update employees set jubun = '1207154234567'
    where employee_id = 175;
    
    update employees set jubun = '0906153234567'
    where employee_id = 176;
    
    update employees set jubun = '0812113234567'
    where employee_id = 177;
    
    update employees set jubun = '9810132234567'
    where employee_id = 178;
    
    update employees set jubun = '8712111234567'
    where employee_id = 179;
    
    update employees set jubun = '8310012234567'
    where employee_id = 180;
    
    update employees set jubun = '6510191234567'
    where employee_id = 181;
    
    update employees set jubun = '6510221234567'
    where employee_id = 182;
    
    update employees set jubun = '6510232234567'
    where employee_id = 183;
    
    update employees set jubun = '8512131234567'
    where employee_id = 184;
    
    update employees set jubun = '8510182234567'
    where employee_id = 185;
    
    update employees set jubun = '7510192234567'
    where employee_id = 186;
    
    update employees set jubun = '8512192234567'
    where employee_id = 187;
    
    update employees set jubun = '9511151234567'
    where employee_id = 188;
    
    update employees set jubun = '7509302234567'
    where employee_id = 189;
    
    update employees set jubun = '8510161234567'
    where employee_id = 190;
    
    update employees set jubun = '9510192234567'
    where employee_id = 191;
    
    update employees set jubun = '0510133234567'
    where employee_id = 192;
    
    update employees set jubun = '0810194234567'
    where employee_id = 193;
    
    update employees set jubun = '0910183234567'
    where employee_id = 194;
    
    update employees set jubun = '1010134234567'
    where employee_id = 195;
    
    update employees set jubun = '9510032234567'
    where employee_id = 196;
    
    update employees set jubun = '9710181234567'
    where employee_id = 197;
    
    update employees set jubun = '9810162234567'
    where employee_id = 198;
    
    update employees set jubun = '7511171234567'
    where employee_id = 199;
    
    update employees set jubun = '7810172234567'
    where employee_id = 200;
    
    update employees set jubun = '7912172234567'
    where employee_id = 201;
    
    update employees set jubun = '8611192234567'
    where employee_id = 202;
    
    update employees set jubun = '7810252234567'
    where employee_id = 203;
    
    update employees set jubun = '7803251234567'
    where employee_id = 204;
    
    update employees set jubun = '7910232234567'
    where employee_id = 205;
    
    update employees set jubun = '8010172234567'
    where employee_id = 206;
    
    commit;
    
    select *
    from employees;
    
    
    ---------------------------------------------------------------------------------------------------------------
                ---- >>> 단일행 함수 <<< ----
    /*
        ※ 단일행 함수의 종류
        
        1. 문자함수
        2. 숫자함수
        3. 날짜함수
        4. 변환함수
        5. 기타함수
    */
    ---------------------------------------------------------------------------------------------------------------
    
    ---- >>> 1. 문자함수 <<< ----
    
    -- 1.1 upper()   ==> 문자열을 모두 대문자로 변환시켜주는 것
    -- 1.2 lower()   ==> 문자열을 모두 소문자로 변환시켜주는 것
    -- 1.3 initcap() ==> 문자열을 단어별(구분자가 공백) 첫글자만 대문자, 나머지는 모두 소문자로 변환시켜주는 것
    
    select 'kOreA SEOul', upper('kOreA SEOul'), lower('kOreA SEOul'), initcap('kOreA SEOul')
    from dual;
    
    select *
    from employees
    where last_name = 'King';
    
    select *
    from employees
    where last_name = 'king';
    
    select *
    from employees
    where last_name = 'KING';
    
    select *
    from employees
    where last_name = 'kINg'; -- 오라클은 데이터 입력 값은 반드시 대소문자 구분해야 한다.
    -- 구분없이 일치하는 검색 결과를 출력되도록 해보세요.
    select *
    from employees
    where upper(last_name) = upper('kINg'); -- lower, initcap 모두 가능
    
    -- 1.4 substr : 문자열 중 특정문자 또는 문자열의 특정 일부분을 선택해올 때 사용한다.
    select '쌍용교육센터'
         , substr('쌍용교육센터', 2, 3) -- 문자열 '쌍용교육센터'에서 2번째 글자부터 3글자를 뽑아온다(java의 인덱스 개념이 아니다).
         , substr('쌍용교육센터', 2) -- 뽑을 글자 수를 지정하지 않으면 끝까지 뽑아온다.
    from dual;
    
-- *** employees 테이블에서 성별이 '여자'만 사원번호, 사원명, 주민번호를 나타내세요. ***
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
    from employees
    where substr(jubun, 7, 1) = '2' or substr(jubun, 7, 1) = '4'; -- 문자이므로 홑따옴표를 붙여준다.
    
-- *** employees 테이블에서 1990년 ~ 1995년에 태어난 사원중 성별이 '남자'만
-- 사원번호, 사원명, 주민번호를 나타내세요. ***
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
    from employees
    where '90' <= substr(jubun, 1, 2) and
          substr(jubun, 1, 2) <= '95' and
          substr(jubun, 7, 1) = '1';
          
    --- **** 1.5  instr : 어떤 문자열에서 명명된 문자의 위치를 알려주는 것 **** -- java의 indexOf와 유사 개념(하지만 index가 아닌 몇번째 글자인지의 위치)
    select instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', 1, 1)
      -- 3(앞 글자 기준)
      -- '쌍용교육센터 서울교육대학교 교육문화원' 에서 '교육'이 나온 위치를 찾는데
      -- 출발점은 1 번째부터 1번째로 나오는 '교육'의 위치를 알려달라는 말이다. 
      
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', 1, 2)
      -- 10(공백 포함)
      -- '쌍용교육센터 서울교육대학교 교육문화원' 에서 '교육'이 나온 위치를 찾는데
      -- 출발점은 1 번째부터 2번째로 나오는 '교육'의 위치를 알려달라는 말이다.
      
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', 4, 1)
      -- 10(출력 값은 첫 글자로부터의 위치)
      -- '쌍용교육센터 서울교육대학교 교육문화원' 에서 '교육'이 나온 위치를 찾는데
      -- 출발점은 4 번째부터 1번째로 나오는 '교육'의 위치를 알려달라는 말이다.
      
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', 4, 3)
      -- 0(찾고자 하는 문자가 없음)
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', 1)
      -- 3
      -- , 1이 생략되어 있다(1번째로 나오는 문자의 위치)
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', 4)
      -- 10
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', -1, 1)
      -- 16(위치 출력은 역순이 아닌 원래 순서대로 해당하는 위치
      -- 출발점은 문자열의 끝에서부터 역순으로 1번째로 나오는 '교육'의 위치
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', -5, 2)
      -- 10(역순은 첫 글자를 기준으로 시작점이 찾고자하는 문자를 포함할 경우 횟수에 포함)
      -- 출발점은 문자열의 끝에서부터 역순으로 1번째로 나오는 '교육'의 위치
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', -1)
    from dual;
    
    --- **** 1.6 reverse : 어떤 문자열을 거꾸로 보여주는 것이다. **** --
    select 'ORACLE', reverse('ORACLE')
         , '대한민국', reverse('대한민국') -- 한글 거꾸로는 깨진다.
         , reverse(reverse('대한민국')) -- 거꾸로를 거꾸로 복구하는 것은 정상 출력
    from dual;
    

-- [퀴즈] --
  create table tbl_files
  (fileno      number(3)
  ,filepath    varchar2(200)
  );
  
  insert into tbl_files(fileno, filepath)
  values(1, 'c:\myDocuments\resume.hwp');
  
  insert into tbl_files(fileno, filepath)
  values(2, 'd:\mymusic.mp3');
  
  insert into tbl_files(fileno, filepath)
  values(3, 'c:\myphoto\2020\08\face.jpg');
  
  commit;
  
  select *
  from tbl_files;
  
  -- 아래와 같이 나오도록 하세요. --
 /* 
  ---------------------------
    파일번호    파일명
  --------------------------- 
       1	   resume.hwp
       2	   mymusic.mp3
       3	   face.jpg
  ----------------------------
 */
    select fileno as 파일번호
         , reverse(substr( reverse(filepath), 1, instr(reverse(filepath),'\',1)-1 )) as 파일명1
         , substr(filepath, instr(filepath, '\', -1)+1) as 파일명2
    from tbl_files;
    
    --- **** 1.7 lpad : 왼쪽부터 문자를 자리채움 **** --
    --- **** 1.8 rpad : 오른쪽부터 문자를 자리채움 **** --
    select lpad('교육센터', 20, '*') -- 20byte를 확보해서 거기에 '교육센터'를 넣은 후, 빈공간(12byte)이 있으면 왼쪽부터 *(크기만큼 반복) 로 채워라.
         , rpad('교육센터', 20, '*') -- 20byte를 확보해서 거기에 '교육센터'를 넣은 후, 빈공간(12byte)이 있으면 오른쪽부터 *(크기만큼 반복) 로 채워라.
    from dual;
    
    --- **** 1.9 ltrim : 왼쪽부터 문자를 제거한다. **** --
    --- **** 1.10 rtrim : 오른쪽부터 문자를 제거한다. **** --
    --- **** 1.11 trim : 왼쪽, 오른쪽 모두부터 공백문자를 제거한다. **** --
    select ltrim('abbbcccccdaabbccdTabbdddSSS', 'abcd') -- 연속된 abcd가 아니라 a 또는 b 또는 c 또는 d 를 의미한다. => 해당하는 문자가 있을 경우 자르고, 아닌 글자가 나오는 지점에서 멈춘다.
         , rtrim('abbbcccccdaabbccdTabbddd', 'abcd')
      -- , trim('abbbcccccdaabbccdTdabcSabbddd', 'abcd') -- TdabcS (X), 오류, 공백문자만 제거할 수 있다.
         , rtrim(ltrim('abbbcccccdaabbccdTdabcSabbddd', 'abcd'), 'abcd') -- TdabcS(양쪽 자르기)
    from dual;
    
    select '쌍용' || '                              교육                             센터'
         , '쌍용' || ltrim('                              교육                             센터') -- 제거해야할 문자를 정하지 않으면 공백을 제거한다.
         , '쌍용                                    ' || '교육                             센터'
         , rtrim('쌍용                                    ') || '교육                             센터'
         , '쌍용' || trim('                               교육                             ') || '센터'
    from dual;
    
    --- **** 1.12 translate **** --
    select translate('010-3456-7890'      -- 문자열에서
                   , '0123456789'         -- 해당 문자가 있으면
                   , '영일이삼사오육칠팔구') -- 해당 문자로 바꿔라(0123456789와 일대일 매핑으로 짝지어져있다).
    from dual;
    
    --- **** 1.13 replace(치환) **** --
    select replace('쌍용교육센터 서울교육대학교 교육문화원'  -- 문자열에서
                 , '교육'                               -- 해당 문자가 있으면
                 , 'education')                         -- 해당 문자로 바꿔라 / translate와 차이는 일대일과 전체의 차이
    from dual;
    
    --- **** 1.14 length => 문자열의 길이를 알려주는 것 **** --
    select length('쌍용center')  -- 8(byte의 크기가 아니다)
    from dual;
    
    
    ---- **** ====== like 연산자 ====== **** ----
    select *
    from employees
    where department_id = 30;
    
    select *
    from employees
    where department_id like 30;
    
    /*
        like 연산자와 함께 사용되어지는 % 와 _ 를 wild character 라고 부른다.
        like 연산자와 함께 사용되어지는 % 의 뜻은 글자가 있든지 없든지 관계없다라는 말(글자수와도 관계없음)
        like 연산자와 함께 사용되어지는 _ 의 뜻은 반드시 아무글자 1개만을 뜻하는 것이다.
    */
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
    from employees
    where jubun like '90____2%' or -- 90년생 월 2자리 일 2자리 여자라는 조건
          jubun like '91____1%';
          
-- employees 테이블에서 first_name 컬럼의 값이 'J'로 시작하는 사원들만
-- 사원번호, 이름, 성, 기본급여를 나타내세요.
    select employee_id AS 사원번호
         , last_name AS 이름
         , first_name AS 성
         , salary AS 기본급여
    from employees
    where first_name like 'J%';
    -- 성이 소문자 s로 끝나는 사원
    select employee_id AS 사원번호
         , last_name AS 이름
         , first_name AS 성
         , salary AS 기본급여
    from employees
    where first_name like '%s';
    -- 성에 ee 가 들어가는 사원
    select employee_id AS 사원번호
         , last_name AS 이름
         , first_name AS 성
         , salary AS 기본급여
    from employees
    where first_name like '%ee%';
    -- 성에 최소한 e가 두번 들어가는 사원
    select employee_id AS 사원번호
         , last_name AS 이름
         , first_name AS 성
         , salary AS 기본급여
    from employees
    where first_name like '%e%e%';
    -- 이름이 F로 시작하고 세번째에는 e 가 들어가는 사원
    select employee_id AS 사원번호
         , last_name AS 이름
         , first_name AS 성
         , salary AS 기본급여
    from employees
    where last_name like 'F_e%';
    
    
-- *** like 연산자와 함께 사용되어지는 % 와 _ 는 어떤 뜻을 가지고 있는 wild character 인데 
  --     이러한 wild character 를 없애버리도록 해본다. *** --
  create table tbl_watch
  (watchname   Nvarchar2(10)  -- varchar2 의 단위는 byte , Nvarchar2 의 단위는 글자 수(영어권에서는 글자 수 = byte이므로 서로 같다)
  ,bigo        Nvarchar2(100)
  );
  
  insert into tbl_watch(watchname, bigo)
  values('금시계', '순금 99.99% 함유 고급시계');
  
  insert into tbl_watch(watchname, bigo)
  values('은시계', '고객만족도 99.99점 획득한 고급시계');
  
  commit;
  
  select *
  from tbl_watch;
  
  -- tbl_watch 테이블에서 bigo 컬럼에 99.99% 라는 글자가 들어있는 행만 추출하세요 --
  select *
  from tbl_watch
  where bigo like '%99.99%%'; -- % 를 percent 로 인식하지 않고 wild character 로 인식한다.
  
  select *
  from tbl_watch
  where bigo like '%99.99\%%' escape '\';
  -- % 를 wild character 기능에서 탈출시켜야만 퍼센트라고 인식된다.
  -- escape 다음에 정의된 글자(아무거나 지정할 수 있다)를 탈출시키고자 하는 wild character 앞에 적어주면, 그 한글자만 탈출한다.
  
  select *
  from tbl_watch
  where bigo like '%99.992%%' escape '2';
  
  select *
  from tbl_watch
  where bigo like '%99.99a%%' escape 'a'; -- 숫자나 문자는 검색하고자 하는 값으로 혼동할 수 있으므로 가급적 특수문자로 사용한다.
  
  
    ---- >>> 2. 숫자함수 <<< ----
    -- 2.1 mod : 나머지를 구해주는 것.
    select 5/2, mod(5,2), trunc(5/2) -- 소수점 이하를 제거하는 함수 => 몫
    from dual;
    
    -- 2.2 round : 반올림을 해주는 것.
    select 94.547
         , round(94.547)     -- 95
         , round(94.547, 0)  -- 95,    0 은 정수 1자리까지 반올림(, 0 은 생략 가능)
         , round(94.547, 1)  -- 94.5,  1 은 소수 첫째자리까지만 나타내준다.
         , round(94.547, 2)  -- 94.55, 2 는 소수 둘째자리까지만 나타내준다.
         , round(94.547, -1) -- 90,    -1 은 정수 10자리까지 반올림
         , round(94.547, -2) -- 100,   -2 은 정수 100자리까지 반올림
    from dual;
    
    -- 2.3 trunc : 절삭 해주는 것
    select 94.547
         , trunc(94.547)     -- 94
         , trunc(94.547, 0)  -- 94,    0 은 정수 1자리까지를 제외한 아래 자리는 자른다(, 0 은 생략 가능).
         , trunc(94.547, 1)  -- 94.5,  1 은 소수 첫째자리까지
         , trunc(94.547, 2)  -- 94.54, 2 는 소수 둘째자리까지
         , trunc(94.547, -1) -- 90,    -1 은 정수 10자리까지
         , trunc(94.547, -2) -- 0,   -2 은 정수 100자리까지
    from dual;
    

create table tbl_sungjuk
(hakbun   varchar2(20) 
,name     varchar2(20)
,kor      number(3)
,eng      number(3)
,math     number(3)
);

insert into tbl_sungjuk(hakbun, name, kor, eng, math)
values('SIST001','한석규', 90, 92, 93);

insert into tbl_sungjuk(hakbun, name, kor, eng, math)
values('SIST002','두석규', 100, 100, 100);

insert into tbl_sungjuk(hakbun, name, kor, eng, math)
values('SIST003','세석규', 71, 72, 73);

insert into tbl_sungjuk(hakbun, name, kor, eng, math)
values('SIST004','네석규', 89, 87, 81);

insert into tbl_sungjuk(hakbun, name, kor, eng, math)
values('SIST005','오석규', 60, 50, 40);

insert into tbl_sungjuk(hakbun, name, kor, eng, math)
values('SIST006','육석규', 80, 81, 87);

commit;

select *
from tbl_sungjuk;

/*
-------------------------------------------------------------------------
학번  성명  국어  영어  수학  총점  평균(소수부첫째자리까지 나타내되 반올림)  학점
-------------------------------------------------------------------------
*/
    select hakbun AS 학번
         , name AS 성명
         , kor AS 국어
         , eng AS 영어
         , math AS 수학
         , kor + eng + math AS 총점
         , round((kor+eng+math)/3, 1) AS 평균
         , case trunc((kor+eng+math)/3, -1)
           when 100 then 'A'
           when 90 then 'A'
           when 80 then 'B'
           when 70 then 'C'
           when 60 then 'D'
           else 'F' end AS 학점
         , decode(trunc((kor+eng+math)/3, -1), 100, 'A', 90, 'A', 80, 'B', 70, 'C', 60, 'D', 'F') AS 학점
    from tbl_sungjuk;
    
    -- 2.4 power : 거듭제곱
    select 2*2*2*2*2, power(2,5)
    from dual;
    
    -- 2.5 sqrt : 제곱근
    select sqrt(4), sqrt(16), sqrt(2), sqrt(3)
    from dual;
    
    -- 2.6 sin, cos, tan, asin, acos, atan
    select sin(90), cos(90), tan(90),
           asin(0.3), acos(0.3), atan(0.3)
    from dual;
    
    -- 2.7 log
    select log(10,100)
    from dual;
    
    -- 2.8 ascii , chr
    select ascii('A'), ascii('a'), ascii('0'), ascii(' ')
    from dual;
    
    select chr(65), chr(97), chr(48), chr(32)
    from dual;
    
    -- 2.9 sign : 결과값이 양수라면 1, 결과값이 0 이면 0, 결과값이 음수라면 -1
    select sign(5-2), sign(5-5), sign(2-5)
    from dual;
    
    -- 2.10 ceil , floor
    -- ceil(실수) ==> 입력된 실수 보다 큰 최소의 정수를 나타내어준다.
    -- ceil(정수) ==> 입력되어진 정수 그대로 나온다.
    select ceil(10.1), ceil(-10.1), ceil(10), ceil(-10)
    from dual;
    
    -- floor(실수) ==> 입력된 실수 보다 작은 최대의 정수를 나타내어준다.
    -- floor(정수) ==> 입력되어진 정수 그대로 나온다.
    select floor(10.1), floor(-10.1), floor(10), floor(-10)
    from dual;
    
    
    ---- >>> 3. 날짜함수 <<< ----
    -- DATE 타입의 기본적인 표현방식은 'YY/MM/DD' 으로 나타내어진다.
    --                      YY 은 년도의 2자리만 나타낸다. 50 ~ 99 은 1950 ~ 1999 이다.
    --                      YY 은 년도의 2자리만 나타낸다. 00 ~ 49 은 2000 ~ 2049 이다.
    --                      MM 은 월이고, DD 는 일이다.
    
    -- **** ==== 현재 시각을 알려주는 것 ==== **** --
    select sysdate, current_date, localtimestamp, current_timestamp, systimestamp
    from dual;
    
    /*
        날짜 + 숫자 = 날짜
        날짜 - 숫자 = 날짜
        
        여기서 숫자의 단위는 일 이다.
    */
    
    select sysdate - 1 AS 어제시각
         , sysdate AS 현재시각
         , sysdate + 1 AS 내일시각
    from dual;
    
    select to_char(sysdate - 1, 'yyyy-mm-dd hh24:mi:ss') AS 어제시각
         , to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') AS 현재시각
         , to_char(sysdate + 1, 'yyyy-mm-dd hh24:mi:ss') AS 내일시각
    from dual;
    
    -- 1 kg = 1000 g
    -- 1 g = 1/1000 kg
    -- 1 일 = 24시간
    -- [퀴즈] 현재시각 및 현재시각으로 부터 1일 2시간 3분 4초 뒤를 나타내세요
    --        yyyy-mm-dd hh24:mi:ss
    select to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') AS 현재시각
         , to_char(sysdate + (86400+7200+180+4)/86400, 'yyyy-mm-dd hh24:mi:ss') AS "1일 2시간 3분 4초 뒤"
    from dual;
    
    
    -- 3.1 add_months(날짜, 숫자) => 날짜에서 숫자만큼 개월 수를 더해주는 것. 숫자는 단위는 개월
    select to_char(add_months(sysdate, -2), 'yyyy-mm-dd hh24:mi:ss') AS "2개월전"
         , to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') AS 현재
         , to_char(add_months(sysdate, 2), 'yyyy-mm-dd hh24:mi:ss') AS "2개월후"
    from dual;
    
    -- ***[퀴즈] 오늘 부로 김민성씨가 또 군대에 끌려갑니다.
    --           근무개월수가 18개월 이라고 할때 제대일자(년-월-일)를 구하세요.
    select to_char(add_months(sysdate, 18), 'yyyy-mm-dd') AS 제대일자
    from dual;
    
    -- 3.2 months_between(날짜1, 날짜2)
    --     날짜1 - 날짜2 값으로 숫자가 나오는데 그 단위는 개월이다.
    --     즉, 두 날짜의 개월차이를 구할때 사용한다.
    select months_between(add_months(sysdate, 18), sysdate)
    from dual;
    
    --    *기본적으로 날짜1 - 날짜2 은 숫자가 나오는데 그 단위는 일 이다.
    select sysdate + 3 - sysdate
    from dual;
    
    -- 3.3 last_day(특정날짜) ==> 특정날짜가 포함된 달력에서 맨 마지막날을 알려주는 것이다 / 형식은 기본날짜형식으로 나온다.
    select to_char(last_day(sysdate), 'yyyy-mm-dd')
         , last_day('2019-02-05') -- 자동형변환(to_date('2019-02-05', 'yyyy-mm-dd'))
         , to_char(last_day(to_date('2019-02-05', 'yyyy-mm-dd')), 'yyyy-mm-dd')
         , to_char(last_day(to_date('2020-02-05', 'yyyy-mm-dd')), 'yyyy-mm-dd')
    from dual;
    
/*
   [퀴즈]
   employees 테이블에서
   사원번호, 사원명, 주민번호, 성별, 현재나이, 월급, 입사일자, 정년퇴직일 을 나타내세요.

   여기서 정년퇴직일이라 함은 
   해당 사원의 생월이 3월에서 8월에 태어난 사람은 
   해당사원의 나이(한국나이)가 63세가 되는 년도의 8월 31일로 하고,
   해당사원의 생월이 9월에서 2월에 태어난 사람은 
   해당사원의 나이(한국나이)가 63세가 되는 년도의 2월말일(2월28일 또는 2월29일)로 한다.
*/
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS 성별
         , extract(year from sysdate) - (substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 AS 현재나이
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         , to_char(hire_date, 'yyyy-mm-dd') AS 입사일자
         -- 원하는 월을 결과값으로 반환하기 위해 임의의 8월의 날을 문자 형식으로 연도와 결합해주자.
--       , case  
--         when substr(jubun,3,2) between '03' and '08' then to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || '-08-01'), 'yyyy-mm-dd')
--         else to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || '-02-01'), 'yyyy-mm-dd')
--         end AS 정년퇴직일
         , to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || case when substr(jubun,3,2) between '03' and '08' then '-08-01' else '-02-01' end), 'yyyy-mm-dd') AS 정년퇴직일
    from employees;
    
    -- 3.4 next_day(특정날짜, '일') '일' : '일' ~ '토'
    --     ==> 특정날짜로 부터 다음번에 돌아오는 가장 빠른 '일'~'토'의 날짜를 알려주는 것이다.
    select sysdate
         , next_day(sysdate, '금') -- 해당 날짜 다음날부터 돌아오는 가장 빠른 금요일
         , next_day(sysdate, '토')
    from dual;
    
    -- 3.5 extract ==> 날짜에서 년, 월, 일을 숫자형태로 추출해주는 함수이다.
    select sysdate
         , extract(year from sysdate), to_char(sysdate, 'yyyy')
         , extract(month from sysdate), to_char(sysdate, 'mm')
         , extract(day from sysdate), to_char(sysdate, 'dd')
    from dual;
    
    -- 3.6 to_yminterval, to_dsinterval
    --     현재일로 부터 1년 2개월 3일 4시간 5분 6초 뒤를 나타내시오.
    select to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') AS 현재시각
         , to_char(sysdate + to_yminterval('01-02') + to_dsinterval('003 04:05:06') -- yminterval(1년 2개월), dsinterval(3일 4시간 5분 6초)
                 , 'yyyy-mm-dd hh24:mi:ss') AS "1년2개월3일4시간5분6초" -- alias는 최대 30byte
    from dual;
    

create table tbl_loan
(gejanum        varchar2(10)   -- 통장번호
,loanmoney      number         -- 대출금
,interestrate   number(2,2)    -- 이자율
,paymentdate    varchar2(2)    -- 이자를내는날짜 '01', '05', '16', '20', 매월말일 '00'
);           

insert into tbl_loan(gejanum, loanmoney, interestrate, paymentdate)
values('10-1234-01', 5000, 0.03, '01');

insert into tbl_loan(gejanum, loanmoney, interestrate, paymentdate)
values('10-1234-02', 5000, 0.03, '05');

insert into tbl_loan(gejanum, loanmoney, interestrate, paymentdate)
values('10-1234-03', 5000, 0.03, '16');

insert into tbl_loan(gejanum, loanmoney, interestrate, paymentdate)
values('10-1234-04', 5000, 0.03, '00');

commit;

select *
from tbl_loan;

---- *** 해당날짜에 대한 요일명을 알아오는 것 *** ----
select to_char(sysdate, 'day') -- '금요일'(windows), 'Friday'(linux)
     , to_char(sysdate, 'dy')  -- '금'            , 'Fri'
     , to_char(sysdate, 'd')   -- 6               , 6 ( 1(일) 2(월) 3(화) 4(수) 5(목) 6(금) 7(토) ) - 호환 위해 주로 사용
from dual;

select decode(to_char(sysdate, 'd'), '1', '일'
                                   , '2', '월'
                                   , '3', '화'
                                   , '4', '수'
                                   , '5', '목'
                                   , '6', '금'
                                   , '7', '토') AS 오늘의요일명 -- 요일명을 표시할 때 이 코드로 주로 사용
from dual;

select T.*
     , (이번달이자납부일 - 지난달이자납부일)*loanmoney*interestrate -- 날짜 - 날짜 = 숫자(단위 : 일)
from
(
    select gejanum, loanmoney, interestrate, paymentdate
         , decode( to_char(currentpaymentdate, 'd'), '1', currentpaymentdate+1
                                                   , '7', currentpaymentdate+2
                                                        , currentpaymentdate ) AS 이번달이자납부일
         , decode( to_char(prevpaymentdate, 'd'), '1', prevpaymentdate+1
                                                , '7', prevpaymentdate+2
                                                     , prevpaymentdate ) AS 지난달이자납부일
    from
    (
        select gejanum, loanmoney, interestrate, paymentdate
             , decode(paymentdate, '00', last_day(sysdate)
                                       , to_date( to_char(sysdate, 'yyyy-mm-') || paymentdate, 'yyyy-mm-dd' )) AS currentpaymentdate -- 위는 날짜 아래는 문자 타입이기 때문에 기본적으로 형변환을 해야하지만 자동형변환도 이루어진다.
             , decode(paymentdate, '00', last_day(add_months(sysdate, -1))
                                       , to_date( to_char(add_months(sysdate, -1), 'yyyy-mm-') || paymentdate, 'yyyy-mm-dd' )) AS prevpaymentdate
        from tbl_loan
    ) V
) T;
    

---- **** 아주아주아주아주아주아주아주아주아주아주아주 중요 !!!!!!! **** ----
--     inline view (인라인 뷰)
/*
       View(뷰)는 테이블은 아니지만 select 되어진 결과물이 테이블 형태를 띄기 때문에
       select 구문을 마치 테이블 처럼 보는것(간주하는것)을 말한다.
       View(뷰)는 inline view (인라인 뷰) 와 Stored View (저장된 뷰)가 있다.
       inline view (인라인 뷰)는 1회용이라고 볼 수 있고,
       Stored View (저장된 뷰)는 저장되었기 때문에 언제든지 꺼내어 사용할 수 있다.
*/
    
-- *** 퇴직금이라함은 근무년수*월급 으로 하겠다. ***
--     만약에 27개월 근무를 했다면 27/12 * 월급 ==> 2.25 * 월급 ==> trunc(2.25) * 월급
--     정년퇴직일에서 입사일까지 개월의 차이를 구하면 되겠다.
--     trunc( trunc(months_between(정년퇴직일, 입사일))/12 ) * 월급

    select V.*
         , trunc( trunc(months_between(V.정년퇴직일, V.입사일자))/12 ) * V.월급 AS 퇴직금
    from
    (
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS 성별
         , extract(year from sysdate) - (substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 AS 현재나이
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         , to_char(hire_date, 'yyyy-mm-dd') AS 입사일자
         , to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || case when substr(jubun,3,2) between '03' and '08' then '-08-01' else '-02-01' end), 'yyyy-mm-dd') AS 정년퇴직일
    from employees
    ) V; -- inline view 라고 부른다 / 결과물을 하나의 테이블로 만들어 해당 테이블 및 컬럼 자체를 활용할 수 있도록 한다.
    
    
    select V.*  -- * 앞에는 생략 불가
         , trunc( trunc(months_between(정년퇴직일, 입사일자))/12 ) * 월급 AS 퇴직금  -- V. (테이블명.) 은 생략이 가능하다.
    from
    (
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS 성별
         , extract(year from sysdate) - (substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 AS 현재나이
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         , to_char(hire_date, 'yyyy-mm-dd') AS 입사일자
         , to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || case when substr(jubun,3,2) between '03' and '08' then '-08-01' else '-02-01' end), 'yyyy-mm-dd') AS 정년퇴직일
    from employees
    ) V
    where 현재나이 >= 50 and 성별 = '여';
    
--- >>> *** Stored View(저장된 뷰) *** <<< ---
    create or replace view 뷰명
    as
    select 문장;
    
    create or replace view view_employees_retire
    as
    select employee_id -- 일반적으로 호환을 위해 컬럼 이름을 영어로 지정한다.
         , first_name || ' ' || last_name AS ename
         , jubun
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS gender
         , extract(year from sysdate) - (substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 AS age
         , nvl(salary + (salary*commission_pct), salary) AS monthsal
         , to_char(hire_date, 'yyyy-mm-dd') AS hire_date
         , to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || case when substr(jubun,3,2) between '03' and '08' then '-08-01' else '-02-01' end), 'yyyy-mm-dd') AS retire_date
    from employees; -- 생성 완료
    
    select *
    from view_employees_retire;
    
    select employee_id, ename, jubun, gender, age, monthsal, hire_date, retire_date, trunc( trunc(months_between(retire_date, hire_date))/12 ) * monthsal AS 퇴직금 -- 추가 컬럼을 지정할 때는 * 이 아닌 전체 컬럼명을 직접 기입해야 한다.
    from view_employees_retire
    where age >= 50 and gender = '남';
    
    select * from tab;
    -- 현재 오라클 서버에 접속한 사용자(지금은 HR) 소유의 테이블명과 뷰명을 조회해주는 것이다.
    
    select *
    from locations;  -- 테이블인지 뷰인지 알 수 없다.
    
    select *
    from tbl_board;  -- 확인하지 않아도 테이블임을 알 수 있다.
    
    select *
    from view_employees_retire;  -- 확인하지 않아도 뷰임을 알 수 있다.
    
    desc view_employees_retire;
    
    --- *** 테이블이나 뷰를 생성한 이후에는 반드시 코멘트(주석)를 꼭 달아주도록 합시다.!!! *** ---
    select *
    from user_tab_comments;
    
    comment on table view_employees_retire
    is '사원들의 정년퇴직일과 퇴직금을 알려주는 VIEW';
    
    --- *** 생성한 테이블이나 뷰의 컬럼에도 반드시 코멘트(주석)를 꼭 달아주도록 합시다.!!! *** ---
    select *
    from user_col_comments
    where table_name = 'EMPLOYEES';  -- 데이터 값만큼은 대소문자를 구분해주어야 한다!
    
    comment on column employees.jubun
    is '주민등록번호';
    
    comment on column view_employees_retire.gender
    is '성별';
    
    comment on column view_employees_retire.retire_date
    is '정년퇴직일자';
    
    select *
    from user_col_comments
    where table_name = 'VIEW_EMPLOYEES_RETIRE';
    
    --- **** Stored View(저장된 view)의 원본소스(select문)를 보겠다. **** ---
    select *
    from user_views -- 저장한 view 목록
    where view_name = 'VIEW_EMPLOYEES_RETIRE';
    /*
    "select employee_id -- 일반적으로 호환을 위해 컬럼 이름을 영어로 지정한다.
         , first_name || ' ' || last_name AS ename
         , jubun
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS gender
         , extract(year from sysdate) - (substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 AS age
         , nvl(salary + (salary*commission_pct), salary) AS monthsal
         , to_char(hire_date, 'yyyy-mm-dd') AS hire_date
         , to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || case when substr(jubun,3,2) between '03' and '08' then '-08-01' else '-02-01' end), 'yyyy-mm-dd') AS retire_date
    from employees"
    */
    
    --- **** Stored View(저장된 view)의 원본소스(select문)를 변경하겠다. **** ---
    create or replace view view_employees_retire  -- 기존의 view를
    as
    select department_id, department_name  -- 해당 select문으로 변경.
    from departments;
    
    create view view_test1  -- 없는 view 추가가능
    as
    select employee_id, first_name
    from employees;
    
    replace view view_test1  -- 변경은 단독으로 요구할 수 없다. => create or replace
    as
    select employee_id, first_name, salary
    from employees;
    
    create or replace view view_test1  -- view 가 없으면 만들고, 있으면 교체
    as
    select employee_id, first_name, salary
    from employees;
    
    select *
    from view_test1;
    
    select *
    from user_views;
    
    --- **** Stored View(저장된 view) 삭제하기 **** ---
    drop view view_test1;
    
    select * from tab;
    
    
    ---- >>> 4. 변환함수 <<< ----
    -- 4.1 to_char()   => 날짜를 문자형태로 변환, 숫자를 문자형태로 변환
    select to_char(sysdate, 'yyyy') AS 년도
         , to_char(sysdate, 'mm') AS 월
         , to_char(sysdate, 'dd') AS 일
         , to_char(sysdate, 'hh24') AS "24시간"
         , to_char(sysdate, 'hh am') AS "12시간"
         , to_char(sysdate, 'hh pm') AS "12시간"
         , to_char(sysdate, 'mi') AS 분
         , to_char(sysdate, 'ss') AS 초
         , to_char(sysdate, 'q') AS 분기 --  1월~3월 : 1 , 4월~6월 : 2 , 7월~9월 : 3 , 10월~12월 : 4   
         , to_char(sysdate, 'day') AS 요일명
         , to_char(sysdate, 'dy') AS 요일명
    from dual;
 
    select to_char(sysdate, 'ddd') -- 올해 중 몇 번째 날
         , to_char(sysdate, 'dd')  -- 이번달 중 몇 번째 날
         , to_char(sysdate, 'd')   -- 이번주 중 몇 번째 날(요일)
    from dual;
 
    select to_char(sysdate, 'sssss') -- 지정 날짜의 0시 0분 0초부터 흐른 시간(초 단위)
    from dual;
 
    select 123456789
         , to_char(123456789, '999,999,999') -- 9개의 숫자를 3자리마다 콤마를 찍은 문자형태로 변환
         , to_char(123456789, '$999,999,999')
         , to_char(123456789, 'L999,999,999') -- 해당 지역의 화폐 기호를 붙인다.
    from dual;
    
    -- 4.2 to_date()   => 문자를 날짜형태로 변환
    select to_date('2020-08-13', 'yyyy-mm-dd') + 1 -- 시, 분, 초를 작성하지 않으면 0시 0분 0초로 저장된다.
    from dual;
    
    -- 4.3 to_number() => 문자를 숫자형태로 변환
    select '5'+'2'
         , to_number('5')+to_number('2')
    from dual;
    
    
    ---- >>> 5. 기타함수 <<< ----
    -- 5.1 case when then else end (암기!!!)
    select case 5-2
           when 4 then '5-2=4 입니다.' -- 케이스가 참일때 실행하고 끝, 거짓이면 내려간다.
           when 1 then '5-2=1 입니다.'
           when 3 then '5-2=3 입니다.'
           else '나는 수학을 몰라요ㅜㅜ' -- 모두 거짓일때 else
           end AS 결과
    from dual;
    -- 같다의 조건만 가능하다.
    
    select case
           when 4>5 then '4는 5보다 큽니다.'
           when 5>7 then '5는 7보다 큽니다.'
           when 3>2 then '3은 2보다 큽니다.'
           else '나는 수학을 몰라요ㅜㅜ' -- 모두 거짓일때 else
           end AS 결과
    from dual;
    -- case를 작성하지 않고 when에서 참, 거짓 조건을 따진다.
    
    -- 5.2 decode(case when then else end는 ms에서도 사용하지만, decode는 오라클에서만 쓴다)
    select decode(5-2, 4, '5-2=4 입니다.'
                     , 1, '5-2=1 입니다.'
                     , 3, '5-2=3 입니다.'
                        , '나는 수학을 몰라요ㅜㅜ') AS 결과
    from dual;
    
-- employees 테이블에서 아래와 같이 나오도록 하세요.
/*
    -------------------------------
    사원번호 사원명 주민번호       성별
    -------------------------------
    예)
     ....    ...  9610201234567 남
     ....    ...  9510202234567 여
*/

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
         , case substr(jubun,7,1)
           when '1' then '남'
           when '2' then '여'
           when '3' then '남'
           when '4' then '여'
           else '외국인입니다.'
           end as 성별
    from employees
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
         , decode(substr(jubun,7,1), '1', '남'
                                   , '2', '여'
                                   , '3', '남'
                                   , '4', '여'
                                        , '외국인입니다.') as 성별
    from employees
    
-- employees 테이블에서 아래와 같이 나오도록 하세요.
/*
    ------------------------------------------
    사원번호 사원명 주민번호       성별  태어난연도
    ------------------------------------------
    예)
     ....    ...  9610201234567 남   1996
     ....    ...  9510202234567 여   1995
     ....    ...  0010203234567 남   2000
*/

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
         , case substr(jubun,7,1)
           when '1' then '남'
           when '2' then '여'
           when '3' then '남'
           when '4' then '여'
           else '외국인입니다.'
           end as 성별
         , case
           when substr(jubun,1,2) >= '50' then '19' || substr(jubun,1,2)
           when substr(jubun,1,2) <= '49' then '20' || substr(jubun,1,2)
           end as 태어난년도
    from employees
    -- 연도로 비교
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
         , case substr(jubun,7,1)
           when '1' then '남'
           when '2' then '여'
           when '3' then '남'
           when '4' then '여'
           end as 성별
         , decode(substr(jubun,7,1), '1', '19' || substr(jubun,1,2)
                                   , '2', '19' || substr(jubun,1,2)
                                   , '3', '20' || substr(jubun,1,2)
                                   , '4', '20' || substr(jubun,1,2)) as 태어난년도
    from employees
    -- 뒷자리의 첫 수(1, 2는 90년생, 3, 4는 2000년생)에 따라 실행
    
    select sysdate
         , to_char(sysdate, 'yyyy')   -- 문자로 연도 추출
         , extract(year from sysdate) -- 숫자로 연도 추출
    from dual;
    
    select '1997'
         , to_number('1997')
         , '1997'+1 -- 문자열 + 숫자 => 자동 형변환
         , '1997'+'1' -- 자동 형변환
         , to_number('1997')+1 -- 형변환 후 연산하는 것이 정석
    from dual;
    
-- employees 테이블에서 아래와 같이 나오도록 하세요.
/*
    ----------------------------------------------------
    사원번호 사원명 주민번호       성별  태어난연도   현재나이
    ----------------------------------------------------
    예)
     ....    ...  9610201234567 남   1996        현재년도 - 태어난년도 + 1
     ....    ...  9510202234567 여   1995
     ....    ...  0010203234567 남   2000
*/

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
         , case substr(jubun,7,1)
           when '1' then '남'
           when '2' then '여'
           when '3' then '남'
           when '4' then '여'
           else '외국인입니다.'
           end as 성별
           /*
           2.
           case when substr(jubun,7,1) in('2','4') then '여' else '남' end as 성별
           3.
           decode(substr(jubun,7,1), '1', '남'
                                   , '3', '남'
                                        , '여') as 성별
           */
         , case
           when substr(jubun,1,2) >= '50' then '19' || substr(jubun,1,2)
           when substr(jubun,1,2) <= '49' then '20' || substr(jubun,1,2)
           end as 태어난년도
           /*
           1.
           case when substr(jubun,7,1) in('1','2') then '19' else '20' end || substr(jubun,1,2) as 태어난년도 -- 공통적인 부분을 end에 묶어 적을 수 있다.
           2.
           substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1990 else 2000 end as 태어난년도  -- 자동형변환
           */
         , case
           when substr(jubun,1,2) >= '50' then extract(year from sysdate) - to_number('19' || substr(jubun,1,2)) + 1
           when substr(jubun,1,2) <= '49' then extract(year from sysdate) - to_number('20' || substr(jubun,1,2)) + 1
           end as 현재나이
           -- extract(year from sysdate) - ( substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1990 else 2000 end ) + 1 AS 현재나이
    from employees
    
    
    create table tbl_members
    (userid    varchar2(20)
    ,passwd    varchar2(20)
    ,name      varchar2(20)
    ,addr      varchar2(100)
    );
    
    insert into tbl_members(userid, passwd, name, addr)
    values('kimys','abcd','김유신','서울');
    
    insert into tbl_members(userid, passwd, name, addr)
    values('young2','abcd','이영이','서울');
    
    insert into tbl_members(userid, passwd, name, addr)
    values('leesa','abcd','이에리사','서울');
    
    insert into tbl_members(userid, passwd, name, addr)
    values('park','abcd','박이남','서울');
    
    insert into tbl_members(userid, passwd, name, addr)
    values('leebon','abcd','이본','서울');
    
    commit;
    
    select *
    from tbl_members;
    
    select count(*)  -- 5행
    from tbl_members;
    
    select *
    from tbl_members
    where userid='kimys' and passwd='abcd';
    
    select count(*)  -- 1행
    from tbl_members
    where userid='kimys' and passwd='abcd';
    
    select count(*)  -- 0행
    from tbl_members
    where userid='superman' and passwd='abcd';
    
    select *
    from tbl_members
    where userid='kimys' and passwd='1234';
    
    select count(*)  -- 0행
    from tbl_members
    where userid='kimys' and passwd='1234';
    
    select case( select count(*)
                 from tbl_members
                 where userid='superman' and passwd='1234' )
           when 1 then '로그인성공'
           else( case( select count(*)
                 from tbl_members
                 where userid='superman' )
                 when 1 then '암호가 틀립니다'
                 else '아이디가 존재하지 않습니다'
                 end
                 )
           end AS LOGIN결과
    from dual;
    
    select decode((select count(*)
                   from tbl_members
                   where userid='kimys' and passwd='abcd'), '1', '로그인성공'
                                                               , decode((select count(*)
                                                                         from tbl_members
                                                                         where userid='kimys'), '1', '암호가 틀립니다'
                                                                                                   , '아이디가 존재하지 않습니다')) AS LOGIN결과
    from dual;
    
    
    create table tbl_board         
    (boardno       number          -- 글번호
    ,subject       varchar2(4000)  -- 글제목
    ,content       varchar2(4000) -- 글내용
    ,userid        varchar2(40)    -- 글쓴이의 ID  
    ,registerday   date            -- 작성일자
    ,readcount     number(10)      -- 조회수               
    );
    
    insert into tbl_board(boardno, subject, content, userid, registerday, readcount)
     values(1, '안녕하세요', '글쓰기 연습입니다', 'leess', sysdate, 0);
     -- sysdate 는 현재시각을 말한다. 
     
     insert into tbl_board(boardno, subject, content, userid, registerday, readcount)
     values(2, '반갑습니다', '모두 취업대박 나십시오', 'eomjh', sysdate, 0);
      
     insert into tbl_board(boardno, subject, content, userid, registerday, readcount)
     values(3, '건강하세요', '로또 1등을 기원합니다', 'leess', sysdate, 0);
      
     insert into tbl_board(boardno, subject, content, userid, registerday, readcount)
     values(4, '기쁘고 감사함이 넘치는 좋은하루되세요 ', '늘 행복하세요', 'emojh', sysdate, 0);
    
     insert into tbl_board(boardno, subject, content, userid, registerday, readcount)
     values(5, '오늘도 좋은하루되세요', '늘 감사합니다', 'hongkd', sysdate, 0);
    
     insert into tbl_board(boardno, subject, content, userid, registerday, readcount)
     values(6, '좋은 하루 되시고 건강하시고 부자되시고 늘 행복하세요', '맛있는 점심 드세요', 'leess', sysdate, 0);
    
     commit;
     
     select *
     from tbl_board;
    
-- 제목이 16 글자보다 크면 16+...으로 출력
-- subject 컬럼의 값의 길이가 16보다 크면 subject 컬럼의 값중 16글자만 보여주고 뒤에 ... 으 붙여서 보여라.
    select boardno
         , subject
         , case
           when length(subject)>16 then substr(subject, 1, 16) || '...'
           else subject
           end AS 기사제목
    from tbl_board
    order by 1 desc;
    
    -- 기사제목에 건강이 있는 행 추출
    select *
    from tbl_board
    where subject like '%건강%';
    
/*
문제 1. 
employees 테이블에서 커미션을 받는 사원들만 
사원번호, 사원명, 기본급여, 수당, 월급을 
사원번호로 오름차순 정렬후, 월급의 내림차순으로 정렬하여 나타내세요.

------------------------------------------------------
사원번호    사원명            기본급여 수당     월급
------------------------------------------------------
145	    John Russell	    14000	5600	19600
146	    Karen Partners	    13500	4050	17550
147	    Alberto Errazuriz	12000	3600	15600
148	    Gerald Cambrault	11000	3300	14300
149	    Eleni Zlotkey	    10500	2100	12600
150	    Peter Tucker	    10000	3000	13000
151	    David Bernstein	    9500	2375	11875
152	    Peter Hall	        9000	2250	11250
153	    Christopher Olsen	8000	1600	9600
154	    Nanette Cambrault	7500	1500	9000
155	    Oliver Tuvault	    7000	1050	8050
156	    Janette King	    10000	3500	13500
157	    Patrick Sully	    9500	3325	12825
158	    Allan McEwen	    9000	3150	12150
159	    Lindsey Smith	    8000	2400	10400
160	    Louise Doran	    7500	2250	9750
161	    Sarath Sewall	    7000	1750	8750
162	    Clara Vishney	    10500	2625	13125
163	    Danielle Greene	    9500	1425	10925
164	    Mattea Marvins	    7200	720	    7920
165	    David Lee	        6800	680	    7480
166	    Sundar Ande	        6400	640	    7040
167	    Amit Banda	        6200	620	    6820
168	    Lisa Ozer	        11500	2875	14375
169	    Harrison Bloom	    10000	2000	12000
170	    Tayler Fox	        9600	1920	11520
171	    William Smith	    7400	1110	8510
172	    Elizabeth Bates	    7300	1095	8395
173	    Sundita Kumar	    6100	610	    6710
174	    Ellen Abel	        11000	3300	14300
175	    Alyssa Hutton	    8800	2200	11000
176	    Jonathon Taylor	    8600	1720	10320
177	    Jack Livingston	    8400	1680	10080
178	    Kimberely Grant	    7000	1050	8050
179	    Charles Johnson	    6200	620	    6820
*/
    
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , salary AS 기본급여
         , salary * commission_pct AS 수당
         , nvl(salary + (salary*commission_pct), salary) AS 월급
    from employees
    where commission_pct is not null;
    order by 1, 5 desc;

/*
문제 2. 
employees 테이블에서 커미션이 없는 사원들중 남자직원들만 
부서번호, 사원명, 주민번호, 기본급여를 
부서번호로 오름차순 정렬후, 사원명의 오름차순으로 정렬하여 나타내세요.

-------------------------------------------------------
부서번호    사원명             주민번호        기본급여
-------------------------------------------------------
30	    Alexander Khoo	    6110151234567	3100
30	    Guy Himuro	        7810151234567	2600
30	    Karen Colmenares	7909151234567	2500
30	    Shelli Baida	    6009301234567	2900
50	    Adam Fripp	        7009151234567	8200
50	    Curtis Davies	    7510121234567	3100
50	    Douglas Grant	    7511171234567	2600
50	    Irene Mikkilineni	9406251234567	2700
50	    James Marlow	    0010153234567	2500
50	    Jean Fleaur	        6510191234567	3100
50	    Joshua Patel	    7310011234567	2500
50	    Kelly Chung	        9511151234567	3800
50	    Kevin Feeney	    9710181234567	3000
50	    Kevin Mourgos	    8110191234567	5800
50	    Ki Gee	            0503253234567	2400
50	    Laura Bissot	    8507251234567	3300
50	    Martha Sullivan	    6510221234567	2500
50	    Mozhe Atkinson	    6511111234567	2800
50	    Nandita Sarchand	8512131234567	4200
50	    Payam Kaufling	    7111011234567	7900
50	    Peter Vargas	    7710061234567	2500
50	    Renske Ladwig	    9510021234567	3600
50	    Samuel McCain	    0910183234567	3200
50	    Sarah Bell	        0510133234567	4000
50	    Shanta Vollman	    8010131234567	6500
50	    Stephen Stiles	    9610041234567	3200
50	    Timothy Gates	    8510161234567	2900
60	    Alexander Hunold	7510151234567	9000
60	    David Austin	    6510151234567	4800
60	    Diana Lorentz	    0803153234567	4200
60	    Valli Pataballa	    6009201234567	4800
70	    Hermann Baer	    7803251234567	10000
90	    Neena Kochhar	    8510151234567	17000
90	    Steven King	        6010151234567	24000
100	    Daniel Faviet	    8810151234567	9000
100	    Jose Manuel Urman	6610151234567	7800
100	    Luis Popp	        6710151234567	6900
*/
    
    select department_id AS 부서번호
         , first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
         , salary AS 기본급여
    from employees
    where commission_pct is null and substr(jubun,7,1)=1 or substr(jubun,7,1)=3
    order by 1, 2;
  
/*
문제 3. 
employees 테이블에서 부서번호 30,50,60,80,100 번 부서에 근무하지 않는 사원들만 
부서번호, 사원명, 월급을 
부서번호로 오름차순 정렬후, 월급의 내림차순으로 정렬하여 나타내세요.

---------------------------------------
부서번호     사원명             월급
---------------------------------------
10	     Jennifer Whalen	  4400
20	     Michael Hartstein	  13000
20	     Pat Fay	          6000
40	     Susan Mavris	      6500
70	     Hermann Baer	      10000
90	     Steven King	      24000
90	     Neena Kochhar	      17000
90	     Lex De Haan	      17000
110	     Shelley Higgins	  12008
110	     William Gietz	      8300
(null)	 Kimberely Grant	  8050
*/
  
    select department_id AS 부서번호
         , first_name || ' ' || last_name AS 사원명
         , nvl(salary + (salary*commission_pct), salary) AS 월급
    from employees
    where nvl(department_id, -9999) not in(30,50,60,80,100)
    order by 1, 3 desc;

/*
문제 4. 
employees 테이블에서 부서번호가 존재하는 사원들중 월급이 8000 이상 8999 이하인 사원들만 
부서번호, 사원명, 월급을 
부서번호로 오름차순 정렬후, 월급의 내림차순으로 정렬하여 나타내세요.

------------------------------------------
부서번호        사원명            월급
------------------------------------------
50	        Adam Fripp	        8200
50	        Matthew Weiss	    8000
80	        Sarath Sewall	    8750
80	        William Smith	    8510
80	        Elizabeth Bates	    8395
80	        Oliver Tuvault	    8050
100	        John Chen	        8200
110	        William Gietz	    8300
*/
    
    select department_id AS 부서번호
         , first_name || ' ' || last_name AS 사원명
         , nvl(salary + (salary*commission_pct), salary) AS 월급
    from employees
    where department_id is not null and
          8000 <= nvl(salary + (salary*commission_pct), salary) and
          nvl(salary + (salary*commission_pct), salary) <= 8999
    order by 1, 3 desc;

/*
문제 5. 
employees 테이블에서 3월과 9월에 태어난 남자 사원들만 
사원명, 주민번호를 
사원명의 오름차순으로 정렬하여 나타내세요.

----------------------------------
사원명               주민번호
----------------------------------
Adam Fripp	        7009151234567
Diana Lorentz	    0803153234567
Ellen Abel	        1209103234567
Hermann Baer	    7803251234567
Karen Colmenares    7909151234567
Ki Gee	            0503253234567
Shelli Baida	    6009301234567
Valli Pataballa	    6009201234567
*/
    
    select first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
    from employees
    where (substr(jubun,4,1)='3' or substr(jubun,4,1)='9') and
          (substr(jubun,7,1)='1' or substr(jubun,7,1)='3')
    order by 1;
  
/*
문제 6. 
employees 테이블에서 부서번호 30번, 50번에 근무하는 사원들만 
사원명, 주민번호, 성별을 나타내세요.
성별은 '남' 또는 '여'라고 나타낸다.

----------------------------------------------------
부서번호    사원명             주민번호        성별
----------------------------------------------------
30	    Den Raphaely        6709152234567	여
30	    Alexander Khoo      6110151234567	남
30	    Shelli Baida	    6009301234567	남
30	    Sigal Tobias	    6110152234568	여
30	    Guy Himuro	        7810151234567	남
30	    Karen Colmenares	7909151234567	남
50	    Matthew Weiss	    7702152234567	여
50	    Adam Fripp	        7009151234567	남
50	    Payam Kaufling	    7111011234567	남
50	    Shanta Vollman	    8010131234567	남
50	    Kevin Mourgos	    8110191234567	남
50	    Julia Nayer	        9012132234567	여
50	    Irene Mikkilineni	9406251234567	남
50	    James Landry	    9408252234567	여
50	    Steven Markle	    9204152234567	여
50	    Laura Bissot	    8507251234567	남
50	    Mozhe Atkinson	    6511111234567	남
50	    James Marlow	    0010153234567	남
50	    TJ Olson	        0005254234567	여
50	    Jason Mallin	    0110194234567	여
50	    Michael Rogers	    0412154234567	여
50	    Ki Gee	            0503253234567	남
50	    Hazel Philtanker	9510012234567	여
50	    Renske Ladwig	    9510021234567	남
50	    Stephen Stiles	    9610041234567	남
50	    John Seo	        9610052234567	여
50	    Joshua Patel	    7310011234567	남
50	    Trenna Rajs	        7310092234567	여
50	    Curtis Davies	    7510121234567	남
50	    Randall Matos	    7612012234567	여
50	    Peter Vargas	    7710061234567	남
50	    Winston Taylor	    8310012234567	여
50	    Jean Fleaur	        6510191234567	남
50	    Martha Sullivan	    6510221234567	남
50	    Girard Geoni	    6510232234567	여
50	    Nandita Sarchand	8512131234567	남
50	    Alexis Bull	        8510182234567	여
50	    Julia Dellinger	    7510192234567	여
50	    Anthony Cabrio	    8512192234567	여
50	    Kelly Chung	        9511151234567	남
50	    Jennifer Dilly	    7509302234567	여
50	    Timothy Gates	    8510161234567	남
50	    Randall Perkins	    9510192234567	여
50	    Sarah Bell	        0510133234567	남
50	    Britney Everett	    0810194234567	여
50	    Samuel McCain	    0910183234567	남
50	    Vance Jones	        1010134234567	여
50	    Alana Walsh	        9510032234567	여
50	    Kevin Feeney	    9710181234567	남
50	    Donald OConnell	    9810162234567	여
50	    Douglas Grant	    7511171234567	남

*/

    select department_id AS 부서번호
         , first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS 성별
    from employees
    where department_id = 30 or department_id = 50

/*
문제 7. 
employees 테이블에서 부서번호 30번, 50번에 근무하는 사원들만 
사원명, 주민번호, 성별을 나타내세요.
성별은 '남' 또는 '여'라고 나타낸다. 그리고 주민번호는 생년월일만 기재해주고 나머지는 마스킹('*')처리해서 보여준다.

------------------------------------------------------------
부서번호        사원명             주민번호            성별
------------------------------------------------------------
30	        Den Raphaely	    670915*******	여
30	        Alexander Khoo	    611015*******	남
30	        Shelli Baida	    600930*******	남
30	        Sigal Tobias	    611015*******	여
30	        Guy Himuro	        781015*******	남
30	        Karen Colmenares    790915*******	남
50	        Matthew Weiss	    770215*******	여
50	        Adam Fripp	        700915*******	남
50	        Payam Kaufling	    711101*******	남
50	        Shanta Vollman	    801013*******	남
50	        Kevin Mourgos	    811019*******	남
50	        Julia Nayer	        901213*******	여
50	        Irene Mikkilineni   940625*******	남
50	        James Landry	    940825*******	여
50	        Steven Markle	    920415*******	여
50	        Laura Bissot	    850725*******	남
50	        Mozhe Atkinson	    651111*******	남
50	        James Marlow	    001015*******	남
50	        TJ Olson	        000525*******	여
50	        Jason Mallin	    011019*******	여
50	        Michael Rogers	    041215*******	여
50	        Ki Gee	            050325*******	남
50	        Hazel Philtanker    951001*******	여
50	        Renske Ladwig	    951002*******	남
50	        Stephen Stiles	    961004*******	남
50	        John Seo	        961005*******	여
50	        Joshua Patel	    731001*******	남
50	        Trenna Rajs	        731009*******	여
50	        Curtis Davies	    751012*******	남
50	        Randall Matos	    761201*******	여
50	        Peter Vargas	    771006*******	남
50	        Winston Taylor	    831001*******	여
50	        Jean Fleaur	        651019*******	남
50	        Martha Sullivan	    651022*******	남
50	        Girard Geoni	    651023*******	여
50	        Nandita Sarchand    851213*******	남
50	        Alexis Bull	        851018*******	여
50	        Julia Dellinger	    751019*******	여
50	        Anthony Cabrio	    851219*******	여
50	        Kelly Chung	        951115*******	남
50	        Jennifer Dilly	    750930*******	여
50	        Timothy Gates	    851016*******	남
50	        Randall Perkins	    951019*******	여
50	        Sarah Bell	        051013*******	남
50	        Britney Everett	    081019*******	여
50	        Samuel McCain	    091018*******	남
50	        Vance Jones	        101013*******	여
50	        Alana Walsh	        951003*******	여
50	        Kevin Feeney	    971018*******	남
50	        Donald OConnell	    981016*******	여
50	        Douglas Grant	    751117*******	남
*/

    select department_id AS 부서번호
         , first_name || ' ' || last_name AS 사원명
         , substr(jubun,1,6) || '*******' AS 주민번호
         -- rpad(substr(jubun,1,6), lentgh(jubun), '*') AS 주민번호
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS 성별
    from employees
    where department_id = 30 or department_id = 50

/*
문제 8. 
employees 테이블에서 90번 부서에 근무하는 사원들만 아래와 같이
사원명, 공개연락처, 비공개연락처를 나타내세요.
여기서 비공개연락처란? 국번을 * 로 마스킹처리 한것을 말한다.

---------------------------------------------
사원명          공개연락처      비공개연락처
---------------------------------------------
Steven King	    515.123.4567	515.***.4567
Neena Kochhar	515.123.4568	515.***.4568
Lex De Haan	    515.123.4569	515.***.4569
*/

    -- 비공개연락처는 phone_number 컬럼에서 국번만 '*'로 변경한다.
    -- 국번만 발췌해야한다.
    -- 국번만 발췌 => phone_number 컬럼에서 최초로 . 이 나오는 위치 그 다음부터 두번째로 . 이 나오는 위치 그 앞까지만 발췌를 하면 된다.
    select first_name || ' ' || last_name AS 사원명
         , phone_number AS 공개연락처
         , substr(phone_number,1,instr(phone_number,'.',1)) || translate(substr(phone_number,instr(phone_number,'.',1)+1,3),'0123456789','**********') || substr(phone_number,instr(phone_number,'.',-1)) AS 비공개연락처
    from employees
    where department_id = 90;

/*
문제 9. 
employees 테이블에서 80번 부서에 근무하는 사원들만 아래와 같이
사원명, 공개연락처, 비공개연락처를 나타내세요.
여기서 비공개연락처란? 첫번째 국번과 마지막 개별번호를 * 로 마스킹처리 한것을 말한다.

---------------------------------------------------------------
사원명               공개연락처               비공개연락처
---------------------------------------------------------------
John Russell	    011.44.1344.429268	    011.**.1344.******
Karen Partners	    011.44.1344.467268	    011.**.1344.******
Alberto Errazuriz   011.44.1344.429278	    011.**.1344.******
Gerald Cambrault    011.44.1344.619268	    011.**.1344.******
Eleni Zlotkey	    011.44.1344.429018	    011.**.1344.******
Peter Tucker	    011.44.1344.129268	    011.**.1344.******
David Bernstein	    011.44.1344.345268	    011.**.1344.******
Peter Hall	        011.44.1344.478968	    011.**.1344.******
Christopher Olsen   011.44.1344.498718	    011.**.1344.******
Nanette Cambrault   011.44.1344.987668	    011.**.1344.******
Oliver Tuvault	    011.44.1344.486508	    011.**.1344.******
Janette King	    011.44.1345.429268	    011.**.1345.******
Patrick Sully	    011.44.1345.929268	    011.**.1345.******
Allan McEwen	    011.44.1345.829268	    011.**.1345.******
Lindsey Smith	    011.44.1345.729268	    011.**.1345.******
Louise Doran	    011.44.1345.629268	    011.**.1345.******
Sarath Sewall	    011.44.1345.529268	    011.**.1345.******
Clara Vishney	    011.44.1346.129268	    011.**.1346.******
Danielle Greene     011.44.1346.229268	    011.**.1346.******
Mattea Marvins	    011.44.1346.329268	    011.**.1346.******
David Lee	        011.44.1346.529268	    011.**.1346.******
Sundar Ande	        011.44.1346.629268	    011.**.1346.******
Amit Banda	        011.44.1346.729268	    011.**.1346.******
Lisa Ozer	        011.44.1343.929268	    011.**.1343.******
Harrison Bloom	    011.44.1343.829268	    011.**.1343.******
Tayler Fox	        011.44.1343.729268	    011.**.1343.******
William Smith	    011.44.1343.629268	    011.**.1343.******
Elizabeth Bates	    011.44.1343.529268	    011.**.1343.******
Sundita Kumar	    011.44.1343.329268	    011.**.1343.******
Ellen Abel	        011.44.1644.429267	    011.**.1644.******
Alyssa Hutton	    011.44.1644.429266	    011.**.1644.******
Jonathon Taylor	    011.44.1644.429265	    011.**.1644.******
Jack Livingston	    011.44.1644.429264	    011.**.1644.******
Charles Johnson	    011.44.1644.429262	    011.**.1644.******
*/  

    select first_name || ' ' || last_name AS 사원명
         , phone_number AS 공개연락처
         , substr(phone_number, 1, instr(phone_number,'.',1)) ||
           translate(substr(phone_number,instr(phone_number,'.',1)+1,2),'0123456789','**********') ||
           substr(phone_number,instr(phone_number,'.',1,2),instr(phone_number,'.',1,3)-instr(phone_number,'.',1,2)) ||
           translate(substr(phone_number,instr(phone_number,'.',-1)), '0123456789', '**********') AS 비공개연락처
    from employees
    where department_id = 80;
    
    /*
    select first_name || ' ' || last_name AS 사원명
     , phone_number AS 공개연락처
     , substr(phone_number,1,instr(phone_number,'.',1,1)) 
    || lpad('*',instr(phone_number,'.',1,2)-instr(phone_number,'.',1,1)-1,'*') 
    || substr(phone_number,instr(phone_number,'.',1,2), instr(phone_number,'.',1,3)-instr(phone_number,'.',1,2))
    || translate( substr(phone_number,instr(phone_number,'.',1,3)), '0123456789','**********')  AS 비공개연락처
from employees
where department_id = 80;
    */

/*
문제 10. (난이도 상)
employees 테이블에서 80번, 90번 부서에 근무하는 사원들만 아래와 같이
부서번호, 사원명, 공개연락처, 비공개연락처를 나타내세요.
여기서 비공개연락처란? 첫번째 국번과 마지막 개별번호를 * 로 마스킹처리 한것을 말한다.

------------------------------------------------------------------------------
부서번호        사원명              공개연락처               비공개연락처
------------------------------------------------------------------------------  
80	        John Russell	    011.44.1344.429268	    011.**.1344.******
80	        Karen Partners	    011.44.1344.467268	    011.**.1344.******
80	        Alberto Errazuriz   011.44.1344.429278	    011.**.1344.******
80	        Gerald Cambrault    011.44.1344.619268	    011.**.1344.******
80	        Eleni Zlotkey	    011.44.1344.429018	    011.**.1344.******
80	        Peter Tucker	    011.44.1344.129268	    011.**.1344.******
80	        David Bernstein	    011.44.1344.345268	    011.**.1344.******
80	        Peter Hall	        011.44.1344.478968	    011.**.1344.******
80	        Christopher Olsen   011.44.1344.498718	    011.**.1344.******
80	        Nanette Cambrault   011.44.1344.987668	    011.**.1344.******
80	        Oliver Tuvault	    011.44.1344.486508	    011.**.1344.******
80	        Janette King	    011.44.1345.429268	    011.**.1345.******
80	        Patrick Sully	    011.44.1345.929268	    011.**.1345.******
80	        Allan McEwen	    011.44.1345.829268	    011.**.1345.******
80	        Lindsey Smith	    011.44.1345.729268	    011.**.1345.******
80	        Louise Doran	    011.44.1345.629268	    011.**.1345.******
80	        Sarath Sewall	    011.44.1345.529268	    011.**.1345.******
80	        Clara Vishney	    011.44.1346.129268	    011.**.1346.******
80	        Danielle Greene	    011.44.1346.229268	    011.**.1346.******
80	        Mattea Marvins	    011.44.1346.329268	    011.**.1346.******
80	        David Lee	        011.44.1346.529268	    011.**.1346.******
80	        Sundar Ande	        011.44.1346.629268	    011.**.1346.******
80	        Amit Banda	        011.44.1346.729268	    011.**.1346.******
80	        Lisa Ozer	        011.44.1343.929268	    011.**.1343.******
80	        Harrison Bloom	    011.44.1343.829268	    011.**.1343.******
80	        Tayler Fox	        011.44.1343.729268	    011.**.1343.******
80	        William Smith	    011.44.1343.629268	    011.**.1343.******
80	        Elizabeth Bates	    011.44.1343.529268	    011.**.1343.******
80	        Sundita Kumar	    011.44.1343.329268	    011.**.1343.******
80	        Ellen Abel	        011.44.1644.429267	    011.**.1644.******
80	        Alyssa Hutton	    011.44.1644.429266	    011.**.1644.******
80	        Jonathon Taylor	    011.44.1644.429265	    011.**.1644.******
80	        Jack Livingston	    011.44.1644.429264	    011.**.1644.******
80	        Charles Johnson	    011.44.1644.429262	    011.**.1644.******
90	        Steven King	        515.123.4567	    515.***.****
90	        Neena Kochhar	    515.123.4568	    515.***.****
90	        Lex De Haan	        515.123.4569	    515.***.****
*/

    select department_id AS 부서번호
         , first_name || ' ' || last_name AS 사원명
         , phone_number AS 공개연락처
         , substr(phone_number, 1, instr(phone_number,'.',1,1)) 
        || lpad('*', instr(phone_number,'.',1,2)-instr(phone_number,'.',1,1)-1, '*')
        || case 
           when instr(phone_number,'.',1,3) > 0 
                then substr(phone_number, instr(phone_number,'.',1,2), instr(phone_number,'.',1,3)-instr(phone_number,'.',1,2))
           else ''
           end
        || translate(substr(phone_number, instr(phone_number,'.',-1,1)), '0123456789', '**********')
        AS 비공개연락처
    from employees
    where department_id in (80,90)
    order by department_id;
  
 -- ////////////////////////////////////////////////////////////////////////
 
    -- 5.3 rank 등수구하기, dense_rank 서열구하기
    
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         , rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) AS 월급등수 -- 공동 등수가 있으면 다음 등수 스킵
         , dense_rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) AS 월급서열 -- 스킵X
    from employees;
    
    
    select department_id AS 부서번호
         , employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         
         , rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) AS 월급전체등수
         , dense_rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) AS 월급전체서열
         
         , rank() over(partition by department_id order by nvl(salary + (salary*commission_pct), salary) desc) AS "부서내 월급등수"
         , dense_rank() over(partition by department_id order by nvl(salary + (salary*commission_pct), salary) desc) AS "부서내 월급서열"
    from employees
    order by 1;
    
    /*
        employees 테이블에서 월급에 대한 전체등수가 1등 부터 10등까지인 사원들만
        사원번호, 사원명, 월급, 등수를 나타내세요.
    */
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         , rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) AS 월급등수
    from employees;
    where rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) between 1 and 10;
    -- 오류!!!! rank() 와 dense_rank() 는 where 절에 사용불가하다.
    -- 해결책은 inline view 를 사용하면 된다(alias 를 where 절에 넣어준다).
    
    select *
    from
    (
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         , rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) AS 월급등수
    from employees
    ) V
    where 월급등수 between 1 and 10;
    
    -- 5.4 lag, lead (게시판에서 특정글을 조회할때 많이 사용한다) --
    select *
    from tbl_board;
    
    select boardno, subject, content
    from tbl_board;
    /*
    ------------------------------------------------------------------------------------------
    앞글번호    앞글제목   현재글번호   현재글제목   현재글내용                 다음글번호   다음글제목
    ------------------------------------------------------------------------------------------
    null        null        1       	안녕하세요	글쓰기 연습입니다          2     반갑습니다
    1           안녕하세요   2	        반갑습니다	모두 취업대박 나십시오      3     건강하세요
    2           반갑습니다   3        	건강하세요	로또 1등을 기원합니다      4     기쁘고 감사함이 넘치는 좋은하루되세요
    ......
    5           오늘도 좋은하루되세요 6  	좋은 하루 되시고 건강하시고 부자되시고 늘 행복하세요	null    null
    */
    
    select lag(boardno, 1) over(order by boardno asc)
         , boardno, subject, content
         , lead(boardno, 1) over(order by boardno asc)
    from tbl_board;
    
    select lag(boardno, 1) over(order by boardno desc) -- 이전 글번호(lag(값을 가져올 컬럼명, 1 앞의 행) over(정렬 기준))
         , lag(subject) over(order by boardno desc) -- 이전 글제목, (, 1) 은 생략할 수 있다.
         , boardno, subject, content
         , lead(boardno, 1) over(order by boardno desc) -- 다음 글번호(lead(값을 가져올 컬럼명, 1 뒤의 행) over(정렬 기준))
         , lead(subject) over(order by boardno desc) -- 다음 글제목, (, 1) 은 생략할 수 있다.
    from tbl_board;
    
    /*
        4번글 클릭 시 다음과 같이 나오도록 해보세요.
          ------------------------------------------------------------------------------------------
         앞글번호    앞글제목   현재글번호   현재글제목   현재글내용                 다음글번호   다음글제목
            ------------------------------------------------------------------------------------------
        5	오늘도 좋은하루되세요	4	기쁘고 감사함이 넘치는 좋은하루되세요 	늘 행복하세요	3	건강하세요
    */
    select *
    from
    (
    select lag(boardno, 1) over(order by boardno desc) AS prevboardno
         , lag(subject) over(order by boardno desc) AS prevsubject
         , boardno, subject, content
         , lead(boardno, 1) over(order by boardno desc) AS nextboardno
         , lead(subject) over(order by boardno desc) AS nextsubject
    from tbl_board
    ) V
    where boardno = 4;
    
    -- 5.5 greatest , least : 나열된 값에서 제일 큰 , 작은 값을 뽑아오는 것
    select greatest(10, 90, 100, 80)
         , least(10, 90, 100, 80)
    from dual;
    
    select greatest('김유신', '윤봉길', '허준', '고수')
         , least('김유신', '윤봉길', '허준', '고수')
    from dual;
    
    --===============================================================================================================--
    
    -- ***** >>>> 그룹함수(집계함수) <<<< ***** --
    
    /*
        1. sum      -- 합계
        2. avg      -- 평균
        3. max      -- 최대값
        4. min      -- 최소값
        5. count    -- select 되어서 나온 결과물의 행의 갯수
        6. variance -- 분산
        7. stddev   -- 표준편차
        
        분산    : 표준편차의 제곱승 (평균에서 떨어진 정도)
        표준편차 : 분산의 제곱근 (평균과의 차액)
        
        >>> 주식투자 <<<
        평균 50 편차가 적음 -- 안정투자
        평균 50 편차가 큼   -- 투기성투자(위험을 안고서 투자)
        
        분산과 표준편차는 어떤 의사결정시 도움이 되는 지표이다.
    */
    
    --- !!!! 중요중요중요중요중요 그룹함수(집계함수)에서는 null 이 있으면 무조건 null 은 제외시킨 후 연산을 한다!!!!
    --- 그룹함수(집계함수)를 사용하면 말 그대로 1개의 결과값만 나온다.
    select salary, max(salary) -- 오류(결과의 갯수가 다르기 때문에 함께 쓸 수 없다)
    from employees;
    
    select sum(nvl(salary*commission_pct, 0))
         , sum(salary*commission_pct) -- null 값이 있으면 제외하고 연산한다
    from employees;
    
    select salary, commission_pct, department_id
    from employees;
    
    select count(salary), count(commission_pct), count(department_id)
    from employees;
    --      107             35                      106 / null 값을 제외한 갯수
    
    select sum(salary), avg(salary), max(salary), min(salary), count(salary)
         , variance(salary), stddev(salary)
    from employees;
    
    select count(*)
    from employees; -- 테이블 행의 수 ==> 모든 컬럼 값이 null 인 행은 없기 때문에 테이블 전체로 지정하면 테이블 행의 갯수가 반환된다.
    
    --- employees 테이블에서 기본급여(salary)의 평균치를 구하세요.
    select sum(salary), count(salary)
         , sum(salary)/count(salary)
         , avg(salary)
    from employees;
    
    --- employees 테이블에서 수당(salary * commission_pct)의 평균치를 구하세요.
    select sum(salary * commission_pct), count(salary * commission_pct)
         , sum(salary * commission_pct)/count(salary * commission_pct)
         , avg(salary * commission_pct)
    from employees;
    -- null 제외이므로 이 평균은 수당을 받는 사원들만을 평균 계산한 것이다.
    
    select avg(salary * commission_pct)
         , sum(salary * commission_pct)/count(salary * commission_pct) -- 수당을 받는 사원들만 평균
         
         , avg(nvl(salary * commission_pct, 0))
         , sum(salary * commission_pct)/count(*) -- 전체 평균
    from employees;
    
    -- null , 0 을 구분하자! (null, 1, 3, 5) (0, 1, 3, 5) => 최소값 : 1 != 0, 주의하자!
    
    --- **** employees 테이블에서 부서번호별 인원수를 나타내세요 **** ---
    select department_id AS 부서번호
         , count(*) AS 인원수 -- 각 부서에 몇명이 있는지
    from employees
    group by department_id
    order by 1;
    
    --- **** employees 테이블에서 부서번호별 인원수를 나타내세요.
    --       또한 모든 사원들의 총인원수도 나타내세요 **** ---
    select department_id AS 부서번호
         , count(*) AS 인원수
    from employees
    group by rollup(department_id); -- 실제 부서번호가 null 이거나 부서번호 그룹화하지 않은 null
    
    select grouping(department_id) -- department_id 컬럼의 값을 가지고 group을 지었을때 grouping(department_id) 값이 0 이라면 해당 department_id 컬럼은 실제 데이터값임을 알려주는 것이고, grouping(department_id) 값이 1 이라면 해당 department_id 컬럼은 실제 데이터가 아니라 group을 짓지 않은 전체라는 뜻이다.
         , department_id AS 부서번호
         , count(*) AS 인원수
    from employees
    group by rollup(department_id);
    
    select decode(grouping(department_id), 0, to_char(department_id), '전체') AS 부서번호
         , count(*) AS 인원수
    from employees
    group by rollup(department_id);
    
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , count(*) AS 인원수
    from employees
    group by rollup(department_id);
    
    
    /*
        employees 테이블
        -----------
        성별  인원수
        -----------
        남   56
        여   51
        전체  107 -- 추가
    */
    -- 1
    select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS 성별
         , count(*) AS 인원수
    from employees
    group by case when substr(jubun,7,1) in('1','3') then '남' else '여' end
    order by 1;
    -- 2
    select gender AS 성별
         , sum(genderno) AS 인원수
    from
    (
    select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS gender
         , count(*) AS genderno
    from employees
    group by substr(jubun,7,1)
    order by 1
    ) V
    group by gender
    order by 1;
    -- 전체 추가
    select decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
    from
    (
    select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS gender
    from employees
    ) V
    group by rollup(gender)
    
    --- **** employees 테이블에서 성별 인원수 퍼센티지를 나타내세요 **** ---
        ---------------------
        성별  인원수 퍼센티지(%)(소수점 한자리까지)
        ---------------------
        남   56      52.3
        여   51      47.7
        전체 -- 추가
        
    select gender AS 성별
         , count(*) AS 인원수
         , round(count(*)/(select count(*) from employees) * 100, 1) AS "퍼센티지(%)" -- 전체 인원 수는 employees 테이블의 행의 갯수이기 때문에 select문을 이용하여 구한다.
    from
    (
    select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS gender
    from employees -- 처음부터 그룹화하지 않고 주민번호를 이용해 성별 칼럼을 만들어 해당 뷰를 이용해 인원 수와 퍼센티지를 구한다.
    ) V
    group by gender
    order by 1;
    -- 전체 추가
    select decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*)/(select count(*) from employees) * 100, 1) AS "퍼센티지(%)" -- 전체 인원 수는 employees 테이블의 행의 갯수이기 때문에 select문을 이용하여 구한다.
    from
    (
    select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS gender
    from employees -- 처음부터 그룹화하지 않고 주민번호를 이용해 성별 칼럼을 만들어 해당 뷰를 이용해 인원 수와 퍼센티지를 구한다.
    ) V
    group by rollup(gender)
    
    ----------------------------------------------------------------------------------------------------------------
    -- employees 테이블에서 부서번호별 기본급여의 합계를 나타내세요.
    -- 또한 모든 부서에 대한 기본급여의 총합계도 나타내세요.
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , sum(salary) AS 기본급여합계
    from employees
    group by rollup(department_id);
    
    -- employees 테이블에서 부서번호별 기본급여의 평균을 나타내세요.
    select department_id AS 부서번호, trunc(avg(salary)) AS 기본급여평균
    from employees
    group by department_id
    order by department_id;
    
    -- employees 테이블에서 부서번호별 기본급여의 최대값을 나타내세요.
    select department_id AS 부서번호, max(salary) AS 기본급여최대값
    from employees
    group by department_id
    order by department_id;
    
    -- employees 테이블에서 부서번호별 기본급여의 최소값을 나타내세요.
    select department_id AS 부서번호, min(salary) AS 기본급여최대값
    from employees
    group by department_id
    order by department_id;
    
    -- [퀴즈] employees 테이블에서 연령대별로 인원수와 퍼센티지(%)를 나타내뇌
    --        전체사원수도 나오도록 하세요...
    
    -------------------------------
    연령대     인원수     퍼센티지(%)
    -------------------------------
    0
    10
    ...       ...       ...
    전체       107       100
    
    select decode(grouping(age_group), 0, to_char(age_group), '전체') AS 연령대
         , count(*) AS 인원수
         , round((count(*) / (select count(*) from employees) * 100), 1) AS "퍼센티지(%)"
    from
    (
    select trunc((extract(year from sysdate) - (substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1), -1) AS age_group
    from employees
    ) V
    group by rollup(age_group);
    
    ---- **** inline view 를 with 절을 사용하여 나타낼수 있다. **** ----
    --- employees 테이블에서 성별, 인원수를 나타내세요. ---
    /*
        employees 테이블
        -----------
        성별  인원수
        -----------
        남   56
        여   51
    */
    
    with V as (
        select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) -- inline view
    
    select gender AS 성별
         , count(*) AS 인원수
    from V
    group by gender
    order by 2 desc; -- 같이 묶어서 실행
    
    /*
        -----------
        성별  인원수
        -----------
        남   56
        여   51
        전체  107
    */
    
    with V as (
        select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    )
    
    select decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
    from V
    group by rollup(gender)
    
    -------------------------------
    연령대     인원수     퍼센티지(%)
    -------------------------------
    0
    10
    ...       ...       ...
    전체       107       100
    
    with V as(
        select trunc((extract(year from sysdate) - (to_number(substr(jubun,1,2)) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1), -1) AS age_group
        from employees
    )
    
    select decode(grouping(age_group), 0, to_char(age_group), '전체') AS 연령대
         , count(*) AS 인원수
         , round((count(*) / (select count(*) from employees) * 100), 1) AS "퍼센티지(%)"
    from V
    group by rollup(age_group);
    
    
    --- *** 그룹을 지을때 1차로 그룹을 지은 다음에 거기서 다시한번 2차로 또 그룹을 지을수 있다. *** ---
    ----------------------
    부서번호    성별  인원수
    ----------------------
        10      남
        10      여
        20      남
        20      여
        30      남
        30      여
        ......
        전체      남   56
        전체      여   51
        전체      전체 107
        
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
    from
    (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) V
    group by rollup(department_id, gender); -- 1차 그룹: 부서번호, 2차 그룹: 성별
    
    
    with V as (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    )
    
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
    from V
    group by rollup(department_id, gender);
    
    -------------------------------------
    부서번호    성별  인원수     퍼센티지(%)
    -------------------------------------
        10      남
        10      여
        20      남
        20      여
        30      남
        30      여
        ......
        전체      남   56
        전체      여   51
        전체      전체 107      100
        
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from
    (
    select department_id
         , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
    from employees
    ) V
    group by rollup(department_id, gender);
    
    with V as(
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    )
    
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from V
    group by rollup(department_id, gender);
    
    
    ----- >>>>> 요약값(rollup, cube, grouping sets) <<<<< ------
  /*
      1. rollup(a,b,c) == grouping sets( (a,b,c),(a,b),(a),() ) 
    
            group by rollup(department_id, gender)
         == group by grouping sets( (department_id, gender), (department_id), () )
  
      2. cube(a,b,c) == grouping sets( (a,b,c),(a,b),(b,c),(a,c),(a),(b),(c),() ) -- 모든 경우의 수, 3개 그룹 -> 모든 2개 경우의 그룹 -> 모든 1개 경우의 그룹 -> 그룹 짓지 않는 전체
 
            group by cube(department_id, gender)
         == group by grouping sets( (department_id, gender), (department_id), (gender), () )
  */
  
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from
    (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) V
    group by rollup(department_id, gender);
    
    --- 또는
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from
    (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) V
    group by grouping sets((department_id, gender), (department_id), ());  -- 1. 동일 부서 내에서 성별끼리 그룹 2. 부서번호끼리 그룹 3. 그룹짓지 않은 전체 ==> roll up 의 방식(그룹이란 같은 데이터값을 같는 것끼리 묶는 것임을 생각)
    
    
    --- *** cube *** ---
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from
    (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) V
    group by cube(department_id, gender)
    order by 1,2;
    
    --- 또는
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from
    (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) V
    group by grouping sets((department_id, gender), (department_id), (gender), ());
    
    
    --- grouping sets --- 원하는 것만 그룹지을 수 있다
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from
    (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) V
    group by grouping sets((department_id), (gender), ());
    
    
    ---- *** having 그룹함수 조건절 *** ----
    --- group by 절을 사용하여 그룹함수의 값을 나타내었을 때 그룹함수의 값이 특정 조건에 해당하는 것만 추출하고자 할때는
    --- where 절을 사용하는 것이 아니라 having 그룹함수 조건절을 사용해야 한다.
    
    -- employees 테이블에서 10명 이상 근무하는 부서번호와 그 인원수를 나타내세요.
    select department_id, count(*)
    from employees
    where count(*) >= 10
    group by department_id; -- 오류(어떤 그룹의 결과 개수인지 문장 구조 순서상 알 수 없기 때문에)
    
    select department_id AS 부서번호
         , count(*) AS 인원수
    from employees
    group by department_id
    having count(*) >= 10 -- 그룹함수(count)는 그룹이 지어진 다음에 쓸 수 있다
    order by 2;
    
    -- employees 테이블에서 부서번호별로 월급의 합계를 나타내었을 때
    -- 부서번호별 월급의 합계가 50000 이상인 부서에 대해서만
    -- 부서번호, 월급의 합계를 나타내세요.
    select department_id AS 부서번호, sum(mon_salary) AS "월급의 합계"
    from
    (
    select department_id, nvl(salary + (salary*commission_pct), salary) AS mon_salary
    from employees
    ) V
    group by department_id
    having sum(mon_salary) >= 50000;
    

             ---- *** !!!! 누적에 대해서 알아봅니다. !!!! *** ----
 /*
   --  sum(누적되어야할 컬럼명) over(order by 누적되어질 기준이 되는 컬럼명 asc[desc]) -- 정렬 기준에 따라 누적합계가 달라진다.
    
   --  sum(누적되어야할 컬럼명) over(partition by 그룹화 되어질 컬럼명 
                                  order by 누적되어질 기준이 되는 컬럼명 asc[desc])  
 */
            
 create table tbl_panmae
 (panmaedate  date
 ,jepumname   varchar2(20)
 ,panmaesu    number
 );

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-2), '새우깡', 10);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-2)+1, '새우깡', 15); 

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-2)+2, '감자깡', 20);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-2)+3, '새우깡', 10);
 
 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-2)+3, '새우깡', 3);
 
 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-1), '고구마깡', 7);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-1)+1, '새우깡', 8); 

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-1)+2, '감자깡', 10);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-1)+3, '감자깡', 5);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate - 4, '허니버터칩', 30);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate - 3, '고구마깡', 15);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate - 2, '고구마깡', 10);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate - 1, '허니버터칩', 20);


 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '새우깡', 10);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '새우깡', 10);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '감자깡', 5);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '허니버터칩', 15);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '고구마깡', 20);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '감자깡', 10); 

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '새우깡', 10);

 commit;
 
 select *
 from tbl_panmae;
 
    select to_char(panmaedate, 'yyyy-mm-dd hh24:mi:ss') AS panmaedate, panmaesu
    from tbl_panmae
    where jepumname = '새우깡';
    
    ---------------------------------------
    판매일자        일별판매량   일별누적판매량
    ---------------------------------------
    2020-06-18      10          10
    2020-06-19      15          25
    2020-06-21      13          38
    2020-07-19      8           46
    2020-08-18      30          76
    
    select to_char(panmaedate, 'yyyy-mm-dd') AS 판매일자
         , sum(panmaesu) AS 일별판매량
         , sum(sum(panmaesu)) over(order by to_char(panmaedate, 'yyyy-mm-dd') asc) AS 일별누적판매량 -- 개별 판매량이 아닌 그룹화된 일별 판매량이 누적되어야 하므로 sum(sum(panmaesu))
    from tbl_panmae
    where jepumname = '새우깡'
    group by to_char(panmaedate, 'yyyy-mm-dd');
    
    --- *** tbl_panmae 테이블에서 모든 제품에 대한 일별판매량과 일별누적판매량을 나타내세요 *** ---
    -------------------------------------------------
    제품명     판매일자        일별판매량   일별누적판매량
    -------------------------------------------------
    
    select jepumname AS 제품명
         , to_char(panmaedate, 'yyyy-mm-dd') AS 판매일자
         , sum(panmaesu) AS 일별판매량
      -- , sum(sum(panmaesu)) over (order by jepumname asc, to_char(panmaedate, 'yyyy-mm-dd') asc) AS 일별누적판매량 -- 이는 정렬은 하되 제품별로 누적을 끊지 않고 전체 누적을 한다.
         , sum(sum(panmaesu)) over (partition by jepumname order by to_char(panmaedate, 'yyyy-mm-dd') asc) AS 일별누적판매량 -- 이는 제품별 전체 누적이 아닌 제품별 누적으로 파티션을 나눈다.
    from tbl_panmae
    group by jepumname, to_char(panmaedate, 'yyyy-mm-dd');
    
    
  ---------------------------------------------------------------------------------
  
  ---- *** 아래처럼 나오도록 하세요 *** ----
  
  --------------------------------------------------------------
  전체사원수     10대미만   10대   20대  30대  40대  50대  60대
  --------------------------------------------------------------
    107	            2     14	21	  19	21	  18	12
  
  --- 오라클 11g 이전에는 아래와 같이 구했다. 
  select count(*) as "전체사원수"
       , sum( decode(V.AGELINE, 0, 1) )  as "10대미만"
       , sum( decode(V.AGELINE, 10, 1) ) as "10대"
       , sum( decode(V.AGELINE, 20, 1) ) as "20대"
       , sum( decode(V.AGELINE, 30, 1) ) as "30대"
       , sum( decode(V.AGELINE, 40, 1) ) as "40대"
       , sum( decode(V.AGELINE, 50, 1) ) as "50대"
       , sum( decode(V.AGELINE, 60, 1) ) as "60대"
   from 
   (
     select trunc( extract(year from sysdate) - (to_number(substr(jubun, 1, 2)) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 , -1) as AGELINE 
     from employees
   ) V;
  
  -- **** PIVOT ==> Oracle 11g부터 제공하는 것으로써, 행을 열로 변환하고자 할 때 사용하는 방법으로서 기존의 GROUP BY 와 집계함수(MAX, SUM 등), DECODE 나 CASE 를 사용하는 방법 대신 좀 더 간결하게 해준다.
   --      1. PIVOT 절은 그룹함수가 적용될 컬럼을 정의하는 것으로서 마치 GROUP BY가 들어간 쿼리에서 SELECT SUM(SALARY), AVG(SALARY), COUNT(SALARY) 구절과 같다.
   --      2. PIVOT FOR 절은 피봇의 기준의 되는 컬럼을 정의하는 것으로서 마치 GROUP BY 절에 뒤따르는 컬럼과 같은 역할로 이해하면 된다.
   --         SELECT 절의 SUM(SALARY), AVG(SALARY), COUNT(SALARY) 가 PIVOT 절의 역할이라면, GROUP BY DEPARTMENT_ID 는 PIVOT FOR의 역할이다.
   --      3. PIVOT IN 절은 PIVOT FOR 절에서 정의한 컬럼에서 필터링을 정의하는 것으로서 마치 SQL 중 WHERE DEPARTMENT_ID IN(10, 20)은 PIVOT IN 절의 역할이다.
   --         또한 PIVOT IN 절은 Subquery 는 포함 할 수 없으나 Alias 정의는 가능하다.

    --------------------------------------------
    10대미만   10대   20대  30대  40대  50대  60대
    --------------------------------------------
        2	  14	 21    19	 21   18    12
   
   with V as (
     select trunc( extract(year from sysdate) - (to_number(substr(jubun, 1, 2)) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 , -1) as AGELINE 
     from employees
   )
-- select "10대미만", "20대"
   select * -- *은 PIVOT IN에서 정의한 그룹 전체를 컬럼
   from V
   PIVOT(COUNT(AGELINE)  -- 그룹함수
         FOR AGELINE -- FOR 그룹
         IN(0 AS "10대미만", 10 AS "10대", 20 AS "20대", 30 AS "30대", 40 AS "40대", 50 AS "50대", 60 AS "60대"));  -- 보여줄(메모리에 올릴) 그룹 나열
         
         
  ----------------------------------------------------------------------------------
  select department_id AS 부서번호
       , count(*) AS 인원수 
  from employees
  where department_id in (30,60)
  group by department_id;
  
  -------------------------------------------------------
  
  ----------------------------
    부서번호30      부서번호60
  ----------------------------
       6              5
  
  select department_id
       , case department_id when 30 then 1 end
       , case department_id when 60 then 1 end
  from employees
  where department_id in (30,60);
  
  --- 오라클 11g 이전에는 아래와 같이 구했다. 
  select sum(case department_id when 30 then 1 end) AS 부서번호30
       , sum(case department_id when 60 then 1 end) AS 부서번호60
  from employees
  where department_id in (30,60);
  
  -- 오라클 11g 에서는 아래와 같이 pivot 을 사용하여 나타낼수 있다.
  with V as (select department_id 
             from employees
             where department_id in (30,60))
  select 부서번호30, 부서번호60           
  from V
  pivot( count(department_id)
         for department_id
         in(30 as 부서번호30, 60 as 부서번호60) );
         
         
    ----- **** PIVOT 예제) 아래처럼 나오도록 하세요 **** -----
    
    -------------------------------------------------------
     직종ID       남자평균급여      여자평균급여      평균급여
    -------------------------------------------------------

    -- PIVOT 을 사용하지 않는 방법 --
    select job_id AS 직종ID
         , nvl(to_char(round(avg(decode(gender, '남', salary))), '999,999'), ' ') AS 남자평균급여 -- 여성일 경우 null 값이므로 평균 계산 시 제외된다, ''은 null, ' '이 공백
         , nvl(to_char(round(avg(decode(gender, '여', salary))), '999,999'), ' ') AS 여자평균급여
         , to_char(round(avg(salary)), '999,999') AS 평균급여
    from
    (
        select job_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
             , salary
        from employees
    ) V
    group by job_id;
    
    -- === [과제] NULL 을 공백으로 처리하세요 ===
    select job_id AS 직종ID
         , nvl(to_char(round(avg(decode(gender, '남', salary))), '99,999'), ' ') AS 남자평균급여 -- 공백은 문자이므로 통일 위해 형변환 필요, ''은 null, ' '이 공백
         , nvl(to_char(round(avg(decode(gender, '여', salary))), '99,999'), ' ') AS 여자평균급여
         , to_char(round(avg(salary)), '99,999') AS 평균급여
    from
    (
        select job_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
             , salary
        from employees
    ) V
    group by job_id;
    
    -- PIVOT 을 사용하여 구하는 방법 --
    with V as (select job_id
                    , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
                    , salary
               from employees)
    
    select job_id AS 직종ID, trunc(남자평균급여) AS 남자평균급여, trunc(여자평균급여) AS 여자평균급여
    from V
    pivot(avg(salary) -- 아래의(for gender) 남 및 여 열에 보여질 데이터 값을 정의한다.
          for gender  -- 남, 여로 보여지는 행을 남, 여 열로 바꾸려고 한다.
          in('남' AS 남자평균급여, '여' AS 여자평균급여)) -- 열로 보여줄 데이터를 필터링한다.
          
    --- *** UNPIVOT ==> 열을 행으로 변경하고자 할 때 사용하는 것으로서,
    --                  열을 행으로 변경하고자 하는 컬럼명과 데이터 영역을 선정해야 한다.
    
    select first_name || ' ' || last_name AS ENAME
         , SALARY
         , (salary * commission_pct) AS COMM
    from employees;
    
    with V as (select first_name || ' ' || last_name AS ENAME
                    , SALARY
                    , (salary * commission_pct) AS COMM
               from employees)
    select ename, colname, datavalue           
    from V
    unpivot(DATAVALUE           -- 데이터 영역의 컬럼명을 지정해주는 것
            for COLNAME         -- 열 영역의 컬럼명을 지정해주는 것
            in(salary, comm));  -- 데이터 영역으로 들어올 컬럼명르 지정해주는 것, NULL 은 표현되지 않음.
            

    ------ !!! 중요 JOIN 은 면접에 가면 무조건 물어봅니다. !!! ------
            ------ ==== **** JOIN **** ==== ------
/*
    JOIN(조인)은 테이블(뷰)과 테이블(뷰)을 합치는 것을 말하는데
    행(ROW)과 행(ROW)을 합치는 것이 아니라, 컬럼(COLUMN)과 컬럼(COLUMN)을 합치는 것을 말한다.
    위에서 말한 행(ROW)과 행(ROW)을 합치는 것은 UNION 연산자를 사용하는 것이다.
    
    Q. INNER JOIN 과 OUTER JOIN 의 차이점에 대해서 말해보세요.
    Q. JOIN 과 UNION의 차이점에 대해서 말해보세요.
    
    A = {1, 2, 3} 원소가 3개
    B = {a, b}    원소가 2개
    
    A ⊙ B = { (1,a), (1,b)
               (2,a), (2,b)
               (3,a), (3,b) } -- 집합 A와 B의 원소 조합의 모든 경우의 수
    데카르트(수학) ==> 원소의 곱 : 3*2 = 6개(모든 경우의 수)
    --> 수학에서 말하는 데카르트곱을 데이터베이스에서는 Catersian Product 라고 부른다.
    
    JOIN => 1. SQL 1992 CODE 방식 --> 테이블(뷰)과 테이블(뷰) 사이에 콤마(,)를 찍어주는 것.
                                     데이터베이스 밴더(회사) 제품마다 문법이 조금씩 다르다.
         => 2. SQL 1999 CODE 방식(ANSI, 표준) --> 테이블(뷰)과 테이블(뷰) 사이에 JOIN 이라는 명령어를 넣어주는 것.
                                                 ANSI(표준화) SQL
*/

    select *
    from employees;
    
    select count(*)
    from employees; -- 107개 행
    
    select *
    from departments;
    
    select count(*)
    from departments; -- 27개 행
    
    select *
    from employees , departments; --> SQL 1992 CODE 방식
    
    select count(*)
    from employee*s , departments; --> SQL 1992 CODE 방식
                                   -- 2889개 행
                                   
    select 107*27 -- 2889 ==> 모든 경우의 수, 모든 직원이 10번 부서부터 마지막 부서까지의 경우의 수 모두 적용
    from dual;
    
    select *
    from employees cross join departments; --> SQL 1999 CODE 방식, Catersian Product
    
    select count(*)
    from employee*s cross join departments; --> SQL 1999 CODE 방식
                                   -- 2889개 행
                                   
    -- cross join 은 프로야구를 예를 들면 10개팀이 있는데
    -- 각 팀당 경기를 몇번해야 하는지 구할 때 쓰인다. 1팀당 모든 팀과 경기를 펼쳐야 한다.
    -- cross join 은 그룹함수로 나온 1개의 행을 가지고 어떤 데이터 값을 얻으려고 할때 사용한다.
    
    -- 사원번호  사원명  부서번호  기본급여  전체사원의평균급여  평균급여와의차액
    -- 위와 같이 나오도록 구하세요.
    select trunc(avg(salary)) AS AVGSAL
    from employees; -- 6461, 1개 행
    
    select employee_id, first_name || ' ' || last_name, department_id, salary
    from employees; -- 이 테이블 옆에 평균급여 컬럼을 찍어줘야 한다, 하지만 행 갯수가 다르므로 그냥 결합X, 107개 행
    
    -- 107 * 1 ==> 107
    -- 콤마
    select employee_id AS 사원번호, ename AS 사원명, department_id AS 부서번호, salary AS 기본급여, avgsal AS 전체사원의평균급여, salary - avgsal AS 평균급여와의차액
    from
    (
    select employee_id, first_name || ' ' || last_name AS ENAME, department_id, salary
    from employees
    ) A
    ,
    (
    select trunc(avg(salary)) AS AVGSAL
    from employees
    ) B;
    
    -- cross join
    select employee_id AS 사원번호, ename AS 사원명, department_id AS 부서번호, salary AS 기본급여, avgsal AS 전체사원의평균급여, salary - avgsal AS 평균급여와의차액
    from
    (
    select employee_id, first_name || ' ' || last_name AS ENAME, department_id, salary
    from employees
    ) A
    cross join
    (
    select trunc(avg(salary)) AS AVGSAL
    from employees
    ) B;
    
    
    ---- **** EQUI JOIN **** ----
    -- 부서번호  부서명  사원번호  사원명  기본급여
    -- 위와 같이 나오도록 하세요
    
    /*
        부서번호        부서명         사원번호  사원명  기본급여
        -------        -----         -----------------------
        departments    departments          employees
        employees
    */
    
    select *
    from employees , departments
    where employees.department_id = departments.department_id -- 조인조건절: 두 테이블을 합칠 때 기준이 되는 조건
    order by employees.employee_id asc;
    
    select *
    from employees E , departments D -- 별칭
    where E.department_id = D.department_id
    order by E.employee_id asc;
    
    select *
    from employees E , departments D
    where employees.department_id = departments.department_id -- 별칭 부여 시 원래 테이블명은 사용할 수 없다 => 오류!!
    order by E.employee_id asc;
    
    select department_id AS 부서번호 -- 두 테이블 모두에 속해 있다. 
         , department_name AS 부서명 -- 부서 테이블에만 있다, 중복된 컬럼이 아닐 경우는 상관X
         , employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E , departments D
    where E.department_id = D.department_id
    order by E.employee_id asc;
    -- column ambiguously defined(애매한 컬럼 정의)
    
    select E.department_id AS 부서번호 -- 중복된 컬럼은 반드시 테이블 하나를 지정해주어야 한다.
         , department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E , departments D
    where E.department_id = D.department_id
--  order by employee_id asc; -- 사원 테이블에만 있으므로 E. 생략 가능
    order by D.department_id asc, employee_id; -- 1992 CODE 방식
    -- 부서번호가 없는 Kimberely는 빠져 있다.
    
    -- employees 테이블에서 사원들이 실제 근무하고 있는 부서번호를 나타내세요
    select distinct department_id
    from employees;
    -- select 바로 다음에 distinct 를 사용하면 select 되어진 행 중에 중복된 행 값이 있으면
    -- 중복을 제거해주고 한번만 보여주게끔 해주는 것이다.
    
    select *
    from departments; -- 부서번호가 10~110 120~270
    
    select E.department_id AS 부서번호
         , department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E , departments D
    where E.department_id(+) = D.department_id  -- (+)가 없는 쪽 테이블의 모든 행들을 출력해준 다음에 조인조건절로 매핑시킨다.
    order by D.department_id asc, employee_id;
    
    select E.department_id AS 부서번호
         , department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E , departments D
    where E.department_id = D.department_id(+)
    order by D.department_id asc, employee_id;
    
    -- 1999 CODE 방식
    ---- *** INNER JOIN(내부조인) *** ----
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E inner join departments D
    on E.department_id = D.department_id  -- 조인조건절
    order by D.department_id asc, employee_id;
    
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E join departments D  -- **** inner 는 생략이 가능 ****
    on E.department_id = D.department_id
    order by D.department_id asc, employee_id;
    
    
    ---- *** OUTER JOIN(외부조인) *** ----
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E left outer join departments D  -- LEFT는 명령어를 기준으로 왼쪽 테이블에 있는 모든 행들을 출력해준 다음 조인조건절로 매핑시킨다.
    on E.department_id = D.department_id
    order by D.department_id, employee_id;
    
    -- OUTER 는 생략가능하다.
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E left join departments D
    on E.department_id = D.department_id
    order by D.department_id, employee_id;
    
    
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E right outer join departments D  -- RIGHT는 명령어를 기준으로 오른쪽 테이블에 있는 모든 행들을 출력해준 다음 조인조건절로 매핑시킨다.
    on E.department_id = D.department_id
    order by D.department_id, employee_id;
    
    -- OUTER 는 생략가능하다.
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E right join departments D
    on E.department_id = D.department_id
    order by D.department_id, employee_id;
    
    
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E full outer join departments D  -- FULL은 명령어를 기준으로 양쪽 테이블에 있는 모든 행들을 출력해준 다음 조인조건절로 매핑시킨다.
    on E.department_id = D.department_id
    order by D.department_id, employee_id;
    
    -- OUTER 는 생략가능하다.
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E full join departments D  -- FULL은 명령어를 기준으로 양쪽 테이블에 있는 모든 행들을 출력해준 다음 조인조건절로 매핑시킨다.
    on E.department_id = D.department_id
    order by D.department_id, employee_id;
    
    
    -- SQL 1999 CODE 방식은
    -- 1. 모든 경우의 수(Catersian Product) ==> CROSS JOIN
    -- 2. NULL 은 제외한 조인 ==> (INNER) JOIN
    -- 3. NULL 까지 보여주는 조인 ==> LEFT (OUTER) JOIN, RIGHT (OUTER) JOIN, FULL (OUTER) JOIN
    
    -- 부서번호  사원번호  사원명  기본급여  부서평균급여  평균급여와의차액
    -- 위와 같이 나오도록 구하세요.
    
/*
    부서번호별  평균급여         부서번호  사원번호  사원명  기본급여
    ------------------        ---------------------------------
        10      ...             10      1122    홍길동   3700
        20      ...             10      1133    이순신   3000
        30      ...             20      1144    엄정화   5000
        ..      ...             ..      ....     ...    ....
        
            V                           employees E
            
        조인조건절 ==> V.부서번호 = E.부서번호
*/

    select department_id, trunc(avg(salary)) AS AVGSAL
    from employees
    group by department_id;
    
    select E.department_id AS 부서번호
         , employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , salary AS 기본급여
         , avgsal AS 부서평균급여
         , salary - avgsal AS 부서평균급여와의차액
    from employees E join
    (
    select nvl(department_id, -9999) AS department_id, trunc(avg(salary)) AS AVGSAL
    from employees
    group by department_id
    ) V
    on nvl(E.department_id, -9999) = V.department_id -- left join으로는 조인조건절 null = null 을 매핑할 수 없다(null 값을 기준으로 매핑하여 null 값이 아닌 값을 보이고자할 때는 nvl())
    order by 1, 4 desc;
    
    -- [퀴즈] 부서번호  사원번호  사원명  기본급여  부서평균급여  부서평균급여와의차액  부서내급여등수  전체급여등수
    -- 위와 같이 나오도록 구하세요.
    /*
        부서번호  부서평균급여 / 사원번호  사원명  기본급여  평균급여  급여차액
               V                            employees E
    */
    
    select E.department_id AS 부서번호
         , employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , salary AS 기본급여
         , avgsal AS 부서평균급여
         , salary - avgsal AS 부서평균급여와의차액
         , rank() over(partition by E.department_id order by salary desc) AS 부서내급여등수
         , rank() over(order by salary desc) AS 전체급여등수
    from employees E join
    (
    select nvl(department_id, -9999) AS department_id, round(avg(salary)) AS AVGSAL
    from employees
    group by department_id
    ) V
    on nvl(E.department_id, -9999) = V.department_id
    order by 1, 7;
    
    -- [퀴즈] 부서번호가 10, 20, 30, 40, 50번 부서의 근무하는 사원들을 대상으로
    --        부서번호  사원번호  사원명  기본급여  부서평균급여  부서평균급여와의차액  부서내급여등수  전체급여등수
    --        위와 같이 나오도록 구하세요.
    
    select E.department_id AS 부서번호
         , employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , salary AS 기본급여
         , avgsal AS 부서평균급여
         , salary - avgsal AS 부서평균급여와의차액
         , rank() over(partition by E.department_id order by salary desc) AS 부서내급여등수
         , rank() over(order by salary desc) AS 전체급여등수
    from employees E join
    (
    select nvl(department_id, -9999) AS department_id, round(avg(salary)) AS AVGSAL
    from employees
    group by department_id
    ) V
    on nvl(E.department_id, -9999) = V.department_id
    where E.department_id between 10 and 50  -- where절은 조인조건절 다음에 온다, but 조건에 맞지 않는 데이터도 메모리에 올라가고 이후 걸러내기 때문에 메모리 낭비
    order by 1, 7;
    
    -- 2번 방법(권장)
    select E.department_id AS 부서번호
         , employee_id AS 사원번호
         , ename AS 사원명
         , salary AS 기본급여
         , avgsal AS 부서평균급여
         , salary - avgsal AS 부서평균급여와의차액
         , rank() over(partition by E.department_id order by salary desc) AS 부서내급여등수
         , rank() over(order by salary desc) AS 전체급여등수
    from
    (
        select department_id, employee_id, first_name || ' ' || last_name AS ENAME, salary
        from employees
        where department_id between 10 and 50
    ) E join
    (
        select department_id, round(avg(salary)) AS AVGSAL
        from employees
        where department_id between 10 and 50
        group by department_id
    ) V
    on E.department_id = V.department_id
    order by 1, 7;
    -- join 할 때는 필요한 조건과 컬럼만 뽑아서 합쳐 부하를 줄인다.
    
    
        ----- **** NON-EQUI JOIN **** -----
    -- 어떤 컬럼의 값이 특정 범위에 속할 때 사용하는 JOIN 이다.
    
    -- 소득세율 지표 관련 테이블을 생성한다. 
  create table tbl_taxindex
  (lowerincome   number       -- 연봉의 최저
  ,highincome    number       -- 연봉의 최대
  ,taxpercent    number(2,2)  -- 세율  -0.99 ~ 0.99 
  );
  -- 데이터 타입이 숫자인 것만 받고자 할 경우에는 number 타입을 사용한다.
  -- number       --> 숫자가 무제한으로 들어온다.
  -- number(4)    --> 4자리 수 의미: 숫자가 ~9999 ~ 9999 까지만 들어온다.
  -- number(5)    --> 5자리: 숫자가 ~99999 ~ 99999 까지만 들어온다.
  -- number(3,1)  --> 3자리 중 소수부 1자리: -99.9 ~ 99.9 까지만 들어온다.
  -- number(4,2)  --> 4자리 중 소수부 2자리: -99.99 ~ 99.99 까지만 들어온다.
  -- number(2,2)  --> 2자리 중 소수부 2자리: -0.99 ~ 0.99 까지만 들어온다.

  insert into tbl_taxindex(lowerincome,highincome,taxpercent)
  values(1, 99999, 0.02);

  insert into tbl_taxindex(lowerincome,highincome,taxpercent)
  values(100000, 149999, 0.05);

  insert into tbl_taxindex(lowerincome,highincome,taxpercent)
  values(150000, 199999, 0.08);

  insert into tbl_taxindex(lowerincome,highincome,taxpercent)
  values(200000, 10000000000000000, 0.1);

  commit;
  
  select *
  from tbl_taxindex;
  
  ------------------------------------
   사원번호  사원명  연봉  세율  소득세액
  ------------------------------------
   1001     홍길동 50000 0.02  50000*0.02
   1002     엄정화 250000 0.08 250000*0.08
   
   select employee_id AS 사원번호
        , first_name || ' ' || last_name AS 사원명
        , to_char(nvl(salary+(salary*commission_pct), salary)*12, '999,999') AS 연봉
        , taxpercent AS 세율
        , to_char(nvl(salary+(salary*commission_pct), salary)*12 * taxpercent, '99,999.9') AS 소득세액
   from employees E , tbl_taxindex T  -- SQL 1992 CODE
   where nvl(salary+(salary*commission_pct), salary)*12 between lowerincome and highincome -- 조인조건절, 테이블 값이 다른 테이블 컬럼의 값 사이에 있을 때 non-equi join
   order by 1;
   
   -- SQL 1999 CODE
   select employee_id AS 사원번호
        , first_name || ' ' || last_name AS 사원명
        , to_char(nvl(salary+(salary*commission_pct), salary)*12, '999,999') AS 연봉
        , taxpercent AS 세율
        , to_char(nvl(salary+(salary*commission_pct), salary)*12 * taxpercent, '99,999.9') AS 소득세액
   from employees join tbl_taxindex T
   on nvl(salary+(salary*commission_pct), salary)*12 between lowerincome and highincome
   order by 1;
   
   
        ----- **** SELF JOIN(자기조인) **** -----
    /*
        자기자신의 테이블(뷰)을 자기자신의 테이블(뷰)과 JOIN 시키는 것을 말한다.
        이때 반드시 테이블(뷰)에 대한 alias를 달리 주어서 실행해야 한다.
    */
    -------------------------------------------------------
     사원번호  사원명          이메일   급여  직속상관번호  직속상관명
     -------------------------------------------------------
     100    Steven King	    SKING   24000     null    null
     102    Lex	De Haan	    LDEHAAN 17000     100     Steven King
     103	Alexander Hunold AHUNOLD 9000     102     Lex De Haan
     104	Bruce Ernst	    BERNST   6000     103     Alexander Hunold
     
        first_name || ' ' || last_name   manager_id   first_name || ' ' || last_name -- 컬럼명은 같은데 보여주는 데이터는 다를 때 SELF JOIN
                                         employee_id -- 두 컬럼의 값으로 매핑
     
     -- SQL 1992 CODE
     select E1.employee_id AS 사원번호                          -- E1
          , E1.first_name || ' ' || E1.last_name AS 사원명      -- E1
          , E1.email AS 이메일                                 -- E1
          , E1.salary AS 급여                                  -- E1
          , E2.employee_id AS 직속상관번호                      -- E2, E1이면 manager_id
          , E2.first_name || ' ' || E2.last_name AS 직속상관명  -- E2
     from employees E1 , employees E2
     where E1.manager_id = E2.employee_id(+)
     order by E1.employee_id;
     
     -- SQL 1999 CODE
     select E1.employee_id AS 사원번호                          -- E1
          , E1.first_name || ' ' || E1.last_name AS 사원명      -- E1
          , E1.email AS 이메일                                 -- E1
          , E1.salary AS 급여                                  -- E1
          , E2.employee_id AS 직속상관번호                      -- E2, E1이면 manager_id
          , E2.first_name || ' ' || E2.last_name AS 직속상관명  -- E2
     from employees E1 left join employees E2
     on E1.manager_id = E2.employee_id
     order by E1.employee_id;
     

    -- [퀴즈] --
   create table tbl_authorbook
   (bookname       varchar2(100)
   ,authorname     varchar2(20)
   ,loyalty        number(5)
   );
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('자바프로그래밍','최은지',1000);
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('로빈슨크루소','이영경',800);
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('로빈슨크루소','최은지',500);
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('조선왕조실록','안세형',2500);
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('그리스로마신화','박지현',1200);
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('그리스로마신화','이지은',1300);
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('그리스로마신화','박수빈',1700);

   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('어린왕자','김동휘',1800);
   
   commit;
   
   select *
   from tbl_authorbook;
   
   /*
        tbl_authorbook 테이블에서 공저(도서명은 동일하지만 작가명이 다른 도서)로 지어진
        도서정보를 나타내세요(SELF JOIN 을 사용해서 풀이)
   */
   -------------------------------
    도서명     작가명     로얄티
    ------------------------------
    로빈슨크루소	이영경	800
    로빈슨크루소	최은지	500
    그리스로마신화	박지현	1200
    그리스로마신화	이지은	1300
    그리스로마신화	박수빈	1700
    
    select distinct B1.bookname AS 도서명
                  , B1.authorname AS 작가명
                  , B1.loyalty AS 로얄티
    from tbl_authorbook B1 join tbl_authorbook B2
    on B1.bookname = B2.bookname and B1.authorname != B2.authorname
    order by 1;


    ----- **** MULTI (Table) JOIN(다중 테이블 조인) **** -----
    --> 3개 이상의 테이블(뷰)을 가지고 조인하는 것이다.
    /*
        -----------------------------------------------------------------------
         부서번호   부서명     국가명     부서주소    사원번호    사원명     기본급여
        -----------------------------------------------------------------------
        부서번호 => departments.department_id
                => employees.department_id
        부서번호 컬럼을 가지고 departments 테이블과 employees 테이블 사이에 조인조건절을 만들어 JOIN 할 수 있다.
        
        부서명 => departments.department_name
        
        국가명 => countries.country_name
        
        부서주소 => locations.street_address
                   locations.city
                   locations.state_province
                   
        사원번호 사원명 기본급여 => employees
        
    */
    
    select *
    from employees;   -- E.department_id
    
    select *
    from departments; -- D.department_id    D.location_id
    
    select *
    from locations;   -- L.location_id  L.country_id
    
    select *
    from countries;   -- C.country_id
    
    -- SQL 1992 CODE
    select E.department_id AS 부서번호
         , department_name AS 부서명
         , country_name AS 국가명
         , street_address || ' ' || city || ' ' || state_province AS 부서주소
         , employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , salary AS 기본급여
    from employees E , departments D , locations L , countries C
    where E.department_id = D.department_id and
          D.location_id = L.location_id and
          L.country_id = C.country_id
    order by 1;
    
    -- SQL 1999 CODE
    select E.department_id AS 부서번호
         , department_name AS 부서명
         , country_name AS 국가명
         , street_address || ' ' || city || ' ' || state_province AS 부서주소
         , employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , salary AS 기본급여
    from employees E join departments D  -- 한 번에 모두 join 할 수 없다, 두 개 먼저 join 하고, 추가로 계속 join 하는 방식.
    on E.department_id = D.department_id
    join locations L
    on D.location_id = L.location_id
    join countries C
    on L.country_id = C.country_id
    order by 1;
    
    -- SQL 1992 CODE null 값 출력
    select E.department_id AS 부서번호
         , department_name AS 부서명
         , country_name AS 국가명
         , street_address || ' ' || city || ' ' || state_province AS 부서주소
         , employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , salary AS 기본급여
    from employees E , departments D , locations L , countries C
    where E.department_id = D.department_id(+) and
          D.location_id = L.location_id(+) and
          L.country_id = C.country_id(+)  -- (+)도 꼬리 물어 모두 붙여주어야 한다
    order by 1;
    
    -- SQL 1999 CODE null 값 출력
    select E.department_id AS 부서번호
         , department_name AS 부서명
         , country_name AS 국가명
         , street_address || ' ' || city || ' ' || state_province AS 부서주소
         , employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , salary AS 기본급여
    from employees E left join departments D
    on E.department_id = D.department_id
    left join locations L
    on D.location_id = L.location_id
    left join countries C
    on L.country_id = C.country_id  -- 마찬가지로 끝까지 left join 해주어야 한다
    order by 1;
    
    select *
    from tbl_taxindex;
    
    
    --- [과제] ---   107명이 나와야 함!!!!
  -------------------------------------------------------------------------------------------------------------------------------------
   부서번호   부서명   부서주소  부서장성명  사원번호  사원명  연봉  연봉소득세액  부서내연봉평균차액   부서내연봉등수
  -------------------------------------------------------------------------------------------------------------------------------------
    e,d       d      d-l-c      d-e/name   e      e/name     e     e-tbl_tax     V(부서연봉평균)       테이블 속성 추가
    -- 1
    select A1.department_id AS 부서번호
         , A1.department_name AS 부서명
         , A1.department_address AS 부서주소
         , A2.ename AS 부서장성명
         , A1.employee_id AS 사원번호
         , A1.ename AS 사원명
         , A1.totsalary AS 연봉
         , A1.salary_tax AS 연봉소득세액
         , A1.diff_sal AS 부서내연봉평균차액
         , rank() over(partition by A1.department_id order by A1.totsalary desc) AS 부서내연봉등수
    from
    (
        select E.department_id
             , department_name
             , street_address || ' ' || city || ' ' || state_province AS DEPARTMENT_ADDRESS
             , E.manager_id
             , employee_id
             , first_name || ' ' || last_name AS ENAME
             , to_char(nvl(salary+(salary*commission_pct), salary)*12, '999,999') AS TOTSALARY
             , to_char(nvl(salary+(salary*commission_pct), salary)*12 * taxpercent, '99,999.9') AS SALARY_TAX
             , to_char(nvl(salary+(salary*commission_pct), salary)*12 - avgsal, '999,999') AS DIFF_SAL
        from employees E left join departments D
        on E.department_id = D.department_id
        left join locations L
        on D.location_id = L.location_id
        left join countries C
        on L.country_id = C.country_id
        left join tbl_taxindex T
        on nvl(salary+(salary*commission_pct), salary)*12 between lowerincome and highincome
        left join (
            select department_id, round(avg(nvl(salary+(salary*commission_pct), salary)*12)) AS AVGSAL
            from employees
            group by department_id
        ) V
        on E.department_id = V.department_id
    ) A1
    left join
    (
        select E.department_id
             , department_name
             , street_address || ' ' || city || ' ' || state_province AS DEPARTMENT_ADDRESS
             , E.manager_id
             , employee_id
             , first_name || ' ' || last_name AS ENAME
             , to_char(nvl(salary+(salary*commission_pct), salary)*12, '999,999') AS TOTSALARY
             , to_char(nvl(salary+(salary*commission_pct), salary)*12 * taxpercent, '99,999.9') AS SALARY_TAX
             , to_char(nvl(salary+(salary*commission_pct), salary)*12 - avgsal, '999,999') AS DIFF_SAL
        from employees E left join departments D
        on E.department_id = D.department_id
        left join locations L
        on D.location_id = L.location_id
        left join countries C
        on L.country_id = C.country_id
        left join tbl_taxindex T
        on nvl(salary+(salary*commission_pct), salary)*12 between lowerincome and highincome
        left join (
            select department_id, round(avg(nvl(salary+(salary*commission_pct), salary)*12)) AS AVGSAL
            from employees
            group by department_id
        ) V
        on E.department_id = V.department_id
    ) A2
    on A1.manager_id = A2.employee_id
    order by 1,10;
    -- 2
    with V as (
        select nvl(department_id, -9999) AS department_id, round(avg(nvl(salary+(salary*commission_pct), salary)*12)) AS AVGSAL
        from employees
        group by department_id
    )
    
    select nvl(to_char(E1.department_id), '인턴') AS 부서번호
         , nvl(department_name, ' ') AS 부서명
         , street_address || ' ' || city || ' ' || state_province AS 부서주소
         , E2.first_name || ' ' || E2.last_name AS 부서장성명
         , E1.employee_id AS 사원번호
         , E1.first_name || ' ' || E1.last_name AS 사원명
         , to_char(nvl(E1.salary+(E1.salary*E1.commission_pct), E1.salary)*12, '999,999') AS 연봉
         , to_char(nvl(E1.salary+(E1.salary*E1.commission_pct), E1.salary)*12 * taxpercent, '99,999.9') AS 연봉소득세액
         , to_char(nvl(E1.salary+(E1.salary*E1.commission_pct), E1.salary)*12 - avgsal, '999,999') AS 부서내연봉평균차액
         , rank() over(partition by E1.department_id order by to_char(nvl(E1.salary+(E1.salary*E1.commission_pct), E1.salary)*12, '999,999') desc) AS 부서내연봉등수
    from employees E1 left join departments D
    on E1.department_id = D.department_id
    left join locations L
    on D.location_id = L.location_id
    left join countries C
    on L.country_id = C.country_id
    left join tbl_taxindex T
    on nvl(salary+(salary*commission_pct), salary)*12 between lowerincome and highincome
    left join V
    on nvl(E1.department_id, -9999) = V.department_id
    left join employees E2
    on E1.manager_id = E2.employee_id
    order by 1,10;
    
    -- 답
    ----------------------------------------------------------------------------------------------------------
     부서번호   부서명   부서주소  부서장성명  사원번호  사원명  연봉  연봉소득세액  부서내연봉평균차액   부서내연봉등수
    ---------------------------------------------------------------------------------------------------------- 
  /*
  부서번호         --> departments , employees  조인조건절  departments.department_id , employees.department_id  
  부서명           --> departments
  부서주소         --> locations     조인조건절  locations.location_id   departments.location_id
  부서장성명       --> employees     조인조건절  departments.manager_id   employees.employee_id  
  사원번호         --> employees 
  사원명           --> employees 
  연봉             --> employees 
  연봉소득세액      --> tbl_taxindex   조인조건절  employees.연봉이   tbl_taxindex.lowerincome  ~  tbl_taxindex.highincome 범위안에 들어오는 것 
  부서내연봉평균차액 --> employees 
  부서내연봉등수    --> employees
  
  [부서번호  부서명  부서주소  부서장성명] A
  [사원번호  사원명  연봉  연봉소득세액  부서내연봉평균차액   부서내연봉등수] B
  ==> A join B
  */
    select D.department_id AS 부서번호
        , department_name AS 부서명
        , street_address || ' ' || city || ' ' || state_province AS 부서주소 
   --   , D.manager_id, E.employee_id 
        , E.first_name || ' ' || E.last_name AS 부서장성명
   from departments D JOIN locations L 
   ON D.location_id = L.location_id
   JOIN employees E
   ON D.manager_id = E.employee_id;
   
   
   with V as (
       select department_id
            , trunc(avg(nvl(salary+(salary*commission_pct), salary)*12)) AS DeptAvgYearSal
       from employees
       group by department_id
   )
   select E.department_id AS 부서번호
        , employee_id AS 사원번호
        , first_name || ' ' || last_name AS 사원명
        , to_char( nvl(salary+(salary*commission_pct), salary)*12, '999,999') AS 연봉
        , to_char( nvl(salary+(salary*commission_pct), salary)*12 * taxpercent, '99,999.9') AS 연봉소득세액 
    --  , DeptAvgSal AS 부서내평균연봉
        , nvl(salary+(salary*commission_pct), salary)*12 - DeptAvgYearSal AS 부서내연봉평균차액
        , rank() over(partition by E.department_id
                      order by nvl(salary+(salary*commission_pct), salary)*12 desc) AS 부서내연봉등수
   from employees E JOIN tbl_taxindex T  
   ON nvl(salary+(salary*commission_pct), salary)*12 between lowerincome and highincome 
   JOIN V
   ON nvl(E.department_id, -9999) = nvl(V.department_id, -9999);
  
   
   select A.department_id AS 부서번호
        , department_name AS 부서명
        , Address AS 부서주소
        , DeptHeadName AS 부서장성명
        , employee_id AS 사원번호
        , Ename AS 사원명
        , YearSal AS 연봉
        , YearSalTax AS 연봉소득세액
        , DeptAvgYearSalDiff AS 부서내연봉평균차액
        , DeptYearSalRank AS 부서내연봉등수
   from 
   (
     select D.department_id
          , department_name
          , street_address || ' ' || city || ' ' || state_province AS Address 
          , E.first_name || ' ' || E.last_name AS DeptHeadName
     from departments D JOIN locations L 
     ON D.location_id = L.location_id
     JOIN employees E
     ON D.manager_id = E.employee_id
   ) A
   RIGHT JOIN
   (
     with V as (
         select department_id
              , trunc(avg(nvl(salary+(salary*commission_pct), salary)*12)) AS DeptAvgYearSal
         from employees
         group by department_id
     )
     select E.department_id
          , employee_id 
          , first_name || ' ' || last_name AS Ename
          , to_char( nvl(salary+(salary*commission_pct), salary)*12, '999,999') AS YearSal
          , to_char( nvl(salary+(salary*commission_pct), salary)*12 * taxpercent, '99,999.9') AS YearSalTax 
          , nvl(salary+(salary*commission_pct), salary)*12 - DeptAvgYearSal AS DeptAvgYearSalDiff
          , rank() over(partition by E.department_id
                        order by nvl(salary+(salary*commission_pct), salary)*12 desc) AS DeptYearSalRank
     from employees E JOIN tbl_taxindex T  
     ON nvl(salary+(salary*commission_pct), salary)*12 between lowerincome and highincome 
     JOIN V
     ON nvl(E.department_id, -9999) = nvl(V.department_id, -9999)
   ) B
   ON A.department_id = B.department_id
   order by 1, 7 desc;
    
    
    ----- **** SET Operator(SET 연산자) **** -----
---- *** UNION / UNION ALL / INTERSECT / MINUS *** ---- 
-- 면접시 JOIN 과 UNION 의 차이점에 대해서 말해보세요~~!! 
==>  UNION 은 테이블(뷰)과 테이블(뷰)을 합쳐서 보여주는 것으로써,
      이것은 행(ROW)과 행(ROW)을 합친 결과를 보여주는 것이다.

    A = { a, x, b, e, g }

    B = { c, d, a, b, y, k, m}    

    A ∪ B = {a, b, c, d, e, g, k, m, x, y}  ==> UNION  -- 중복 제거, 결과가 정렬됨
                                             {a, b, c, d, e, g, k, m, x, y}

                                             / UNION ALL  -- 중복 제거 없고, 정렬도 없이 그대로 출력
                                             {a, x, b, e, g, c, d, a, b, y, k, m} 

    A ∩ B = {a,b}  ==> INTERSECT
                       {a,b}

    A - B = {x,e,g} ==> MINUS 
                        {x,e,g}

    B - A = {c,d,y,k,m} ==> MINUS 
                            {c,d,y,k,m}
                            
    select *
    from tbl_panmae;
    
    -- 현재가 2020년 8월이므로 저저번달은 2020년 6월이다.
    -- 2020년 6월에 판매되어진 정보는 tbl_panmae_202006 이라는 테이블속으로 이관시키고자 한다.
    -- 먼저 2020년 6월에 판매되어진 정보를 추출해야 한다.
    create table tbl_panmae_202006  -- select 결과물을 테이블로 만든다.
    as
    select *
    from tbl_panmae
    where to_char(panmaedate, 'yyyymm') = to_char(add_months(sysdate, -2), 'yyyymm');
    -- Table TBL_PANMAE_202006이(가) 생성되었습니다.
    
    select *
    from tbl_panmae_202006;
    
    -- 현재가 2020년 8월이므로 저번달은 2020년 7월이다.
    -- 2020년 7월에 판매되어진 정보는 tbl_panmae_202007 이라는 테이블속으로 이관시키고자 한다.
    create table tbl_panmae_202007  -- select 결과물을 테이블로 만든다.
    as
    select *
    from tbl_panmae
    where to_char(panmaedate, 'yyyymm') = to_char(add_months(sysdate, -1), 'yyyymm');
    -- Table TBL_PANMAE_202007이(가) 생성되었습니다.
    
    select *
    from tbl_panmae_202007;
    
    -- 현재가 2020년 8월이므로 tbl_panmae 테이블에는
    -- 2020년 8월에 판매되어진 정보만 남기고자 한다.
    
    -- tbl_panmae 테이블에서 이번달 판매가 아닌 행들만 모두 추출하세요.
    select *
    from tbl_panmae
    where to_char(panmaedate, 'yyyymm') != to_char(sysdate, 'yyyymm');
    
    -- tbl_panmae 테이블에서 이번달 판매가 아닌 행들만 삭제하세요.
    delete from tbl_panmae  -- 행 삭제
    where to_char(panmaedate, 'yyyymm') != to_char(sysdate, 'yyyymm');  -- 삭제할 행 조건 지정
    -- 9개 행 이(가) 삭제되었습니다.
    
    commit;
    
    select *
    from tbl_panmae;  -- 이번달(2020년8월)에 판매된 정보만 보인다.
    
    select *
    from tbl_panmae_202006;
    
    select *
    from tbl_panmae_202007;
    
    select *
    from tbl_panmae;
    
    -- 지금까지 판매되어진 제품별로 판매량의 합계를 추출하세요.
    ----------------------
     제품명    판매량의합계
    ---------------------- 
     감자깡        ...
     고구마깡      ...
     새우깡        ...
     허니버터칩    ...
     
    select *
    from tbl_panmae_202007
    UNION
    select *
    from tbl_panmae_202006
    UNION
    select *
    from tbl_panmae;
    -- UNION 결과는 항상 첫 번째 컬럼에 대해 오름차순 정렬된다.
    -- UNION 은 중복된 행이 있으면 중복을 제거하고 1개만 보여준다.
    
    select *
    from tbl_panmae_202007
    UNION ALL
    select *
    from tbl_panmae_202006
    UNION ALL
    select *
    from tbl_panmae;
    -- UNION ALL 은 UNION ALL 한 테이블의 순서대로 나올 뿐, 정렬은 없다.
    -- UNION ALL 은 중복된 행이 있더라도 중복을 제거하지 않고 있는 그대로 합쳐서 보여줌, 속도가 더 빠르다(중복 검색 및 정렬을 하지 않기 때문에)ㄹ
    
    select jepumname AS 제품명
         , sum(panmaesu) AS 판매량의합계
    from
    (
    select *
    from tbl_panmae_202007
    UNION
    select *
    from tbl_panmae_202006
    UNION
    select *
    from tbl_panmae
    ) V
    group by jepumname
    order by 1;
    
    -- with 절
    with V as (select *
               from tbl_panmae_202007
               UNION
               select *
               from tbl_panmae_202006
               UNION
               select *
               from tbl_panmae)
               
    select jepumname AS 제품명
         , sum(panmaesu) AS 판매량의합계
    from V
    group by jepumname
    order by 1;
    
    -- [퀴즈] 아래와 같이 나오도록 하세요..
    -- 2020년 6월 부터 현재까지 발생한 판매에 있어서 제품별, 판매년월별, 판매량의합계를 나타내세요.
    --------------------------------
     제품명    판매년월     판매량의합계
    --------------------------------
     감자깡	2020-06 	20
     감자깡	2020-07	    15
     감자깡	2020-08	    15
     고구마깡	2020-07	    7
     고구마깡	2020-08	    45
     새우깡	2020-06	    38
     새우깡	2020-07 	8
     새우깡	2020-08 	30
     허니버터칩	2020-08	65
     전체      
    --                   그룹함수
    -- grouping sets
    select decode(grouping(jepumname), 0, jepumname, '전체') AS 제품명
         , decode(grouping(to_char(panmaedate, 'yyyy-mm')), 0, to_char(panmaedate, 'yyyy-mm'), ' ') AS 판매년월
         , sum(panmaesu) AS 판매량의합계
    from
    (
    select panmaedate, jepumnate, panmaesu
    from tbl_panmae_202007
    UNION
    select panmaedate, jepumnate, panmaesu
    from tbl_panmae_202006
    UNION
    select panmaedate, jepumnate, panmaesu
    from tbl_panmae
    ) V
    group by grouping sets((jepumname, to_char(panmaedate, 'yyyy-mm')), ());
    
    -- rollup
    select decode(grouping(jepumname), 0, jepumname, '전체') AS 제품명
         , decode(grouping(to_char(panmaedate, 'yyyy-mm')), 0, to_char(panmaedate, 'yyyy-mm'), ' ') AS 판매년월
         , sum(panmaesu) AS 판매량의합계
    from
    (
    select panmaedate, jepumnate, panmaesu
    from tbl_panmae_202007
    UNION
    select panmaedate, jepumnate, panmaesu
    from tbl_panmae_202006
    UNION
    select panmaedate, jepumnate, panmaesu
    from tbl_panmae
    ) V
    group by rollup(jepumname, to_char(panmaedate, 'yyyy-mm'));
    
    -- 2020년 6월 부터 현재까지 발생한 판매에 있어서 제품별, 판매년월별, 판매량의합계를 나타내세요.
    ---------------------------------------------
     제품명    판매년월     판매량의합계  퍼센티지(%)
    ---------------------------------------------
     감자깡	2020-06 	20
     감자깡	2020-07	    15
     감자깡	2020-08	    15
     감자깡
     고구마깡	2020-07	    7
     고구마깡	2020-08	    45
     고구마깡
     새우깡	2020-06	    38
     새우깡	2020-07 	8
     새우깡	2020-08 	30
     새우깡
     허니버터칩	2020-08	65
     허니버터칩
     전체
    
    -- 판매수 총합은 같은 판매량이 제거되면 안되기 때문에 UNION ALL로 결합한 새로운 뷰 생성
    
    with V as (
        select panmaedate, jepumnate, panmaesu
        from tbl_panmae_202007
        UNION  -- 실수로 두 데이터에 중복 데이터가 있을 경우 거르기 위해 / union all: 중복이 없음이 확실할 때는 성능에 더 좋다.
        select panmaedate, jepumnate, panmaesu
        from tbl_panmae_202006
        UNION
        select panmaedate, jepumnate, panmaesu
        from tbl_panmae
    )
    
    select decode(grouping(jepumname), 0, jepumname, '전체') AS 제품명
         , decode(grouping(to_char(panmaedate, 'yyyy-mm')), 0, to_char(panmaedate, 'yyyy-mm'), ' ') AS 판매년월
         , sum(panmaesu) AS 판매량의합계
         , round(sum(panmaesu) / (select sum(panmaesu) from V) * 100, 1) AS "퍼센티지(%)"
    from V
    group by rollup(jepumname, to_char(panmaedate, 'yyyy-mm'));
    
    
    ---- **** INTERSECT(교집합), MINUS(차집합) **** ----
insert into tbl_panmae_202006(panmaedate, jepumname, panmaesu)
values(to_date('2020-08-01', 'yyyy-mm-dd'), '허니버터칩', 10);

insert into tbl_panmae_202007(panmaedate, jepumname, panmaesu)
values(to_date('2020-08-01', 'yyyy-mm-dd'), '허니버터칩', 10);

insert into tbl_panmae(panmaedate, jepumname, panmaesu)
values(to_date('2020-08-01', 'yyyy-mm-dd'), '허니버터칩', 10);

commit;

    select *
    from tbl_panmae_202007
    UNION
    select *
    from tbl_panmae_202006
    UNION
    select *
    from tbl_panmae;
    
    select *
    from tbl_panmae_202007
    UNION ALL
    select *
    from tbl_panmae_202006
    UNION ALL
    select *
    from tbl_panmae;
    
    select *
    from tbl_panmae_202007
    INTERSECT
    select *
    from tbl_panmae_202006;
    
    select *
    from tbl_panmae_202007
    MINUS
    select *
    from tbl_panmae_202006;
    
    select *
    from tbl_panmae_202006
    MINUS
    select *
    from tbl_panmae_202007;

-- tbl_panmae_202006 테이블과 tbl_panmae_202007 테이블에 중복된 행을 추출해서 삭제하세요.
select panmaedate, jepumname, panmaesu
from tbl_panmae_202006
intersect
select panmaedate, jepumname, panmaesu
from tbl_panmae_202007;

delete from tbl_panmae_202006
where (panmaedate, jepumname, panmaesu) in(select panmaedate, jepumname, panmaesu  -- * 대신 직접 입력하여 가독성
                                           from tbl_panmae_202006
                                           intersect
                                           select panmaedate, jepumname, panmaesu
                                           from tbl_panmae_202007);
-- 같은 방법으로
delete from tbl_panmae_202007
where (panmaedate, jepumname, panmaesu) in(select panmaedate, jepumname, panmaesu
                                           from tbl_panmae_202006
                                           intersect
                                           select panmaedate, jepumname, panmaesu
                                           from tbl_panmae_202007);
-- 6월 달에서 데이터를 삭제했으므로 in 내부의 데이터도 없어져 7월 달에서는 삭제할 수 없다.
-- 임시로 삭제할 데이터를 테이블로 만들어준다(삭제 이전에).
create table tbl_temporary
as
select panmaedate, jepumname, panmaesu
from tbl_panmae_202006
intersect
select panmaedate, jepumname, panmaesu
from tbl_panmae_202007;

delete from tbl_panmae_202007
where (panmaedate, jepumname, panmaesu) in(select panmaedate, jepumname, panmaesu
                                           from tbl_temporary);
                                           
commit;

select *
from tbl_panmae_202006;  -- 2020-08-01 허니버터칩 10 인 행이 없다.

select *
from tbl_panmae_202007;  -- 2020-08-01 허니버터칩 10 인 행이 없다.

-- tbl_temporary 테이블 삭제하기
select *
from tbl_temporary;

drop table tbl_temporary purge;
-- Table TBL_TEMPORARY이(가) 삭제되었습니다.

--------------------------------------------------------------------------------------------------------------------------------
---- *** 동일한 테이블에 동일한 행이 들어가 있을 경우 중복된 행을 제거하기 *** ----
insert into tbl_panmae_202006  -- select 결과를 insert 해줄 수 있다.
select *
from tbl_panmae_202006
where jepumname = '감자깡';

commit;

select *
from tbl_panmae_202006;

insert into tbl_panmae_202006
select *
from tbl_panmae_202006
where jepumname = '새우깡' and panmaedate = to_date('2020-06-18 14:16:28', 'yyyy-mm-dd hh24:mi:ss');

commit;

select jepumname, to_char(panmaedate, 'yyyy-mm-dd hh24:mi:ss'), panmaesu
from tbl_panmae_202006;

delete from tbl_panmae_202006
where jepumname = '감자깡' and
      to_char(panmaedate, 'yyyy-mm-dd hh24:mi:ss') = '2020-06-20 14:16:28' and
      panmaesu = 20;
-- 2개 행 이(가) 삭제되었습니다.
-- 컬럼의 중복을 조건으로 delete 하면 모두 삭제된다.

----- **** Pseudo Column(의사, 유사, 모조) 컬럼 **** ----- 한 테이블 내 중복 값 제거
-----      rowid, rownum
-----      rowid 는 오라클이 내부적으로 사용하기 위해 만든 id 값으로서 행에 대한 고유 id 값이다.
select jepumname, panmaedate, panmaesu, count(*)
from tbl_panmae_202006
group by jepumname, panmaedate, panmaesu
having count(*) > 1;

select jepumname, panmaedate, panmaesu, rowid
from tbl_panmae_202006
where jepumname in ('새우깡', '감자깡');
-- 중복을 찾는 서브쿼리문 작성
select jepumname, panmaedate, panmaesu, rowid
from tbl_panmae_202006
where jepumname in (select distinct jepumname
                    from tbl_panmae_202006
                    where jepumname in('새우깡', '감자깡'));
-- 제품명 뿐만 아니라 판매일, 판매수 모두가 같은가를 확인하는 조건으로 서브쿼리문 확장                    
select jepumname, panmaedate, panmaesu, rowid
from tbl_panmae_202006
where (jepumname, panmaedate, panmaesu) in (select jepumname, panmaedate, panmaesu
                                            from tbl_panmae_202006
                                            group by jepumname, panmaedate, panmaesu
                                            having count(*) > 1)  -- 제품명, 판매일, 판매수 모두가 같은 중복을 찾는 조건, 찾고자 하는 컬럼 모두를 괄호로 묶어야 한다.
order by 1;  -- 중복된 값의 rowid를 확인

delete from tbl_panmae_202006
where rowid in('AAAE8NAAEAAAAGXAAB', 'AAAE8NAAEAAAAGXAAC');
--              중복 감자깡 rowid      중복 새우깡 rowid
-- 2개 행 이(가) 삭제되었습니다.

-- rollback;  -- 취소

commit;  -- 적용

select jepumname, panmaedate, panmaesu
from tbl_panmae_202006;


select rownum, jepumname, panmaedate, panmaesu
from tbl_panmae
-- rownum 은 select 된 행의 행번호를 나타내고자 할 때 사용하는 Pseudo Column 이다.

select boardno, subject, userid, registerday
from tbl_board;

-----------------------------------------------------------------------------
 번호 글번호 글제목                                             글쓴이 작성일자
----------------------------------------------------------------------------- 
 1    6 	좋은 하루 되시고 건강하시고 부자되시고 늘 행복하세요	 leess	20/08/13
 2    5	    오늘도 좋은하루되세요	                             hongkd	20/08/13
 3    4 	기쁘고 감사함이 넘치는 좋은하루되세요 	             emojh	20/08/13
 4    3 	건강하세요	                                     leess	20/08/13
 5    1	    안녕하세요	                                     leess	20/08/13
 6    2	    반갑습니다	                                     eomjh	20/08/13
 
select rownum, boardno, subject, userid, registerday
from tbl_board
order by boardno desc;
/*
-----------------------------------------------------------------------------
 rownum, boardno, subject, userid, registerday
-----------------------------------------------------------------------------
 6	     6	좋은 하루 되시고 건강하시고 부자되시고 늘 행복하세요	leess	20/08/13
 5	     5	오늘도 좋은하루되세요	hongkd	20/08/13
 4	     4	기쁘고 감사함이 넘치는 좋은하루되세요 	emojh	20/08/13
 3	     3	건강하세요	leess	20/08/13
 2	     2	반갑습니다	eomjh	20/08/13
 1	     1	안녕하세요	leess	20/08/13
 -- rownum 기본값은 insert 된 순서대로 나온다.
*/

with V as(
        select boardno, subject, userid, registerday
        from tbl_board
        order by boardno desc
)

select rownum, boardno, subject, userid, registerday
from V;  -- rownum 을 따로 떼내 정렬된 테이블(뷰)에 순서대로 번호를 매기도록 한다.
/*
-----------------------------------------------------------------------------
 rownum, boardno, subject, userid, registerday
-----------------------------------------------------------------------------
 1	     6	좋은 하루 되시고 건강하시고 부자되시고 늘 행복하세요	leess	20/08/13
 2	     5	오늘도 좋은하루되세요	hongkd	20/08/13
 3	     4	기쁘고 감사함이 넘치는 좋은하루되세요 	emojh	20/08/13
 4	     3	건강하세요	leess	20/08/13
 5	     2	반갑습니다	eomjh	20/08/13
 6	     1	안녕하세요	leess	20/08/13
 -- rownum 기본값은 insert 된 순서대로 나온다.
*/

-- 또는
select row_number() over(order by boardno desc), boardno, subject, userid, registerday
from tbl_board;


-- 페이지 당 글을 2개씩 보여주고자 한다.
-- 1페이지  rownum => 1~2  boardno => 6~5
-- 2페이지  rownum => 3~4  boardno => 4~3
-- 3페이지  rownum => 5~6  boardno => 2~1
with V as(
        select boardno, subject, userid, registerday
        from tbl_board
        order by boardno desc
)

select rownum, boardno, subject, userid, registerday
from V
where rownum between 3 and 4;  -- rownum 은 where 절에 바로 쓸 수 없다!!!!!
                               -- 그러므로 inline view 를 사용해야만 올바르게 나온다.

select boardno, subject, userid, registerday
from 
(
    with V as(
            select boardno, subject, userid, registerday
            from tbl_board
            order by boardno desc
    )
            
    select rownum AS rno, boardno, subject, userid, registerday  -- rownum 말 자체를 where 절에 쓸 수 없기 때문에 AS 지정해야 한다.
    from V
) T
where rno between 1 and 2;  --> 1페이지 내용물

select boardno, subject, userid, registerday
from 
(
    with V as(
            select boardno, subject, userid, registerday
            from tbl_board
            order by boardno desc
    )
            
    select rownum AS rno, boardno, subject, userid, registerday
    from V
) T
where rno between 3 and 4;  --> 2페이지 내용물

select boardno, subject, userid, registerday
from 
(
    with V as(
            select boardno, subject, userid, registerday
            from tbl_board
            order by boardno desc
    )
            
    select rownum AS rno, boardno, subject, userid, registerday
    from V
) T
where rno between 5 and 6;  --> 3페이지 내용물

-- 또는
select row_number() over(order by boardno desc), boardno, subject, userid, registerday
from tbl_board
where row_number() over(order by boardno desc) between 1 and 2;
-- row_number() over(order by boardno desc) 은 where 절에 바로 쓸 수가 없다.

with V as(
        select row_number() over(order by boardno desc) AS rno, boardno, subject, userid, registerday
        from tbl_board
)

select boardno, subject, userid, registerday
from V
where rno between 1 and 2;  --> 1페이지 내용물

with V as(
        select row_number() over(order by boardno desc) AS rno, boardno, subject, userid, registerday
        from tbl_board
)

select boardno, subject, userid, registerday
from V
where rno between 3 and 4;  --> 2페이지 내용물

with V as(
        select row_number() over(order by boardno desc) AS rno, boardno, subject, userid, registerday
        from tbl_board
)

select boardno, subject, userid, registerday
from V
where rno between 5 and 6;  --> 3페이지 내용물


----- ==== **** SUB Query **** ==== -----
/*
  - SUB Query(서브쿼리)란?
  select 문 속에 또 다른 select 문이 포함돼 있을 때 포함된 select 문을 SUB Query(서브쿼리)라고 부른다.
  
select jepumname, panmaedate, panmaesu, rowid
from tbl_panmae_202006  ==> Main Query(메인쿼리 == 외부쿼리)
where (jepumname, panmaedate, panmaesu) in (select jepumname, panmaedate, panmaesu
                                            from tbl_panmae_202006
                                            group by jepumname, panmaedate, panmaesu
                                            having count(*) > 1) ==> SUB Query(서브쿼리 == 외부쿼리)
*/

/*
  employees 테이블에서 기본급여가 제일 많은 사원과 기본급여가 제일 적은 사원의 정보를
  사원번호, 사원명, 기본급여로 나타내세요.
*/

from employees
where salary = (salary 의 최대값) or
      salary = (salary 의 최소값)
      
salary 의 최대값 ==> select max(salary) from employees
salary 의 최소값 ==> select min(salary) from employees

select employee_id AS 사원번호
     , first_name || ' ' || last_name AS 사원명
     , salary AS 기본급여
from employees
where salary = (select max(salary) from employees) or
      salary = (select min(salary) from employees);
      
/*
  employees 테이블에서 부서번호가 60, 80번 부서에 근무하는 사원들 중에
  월급이 50번 부서 직원들의 '평균월급' 보다 많은 사원들만
  부서번호, 사원번호, 사원명, 월급을 나타내세요.
*/
select 부서번호, 사원번호, 사원명, 월급
from employees
where department_id in(60, 80) and
      월급 > (50번 부서 직원들의 평균월급);
      
월급 ==> nvl(salary+(salary*commission_pct), salary)

50번 부서 직원들의 평균월급 ==>
select avg(nvl(salary+(salary*commission_pct), salary))
from employees
where department_id = 50

select department_id AS 부서번호
     , employee_id AS 사원번호
     , first_name || ' ' || last_name AS 사원명
     , nvl(salary+(salary*commission_pct), salary) AS 월급
from employees
where department_id in(60, 80) and
      nvl(salary+(salary*commission_pct), salary) > (select avg(nvl(salary+(salary*commission_pct), salary))
                                                     from employees
                                                     where department_id = 50);
                                                     
----- *** === ANY, ALL === *** -----
/*
  SUB Query 절에서 사용되는 ANY는 OR 와 흡사하고,
  SUB Query 절에서 사용되는 ALL 은 AND 와 흡사하다.
*/

-- employees 테이블에서 salary가 30번 부서에 근무하는 사원들의 salary 와 동일한 사원들만 추출하세요.
-- 단, 30번 부서에 근무하는 사람은 제외하세요.

from employees
where nvl(department_id, -9999) != 30 and
      -- salary = (30번 부서에 근무하는 사원들의 salary); (X), = 은 하나의 결과물만이 비교 대상이므로 올바르지 않다.
      -- salary in (30번 부서에 근무하는 사원들의 salary); (O)
      salary =ANY (30번 부서에 근무하는 사원들의 salary);
      
30번 부서에 근무하는 사원들의 salary ==>
select distinct salary  -- 중복값이 필요하지 않다.
from employees
where department_id = 30
/*
  11000
  2900
  2600
  2500
  2800
  3100
*/

select department_id, employee_id, first_name, salary
from employees
where nvl(department_id, -9999) != 30 and
      salary =ANY (select distinct salary
                   from employees
                   where department_id = 30)
order by 1;

/*
  기본급여(salary) 가 제일 많은 사원을 제외한 나머지 모든 사원들만
  사원번호, 사원명, 기본급여(salary)를 나타내세요.
*/
select 사원번호, 사원명, 기본급여(salary)
from employees
where salary < (기본급여(salary)의 최대값);

기본급여(salary)의 최대값 ==> select max(salary) from employees

select employee_id AS 사원번호
     , first_name || ' ' || last_name AS 사원명
     , salary AS 기본급여
from employees
where salary = (select max(salary) from employees);
-- 또는
select employee_id AS 사원번호
     , first_name || ' ' || last_name AS 사원명
     , salary AS 기본급여
from employees
where salary >= ALL (select salary from employees);  -- 기본급여 최대값

select employee_id AS 사원번호
     , first_name || ' ' || last_name AS 사원명
     , salary AS 기본급여
from employees
where salary < (select max(salary) from employees);
-- 또는
select employee_id AS 사원번호
     , first_name || ' ' || last_name AS 사원명
     , salary AS 기본급여
from employees
where NOT salary >= ALL (select salary from employees);  -- NOT 최대값: 최대값을 부정하는 표현

--- ALL을 사용할 경우 조심해야할 사항이 있다!! ---
/*
  커미션(salary*commission_pct) 이 제일 많은 사원을 제외한 나머지 모든 사원들만
  사원번호, 사원명, 기본급여(salary)를 나타내세요.
*/
select employee_id AS 사원번호
     , first_name || ' ' || last_name AS 사원명
     , salary*commission_pct AS 수당
from employees
where salary*commission_pct = (select max(salary*commission_pct) from employees);
-- 또는
select employee_id AS 사원번호
     , first_name || ' ' || last_name AS 사원명
     , salary*commission_pct AS 수당
from employees
where salary*commission_pct >= ALL (select salary*commission_pct from employees  -- 비교값에 NULL 이 있으면 최대값이라 하여도 비교가 불가하기 때문에 결과가 나오지 않는다.
                                    where salary*commission_pct is not null);    -- NULL을 제외시킨다(where 절 이용하거나 nvl 함수 이용) ==> ALL 사용 시 null 값을 허용하는 컬럼이면 null 값 존재 유무를 떠나 제외시키는 where 절을 추가하는 것이 좋다.
                                    
                                    
----- ==== *** Pairwise Sub Query *** ==== -----
/*
  employees 테이블에서
  부서번호별로 salary 가 최대인 사원과
  부서번호별로 salary 가 최소인 사원의 정보를
  부서번호, 사원번호, 사원명, 기본급여를 나타내세요.
*/

from employees
where (department_id, salary) in(부서번호별로 salary의 최대값 또는  -- 조건을 비교할 속성을 쌍으로 구성한다.
                                 부서번호별로 salary의 최소값)
                                 
부서번호별로 salary의 최대값 또는
부서번호별로 salary의 최소값 ==>
select department_id, max(salary)
from employees
group by department_id
union
select department_id, min(salary)
from employees
group by department_id

select nvl(department_id, -9999), max(salary)
from employees
group by department_id
union
select nvl(department_id, -9999), min(salary)  -- nvl() 둘 다 해줘야 한다.
from employees
group by department_id

select department_id AS 부서번호
     , employee_id AS 사원번호
     , first_name || ' ' || last_name AS 사원명
     , salary AS 기본급여
from employees
where (nvl(department_id, -9999), salary) in(select nvl(department_id, -9999), max(salary)
                                             from employees
                                             group by department_id
                                             union
                                             select nvl(department_id, -9999), min(salary)
                                             from employees
                                             group by department_id)
order by 1,4;


----- ==== *** 상관서브쿼리(=서브상관쿼리) *** ==== -----
/*
  상관서브쿼리 라함은 Main Query(== 외부쿼리)에서 사용된 테이블(뷰)에 존재하는 컬럼이
  Sub Query(== 내부쿼리)의 조건절(where절, having절)에 사용될 때를 말한다.
*/

select department_id AS 부서번호
     , employee_id AS 사원번호
     , salary AS 기본급여
     , rank() over(order by salary desc) AS 전체등수
     , rank() over(partition by department_id order by salary desc) AS 부서내등수
from employees
order by 1, 3 desc;
-- 또는
select department_id AS 부서번호  -- E. 생략 가능
     , employee_id AS 사원번호
     , salary AS 기본급여
     , (select count(*)+1
        from employees
        where salary > E.salary) AS 전체등수  -- 부서번호, 사원번호, 기본급여 데이터 출력 후 출력한 기본급여보다 높은 급여 값이 몇 개 있느냐를 등수로 표현(비교 연산자, 피연산자 순서 중요)
     , (select count(*)+1
        from employees
        where department_id = E.department_id and salary > E.salary) AS 부서내등수
from employees E
order by 1, 3 desc;

----- !!!!! 꼭 알아둘 것 !!!!!
----- ==== *** 상관서브쿼리(=서브상관쿼리)를 사용한 UPDATE 처리하기 *** ==== -----
create table tbl_employees_backup
as
select *
from employees;

update employees set first_name = '김', last_name = '용진';  -- update set 명령어 이후 = 의 의미는 대입하라는 것

commit;

select *
from employees;

select *
from tbl_employees_backup;

update employees E set first_name = (select first_name
                                     from tbl_employees_backup
                                     where employee_id = E.employee_id)
                     , last_name = (select last_name
                                    from tbl_employees_backup
                                    where employee_id = E.employee_id);
                                    
select *
from employees;

-- rollback;
commit;

-- [퀴즈] 공저로 지어진 도서정보만 추출하세요. (단, Sub Query를 사용)
select *
from tbl_authorbook;

로빈슨크루소	    이영경	800
로빈슨크루소	    최은지	500
그리스로마신화	박지현	1200
그리스로마신화	이지은	1300
그리스로마신화	박수빈	1700

select bookname, authorname, loyalty
from tbl_authorbook
where bookname =any (select bookname
                     from tbl_authorbook
                     group by bookname
                     having count(*) > 1);
                     
-- *상관서브쿼리
select bookname, authorname, loyalty
from tbl_authorbook A
where bookname =any (select bookname
                     from tbl_authorbook
                     where bookname = A.bookname and authorname != A.authorname);
                     
                     
---- *** Sub Query 절을 사용하여 테이블을 생성할 수 있다. *** ----
---- employees 테이블에서 부서번호 10번과 30번에 근무하는 직원들만 뽑아서 그 직원들만 보이도록
---- tbl_employees_sub 라는 테이블을 생성하세요.
create table tbl_employees_sub
as
select *
from employees
where department_id in (10, 30)
order by department_id, employee_id;
-- Table TBL_EMPLOYEES_SUB이(가) 생성되었습니다.

select *
from tbl_employees_sub;

---- *** Sub Query 절을 사용하여 데이터를 입력할 수 있다. *** ----
insert into tbl_employees_sub
select *
from employees
where department_id = 50;

commit;

select *
from tbl_employees_sub;

---- *** Sub Query 절을 사용하여 데이터를 변경할 수 있다. *** ----
update tbl_employees_sub set salary = (select max(salary) from employees)
                           , commission_pct = (select max(commission_pct) from employees)
where department_id in (10, 50);

commit;

select *
from tbl_employees_sub;


----- **** 데이터 조작어(DML == Data Manuplation Language) ****
--- DML문은 기본적으로 수동 commit 이다.
--- 즉, DML문을 수행한 다음에는 바로 디스크(파일)에 적용되지 않고 commit 해야만 적용된다.
--- 그래서 DML문을 수행한 다음에 디스크(파일)에 적용치 않고자 한다면 rollback 하면 된다.
1. insert -- 데이터 입력
2. update -- 데이터 수정
3. delete -- 데이터 삭제
4. merge  -- 데이터 병합

insert 는 문법이
insert into 테이블명(컬럼명1,컬럼명2,...) values(값1,값2,...);

※ Unconditional insert all  -- 조건없이 여러 테이블에 넣어줄 때
[문법]
insert all
into 테이블명1(컬럼명1, 컬럼명2, ...)
values(값1, 값2, ...)
into 테이블명2(컬럼명3, 컬럼명4, ...)
values(값3 값4, ...)
Sub Query문;

create table tbl_emp1
(empno              number(6)
,ename              varchar2(50)
,monthsal           number(7)
,gender             varchar2(4)
,manager_id         number(6)
,department_id      number(4)
,department_name    varchar2(30)
);

create table tbl_emp1_backup
(empno              number(6)
,ename              varchar2(50)
,monthsal           number(7)
,gender             varchar2(4)
,manager_id         number(6)
,department_id      number(4)
,department_name    varchar2(30)
);

insert all
into tbl_emp1(empno, ename, monthsal, gender, manager_id, department_id, department_name)
values(employee_id, ename, msal+100, gender, manager_id, department_id, department_name)  -- 읽은 값을 바꿔 넣을 수도 있다.
into tbl_emp1_backup(empno, ename, monthsal, gender, manager_id, department_id, department_name)
values(employee_id, ename, msal-100, gender, manager_id, department_id, department_name)
select employee_id
     , first_name || ' ' || last_name AS ename
     , nvl(salary+(salary*commission_pct), salary) AS msal
     , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS gender
     , E.manager_id
     , E.department_id
     , department_name
from employees E left join departments D
on E.department_id = D.department_id
order by E.department_id asc, employee_id asc;

commit;

select *
from tbl_emp1;

select *
from tbl_emp1_backup


※ Conditional insert all  -- 조건에 따라 테이블마다 다르게 넣어줄 때
조건(where절)에 일치하는 행들만 특정 테이블로 찾아가서 insert 하도록 하는 것이다.

create table tbl_emp_dept30
(empno              number(6)
,ename              varchar2(50)
,monthsal           number(7)
,gender             varchar2(4)
,manager_id         number(6)
,department_id      number(4)
,department_name    varchar2(30)
);

create table tbl_emp_dept50
(empno              number(6)
,ename              varchar2(50)
,monthsal           number(7)
,gender             varchar2(4)
,manager_id         number(6)
,department_id      number(4)
,department_name    varchar2(30)
);

create table tbl_emp_dept80
(empno              number(6)
,ename              varchar2(50)
,monthsal           number(7)
,gender             varchar2(4)
,manager_id         number(6)
,department_id      number(4)
,department_name    varchar2(30)
);

insert all
when department_id = 30 then
into tbl_emp_dept30(empno, ename, monthsal, gender, manager_id, department_id, department_name)
values(employee_id, ename, msal, gender, manager_id, department_id, department_name)
when department_id = 50 then
into tbl_emp_dept50(empno, ename, monthsal, gender, manager_id, department_id, department_name)
values(employee_id, ename, msal, gender, manager_id, department_id, department_name)
when department_id = 80 then
into tbl_emp_dept80(empno, ename, monthsal, gender, manager_id, department_id, department_name)
values(employee_id, ename, msal, gender, manager_id, department_id, department_name)
select employee_id
     , first_name || ' ' || last_name AS ename
     , nvl(salary+(salary*commission_pct), salary) AS msal
     , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS gender
     , E.manager_id
     , E.department_id
     , department_name
from employees E left join departments D
on E.department_id = D.department_id
where E.department_id in (30, 50, 80)
order by E.department_id, employee_id;
-- 85개 행 이(가) 삽입되었습니다.

commit;

select *
from tbl_emp_dept30;

select *
from tbl_emp_dept50;

select *
from tbl_emp_dept80;


----- *** 데이터베이스 링크 만들기 *** -----
update employees set first_name = '김'
                   , last_name = '용진'
where employee_id = 100;  -- Steven King
-- 1 행 이(가) 업데이트되었습니다.

select *
from employees;

-- rollback;
commit;

create database link bonjumlink
connect to hr identified by cclass  -- 접속하고자 하는 상대의 유저명과 비밀번호
using '네트서비스명';  -- 상대방 IP의 포트에 붙을 수 있도록 지정한 것

create database link bonjumlink
connect to hr identified by cclass
using 'BONJUM';
-- Database link BONJUMLINK이(가) 생성되었습니다.
/*
  네트서비스명 BONJUM 은
  C:\oraclexe\app\oracle\product\11.2.0\server\network\ADMIN\tnsnames.ora 에서 작성한다.
*/

-- 네트서비스명을 만들고 연결을 확인하자.
-- 명령 프롬프트에서(cmd에서)
-- C:\Users\sist>tnsping BONJUM 5
/*
OK (10 msec)
OK (0 msec)
OK (20 msec)
OK (0 msec)
OK (10 msec)
*/

-- 생성된 데이터베이스 링크를 조회해본다.
select *
from user_db_links;

-- 생성된 데이터베이스 링크를 삭제해본다.
drop database link BONJUMLINK;
-- Database link BONJUMLINK이(가) 삭제되었습니다.

select *
from employees@bonjumlink;  -- 접속한 상대방

select *
from employees;  -- 로컬

create table tbl_reservation_kyj
(rsvno      varchar2(10)  -- 예약고유번호
,memberid   varchar2(20)  -- 회원ID
,ticketCnt  number        -- 티켓개수
,constraint PK_tbl_reservation_kyj primary key(rsvno)
);
insert into tbl_reservation_kyj(rsvno, memberid, ticketCnt)
values('kyj001', 'leess', 2);

commit;

update tbl_reservation_kyj set ticketCnt = ticketCnt + 3
where rsvno = 'kyj001';

insert into tbl_reservation_kyj(rsvno, memberid, ticketCnt)
values('kyj002', 'eomjh', 1);

-- rollback;  -- commit 한 이후로 변경된 것만 취소시킨다.
commit;  -- 디스크에 적용

select *
from tbl_reservation_kyj;

merge into tbl_reservation@bonjumlink R
using tbl_reservation_kyj L
on (L.rsvno = R.rsvno)
when matched then
    update set R.memberid = L.memberid
             , R.ticketCnt = L.ticketCnt
when not matched then
    insert(rsvno, memberid, ticketCnt) values(L.rsvno, L.memberid, L.ticketCnt);
    
commit;


delete from tbl_emp_dept80;

select *
from tbl_emp_dept80;

rollback;

delete from tbl_emp_dept80
where monthsal >= 10000;

commit;


select *
from tbl_emp_dept80;

delete from tbl_emp_dept80;  -- DML문이므로 수동 commit 이다.

create table tbl_emp_dept90  -- DDL문이므로 auto commit 된다.
(deptno     number);

rollback;

select *
from tbl_emp_dept80;  -- DML문 이후 commit 하지 않아도 DDL문을 실행하면 자동 commit 되어 rollback 되지 않는다.

select *
from employees;

--------------------------------------------------------------------------------------------------------------------------------
update employees set first_name = 'Steven'
                   , last_name = 'King'
where employee_id = 100;

commit;

-- [퀴즈]데이터베이스 링크를 통해 깨진 데이터를 UPDATE 해보자.
update employees set first_name = '몰라'
                   , last_name = '또몰라'
                   , salary = 2000;
                   
commit;

create database link bonjumlink
connect to hr identified by cclass
using 'BONJUM';

select *
from tab@bonjumlink;  -- 생성되어 있는 테이블 확인(@데이터베이스 링크: 연결된 상대의 테이블 확인)

select *
from user_db_links;

select *
from employees@bonjumlink;

select *
from employees;

update employees E set first_name = (select first_name
                                     from employees@bonjumlink
                                     where employee_id = E.employee_id)
                     , last_name = (select last_name
                                    from employees@bonjumlink
                                    where employee_id = E.employee_id)
                     , salary = (select salary
                                    from employees@bonjumlink
                                    where employee_id = E.employee_id);
                                    
commit;

----- *** 데이터 정의어(DDL == Data Definition Language) *** -----
==> DDL : create, alter, drop, truncate
--  DDL문을 실행하면 auto commit 된다.

----- *** 데이터 제어어(DCL == Data Control Language) *** -----
==> DCL : grant(권한 부여), revoke(권한 회수)
--  DCL문을 실행하면 auto commit 된다.

----- *** TCL(Transaction Control Language) *** -----
==> TCL : commit, rollback

----- *** DQL(Data Query Language) *** -----
==> DQL : select


----- *** Transaction 처리 *** -----
-- Transaction 은 여러개의 DML로 이루어진 작업의 한꾸러미(한세트)를 뜻한다.
-- 예) 네이버(다음) 카페에서 활동(글쓰기를 하면 내 포인트 점수가 10점이 올라가고, 댓글쓰기를 하면 내 포인트 점수가 3점이 올라가도록 한다).
-- 게시판 테이블 <-- insert into 게시판 테이블 <== 1. insert 가 성공임을 알아채고
-- 댓글 테이블
-- 회원 테이블(회원아이디, 회원명, 포인트)
--            leess     이순신  100 <-- update 회원테이블 set 포인트 = 포인트 + 10 <== 2.1. update 가 성공임을 알아채면 / 2.2. update 가 실패했다면
                                                                                -- 3.1. 그제서야 commit 해줘야 한다./ 3.2. transaction 의 일부분이 실패했다면 rollback 해줘야 한다.
                                                                                
----- *** 특정 시점까지 rollback 을 할 수 있도록 만들어 보자 *** -----
update employees set first_name = '몰라'
where department_id = 50;
-- 45개 행 이(가) 업데이트되었습니다.

savepoint point_1;

delete employees
where department_id is null;
-- 1 행 이(가) 삭제되었습니다.

select *
from employees
where department_id = 50;

select *
from employees
where department_id is null;
-- 행이 없다.

rollback to savepoint point_1;
-- savepoint point_1 이 선언된 이후로 변경되어진 것만 rollback 시킨다.
-- 그러므로 delete employees where department_id is null; 만 rollback 시킨다.

select *
from employees
where department_id is null;
-- 행이 있다.

select first_name
from employees
where department_id = 50;

rollback;
-- commit 한 이후로 변경된 모든 것을 rollback 시킨다.

select first_name
from employees
where department_id = 50;


---- ==== 제약조건(Constraint)을 사용하여 테이블을 생성해 보겠습니다. ==== ----
/*
  >>> 제약조건(Constraint)의 종류 <<<
  1. Primary Key 제약 (P) -- 테이블당 오로지 1개만 생성할 수 있다.
                         -- 어떤 컬럼에 Primary Key 제약을 주면 그 컬럼은 자동적으로 NOT NULL 되어지고, 그 컬럼에는 중복된 값을 허락치 않고 오로지 고유한 값만 들어오게 된다.
  2. Unique      제약 (U) -- 테이블당 여러개 생성할 수 있다.
                         -- 어떤 컬럼에 Unique Key 제약을 주면 그 컬럼은 자동적으로 NULL이 허용되고, 그 컬럼에는 중복된 값을 허락치 않고 오로지 고유한 값만 들어오게 된다.
  3. Foreign Key 제약 (R) -- 테이블당 여러개 생성할 수 있다.
                         -- Foreign Key 제약으로 참고(Reference)받는 컬럼은 반드시 NOT NULL 이어야 하고, 중복된 값을 허락치 않는 고유한 값만 가져야 한다.
  4. Check       제약 (C) -- 테이블당 여러개 생성할 수 있다.
                         -- 어떤 컬럼에 입력(insert)되거나 수정(update) 시 특정 조건에 맞는 데이터만 적용시키고자 할 때 사용하는 것이다.
  5. NOT NULL    제약 (C) -- 테이블당 여러개 생성할 수 있다.
                         -- 특정 컬럼에 NOT NULL 제약을 주면 반드시 값을 주어야 한다는 뜻이다.
*/

-- ** 시퀀스(Sequence) 생성하기 ** --
-- 시퀀스(Sequence)란? 쉽게 생각하면 은행에서 발급해주는 대기번호표와 비슷한 것이다.
create sequence seq_yeyakno
start with 1    -- 첫번째 출발은 1 부터 한다.
increment by 1  -- 증가치값
nomaxvalue      -- 최대값이 없는 무제한, 계속 증가시키겠다는 말
nominvalue      -- 최소값이 없다.
nocycle         -- 반복이 없음
nocache;        -- 캐시가 없음(메모리에 기억시키지 않음)

create sequence seq_yeyakno2
start with 1    -- 첫번째 출발은 1 부터 한다.
increment by 1  -- 증가치값
maxvalue 5      -- 최대값이 5
minvalue 2      -- 최소값이 2
cycle           -- 반복을 함
nocache;        -- 캐시가 없음(메모리에 기억시키지 않음)
-- 오류발생!! 왜냐하면 minvalue 값은 start with 값과 같든지 아니면 start with 값보다 작아야 한다.

drop sequence seq_yeyakno2;  -- 시퀀스 삭제하기

create sequence seq_yeyakno2
start with 2    -- 첫번째 출발은 2 부터 한다.
increment by 1  -- 증가치값
maxvalue 5      -- 최대값이 5
minvalue 1      -- 최소값이 1. 최대값까지 도달한 이후에 그 다음에 입력되는 값은 minvalue 값인 1이다.
cycle           -- 반복을 함
nocache;        -- 캐시가 없음(메모리에 기억시키지 않음)

-- ** 고객 테이블을 생성해보도록 하겠다. ** --
-- (예: departments 테이블의 department_id 컬럼)

-- 테이블 사이에 "부모", "자식" 관계에 있는 테이블을 삭제(제거)하고자 한다면
-- 먼저 "자식 테이블"부터 삭제하고 그 다음에 "부모 테이블"을 삭제한다.
-- 반대로 생성시에는 "부모 테이블" 부터 먼저 생성하고 그 다음에 "자식 테이블"을 생성한다.
drop table tbl_yeyak purge;
drop table tbl_gogek purge;

create table tbl_gogek    -- foreign key에 의해서 참조를 받는 테이블을 "부모 테이블" 이라고 부른다.
(gogekid    varchar2(30)  -- gogekid 컬럼은 tbl_yeyak 테이블의 gogekid 컬럼에 의해 참조를 받는 컬럼이므로 반드시 고유한 값만 들어와야하고, NOT NULL 이어야 한다.
                          -- 그러므로 gogekid 컬럼에 Primary Key 제약을 준다.
,gogekname  varchar2(30)
,gogekphone varchar2(30)
,gogekemail varchar2(30)
,constraint PK_tbl_gogek_gogekid primary key(gogekid)
,constraint PK_tbl_gogek_gogekemail primary key(gogekemail)
-- Primary Key 테이블당 오로지 1개만 생성할 수 있으므로 오류발생!!
);

create table tbl_gogek    -- foreign key에 의해서 참조를 받는 테이블을 "부모 테이블" 이라고 부른다.
(gogekid    varchar2(30)  -- gogekid 컬럼은 tbl_yeyak 테이블의 gogekid 컬럼에 의해 참조를 받는 컬럼이므로 반드시 고유한 값만 들어와야하고, NOT NULL 이어야 한다.
                          -- 그러므로 gogekid 컬럼에 Primary Key 제약을 준다.
,gogekname  varchar2(30)
,gogekphone varchar2(30) not null
,gogekemail varchar2(30)
,constraint PK_tbl_gogek_gogekid primary key(gogekid)
,constraint UQ_tbl_gogek_gogekphone unique(gogekphone)  -- 후보키(gogekphone 컬럼에 not null 을 주었으므로 primary key 와 동일한 효과를 가지게 된다.)
,constraint UQ_tbl_gogek_gogekemail unique(gogekemail)  -- 후보키
-- 제약조건명은 오라클서버 전체에서 고유해야만 한다.
);

insert into tbl_gogek(gogekid, gogekname, gogekphone, gogekemail)
values('leess', '이순신', '010-3456-7890', 'leess@naver.com');

insert into tbl_gogek(gogekid, gogekname, gogekphone, gogekemail)
values('leess', '이삼순', '010-9898-1234', 'leess@daum.net');
-- 입력 오류!! 중복된 gogekid 를 사용할 수 없다.

insert into tbl_gogek(gogekid, gogekname, gogekphone, gogekemail)
values('sunsin', '이순신', '010-9999-7777', 'sunsin@gmail.com');  -- 동명이인

insert into tbl_gogek(gogekid, gogekname, gogekphone, gogekemail)
values('eomjh', '엄정화', '010-2525-7878', 'eomjh@gmail.com');

insert into tbl_gogek(gogekid, gogekname, gogekphone, gogekemail)
values('chaew', '차은우', '010-9797-3333', null);

insert into tbl_gogek(gogekid, gogekname, gogekphone)
values('chakw', '차금우', '010-5555-3333');

insert into tbl_gogek(gogekid, gogekname, gogekphone, gogekemail)
values('chadw', '차동우', '010-8998-0090', 'eomjh@gmail.com');
-- ORA-00001: unique constraint (HR.UQ_TBL_GOGEK_GOGEKEMAIL) violated
-- 왜냐하면 gogekemail 컬럼에 UNIQUE 제약을 걸어두었으므로 중복된 이메일을 넣을 수 없다.
-- 그런데 오라클은 UNIQUE 제약을 걸어둔 컬럼이 NULL 을 허락한다면 NULL 을 여러 번 넣을 수 있다.
-- 하지만 Microsoft사 제품의 MS-SQL 은 UNIQUE 제약이 걸려 있는 컬럼이 NULL 을 허락한다면 NULL 은 오로지 1번만 들어온다.

insert into tbl_gogek(gogekid, gogekname, gogekphone, gogekemail)
values('chadw', '차동우', null, 'chadw@gmail.com');
-- gogekphone 컬럼에는 null이 들어올수 없으므로 오류 발생

insert into tbl_gogek(gogekid, gogekname, gogekphone, gogekemail)
values('chadw', '차동우', '010-5555-3333', 'chadw@gmail.com');
-- gogekphone 컬럼에는 중복된 전화번호를 넣을 수 없으므로 오류 발생

insert into tbl_gogek(gogekid, gogekname, gogekphone, gogekemail)
values('chadw', '차동우', '010-7777-0070', 'chadw@gmail.com');

commit;

select *
from tbl_gogek;

-- ** 예약을 받아주는 테이블을 생성해보도록 하겠다. ** --
-- (예: employees 테이블의 department_id 컬럼)
create table tbl_yeyak      -- foreign key가 있는 테이블을 "자식 테이블" 이라고 한다.
(yeyakno        number      -- 예약번호  예약번호는 사용자가 수동적으로 입력치 않고 자동적으로 들어와야 한다. 그리고 예약번호는 매번 그 숫자가 증가해야 한다.
                            --           그렇게 되도록 위에서 생성한 시퀀스를 사용토록 한다.
                            -- 예약번호의 값은 NOT NULL 이면서 고유해야 한다.
,gogekid        varchar2(30) not null  -- 고객아이디 NOT NULL
,registerday    date default sysdate   -- registerday 컬럼에 값을 입력하지 않고 생략하면 자동적으로 default 로 선언된 sysdate 값이 들어온다.
,ticketcnt      number(2) not null     -- -99 ~ 99

,constraint PK_tbl_yeyak_yeyakno primary key(yeyakno)  -- 제약조건명은 30글자 이내여야 한다.

,constraint FK_tbl_yeyak_gogekid foreign key(gogekid) references tbl_gogek(gogekid)
-- tbl_yeyak 테이블의 gogekid 컬럼에 들어오는 값은 아무거나 올 수 없고
-- 반드시 tbl_gogek 테이블의 입력된 gogekid 컬럼 값을 참조해서
-- tbl_gogek 테이블의 gogekid 컬럼에 들어있는 것만 입력될 수 있다.
-- 그런데 중요한 것은 tbl_gogek 테이블의 gogekid 컬럼은 참조를 받는 컬럼인데
-- 참조를 받는 컬럼은 반드시 NOT NULL 이면서 고유한 값만 들어와야 한다.

,constraint CK_tbl_yeyak_ticketcnt check(1 <= ticketcnt and ticketcnt <= 10)
);

desc tbl_yeyak;

drop table tbl_yeyak purge;  -- 테이블 삭제

insert into tbl_yeyak(yeyakno, gogekid, registerday, ticketcnt)
values(seq_yeyakno.nextval, 'leess', default, 20);  -- 고객 테이블에 있는 정보만 받을 수 있게 해야한다.
-- 1 행 이(가) 삽입되었습니다.
-- ORA-01400: cannot insert NULL into ("HR"."TBL_YEYAK"."GOGEKID"), yeyakno, gogekid 모두 not null 일 때 하나만 입력하여 하나를 null 값 처리할 수 없기 때문에 오류
-- ORA-02290: check constraint (HR.CK_TBL_YEYAK_TICKETCNT) violated, check 제약으로 인해 입력 오류

insert into tbl_yeyak(yeyakno, gogekid, ticketcnt)
values(seq_yeyakno.nextval, 'leess', -30);
-- ORA-02290: check constraint (HR.CK_TBL_YEYAK_TICKETCNT) violated, check 제약으로 인해 입력 오류

insert into tbl_yeyak(yeyakno, gogekid, registerday, ticketcnt)
values(seq_yeyakno.nextval, 'leess', sysdate, 0);
-- ORA-02290: check constraint (HR.CK_TBL_YEYAK_TICKETCNT) violated, check 제약으로 인해 입력 오류

insert into tbl_yeyak(yeyakno, gogekid, ticketcnt)
values(seq_yeyakno.nextval, 'leess', 2);
-- 1 행 이(가) 삽입되었습니다.

insert into tbl_yeyak(yeyakno, gogekid, ticketcnt) values(seq_yeyakno.nextval, 'hongkd', 1);
-- 입력오류!! 왜나하면 tbl_yeyak 테이블의 gogekid 컬럼에 입력되거나 수정되는 값은
-- 반드시 tbl_gogek 테이블에 입력된 gogekid 컬럼의 값만 들어올 수 있기 때문이다.
-- 현재는 tbl_gogek 테이블에 입력된 gogekid 컬럼의 값은 'leess' 과 'eomjh' 만 있기 때문에
-- 고객으로 등록이 안된 'hongkd' 은 입력을 할 수 없다.

insert into tbl_yeyak(yeyakno, gogekid, ticketcnt) values(seq_yeyakno.nextval, 'eomjh', 1);

insert into tbl_yeyak(yeyakno, gogekid, ticketcnt) values(seq_yeyakno.nextval, 'leess', 3);

select *
from tbl_yeyak;

commit;

select *
from tbl_gogek;

select *
from tbl_yeyak Y join tbl_gogek G
on Y.gogekid = G.gogekid;

--- *** 생성된 제약조건을 조회해보자 ** ---
select *
from user_constraints
where table_name = 'TBL_GOGEK';  -- 데이터 값은 대소문자 구분해야한다.

select *
from user_cons_columns
where table_name = 'TBL_GOGEK';

select *
from user_constraints
where table_name = 'TBL_YEYAK';

select *
from user_cons_columns
where table_name = 'TBL_YEYAK';

-- 일반적으로 제약조건을 조회할 경우에는 user_constraints 와 user_cons_columns 를 JOIN 을 통해서 조회한다.
-- JOIN 조건절 컬럼은 constraint_name 으로 한다.
select *
from user_constraints A join user_cons_columns B
on A.constraint_name = B.constraint_name
where A.table_name = 'TBL_GOGEK';

select *
from user_constraints A join user_cons_columns B
on A.constraint_name = B.constraint_name
where A.table_name = 'TBL_YEYAK';


--- *** === tbl_yeyak 테이블에 어떤 컬럼이 어떤 default 값을 가지는지 알고자 한다. === *** ---
select column_name, data_type, data_default
from user_tab_columns
where table_name = 'TBL_YEYAK';

--- *** === tbl_yeyak 테이블에 registerday 컬럼의 default 값을 변경하고자 한다. === *** ---
alter table tbl_yeyak
modify registerday default sysdate - 1;

select column_name, data_type, data_default
from user_tab_columns
where table_name = 'TBL_YEYAK';

insert into tbl_yeyak(yeyakno, gogekid, ticketcnt)
values(seq_yeyakno.nextval, 'eomjh', 5);

select yeyakno, gogekid, to_char(registerday, 'yyyy-mm-dd hh24:mi:ss'), ticketcnt
from tbl_yeyak;

--- *** === tbl_yeyak 테이블에 registerday 컬럼의 default 값을 삭제한다. === *** ---
alter table tbl_yeyak
modify registerday default null;

select column_name, data_type, data_default
from user_tab_columns
where table_name = 'TBL_YEYAK';

insert into tbl_yeyak(yeyakno, gogekid, ticketcnt)
values(seq_yeyakno.nextval, 'chaew', 9);
-- registerday 컬럼에 null 을 허락할 때, registerday 컬럼에 default 가 없을 경우 값을 입력치 않으면 자동적으로 null 이 들어온다.

desc tbl_yeyak;

select *
from tbl_yeyak;

--- *** === tbl_yeyak 테이블에 registerday 컬럼의 default로 sysdate 를 주도록 하세요. === *** ---
alter table tbl_yeyak
modify registerday default sysdate;

select column_name, data_type, data_default
from user_tab_columns
where table_name = 'TBL_YEYAK';

--- *** === tbl_yeyak 테이블에 새로운 컬럼을 추가해보겠습니다.=== *** ---
--- 예약날짜(reservationday) 컬럼을 추가하겠다.
alter table tbl_yeyak
add reservationday date;

desc tbl_yeyak;

select *
from tbl_yeyak;

--- *** === tbl_yeyak 테이블에 있는 예약날짜(reservationday) 컬럼을 삭제해보겠습니다.=== *** ---
alter table tbl_yeyak
drop column reservationday;

desc tbl_yeyak;

select *
from tbl_yeyak;

--- *** === tbl_yeyak 테이블에 있는 컬럼명 ticketcnt 이름을 yeyakcnt 라는 이름으로 변경하겠다.=== *** ---
alter table tbl_yeyak
rename column ticketcnt to yeyakcnt;

desc tbl_yeyak;

select *
from tbl_yeyak;

--- *** yeyakcnt 를 ticketcnt 로 변경한다. *** ---
alter table tbl_yeyak
rename column yeyakcnt to ticketcnt;

desc tbl_yeyak;
-- TICKETCNT   NOT NULL NUMBER(2) ==> -99 ~ 99

insert into tbl_yeyak(yeyakno, gogekid, ticketcnt)
values(seq_yeyakno.nextval, 'eomjh', 150);
-- ORA-01438: value larger than specified precision allowed for this column

--- *** ticketcnt 컬럼에 입력되는 값을 1개 이상 200개 이하까지만 허락되도록 하고자 한다. *** ---
-- 1. ticketcnt 컬럼의 타입을 NUMBER(2) 에서 NUMBER(3) 으로 변경해야 한다.
alter table tbl_yeyak
modify ticketcnt number(3);

desc tbl_yeyak;
-- TICKETCNT   NOT NULL NUMBER(3) ==> -999 ~ 999

-- 2. ticketcnt 컬럼에 걸린 check 제약을 변경해야 한다.
-- tbl_yeyak 테이블에 존재하는 check 제약을 조회해 오자.
select *
from user_constraints
where table_name = 'TBL_YEYAK' and constraint_type = 'C';
-- -----------------------------------------------------------
-- CONSTRAINT_NAME          SEARCH_CONDITION
-- -----------------------------------------------------------
-- CK_TBL_YEYAK_TICKETCNT   1<="TICKETCNT" AND "TICKETCNT"<=10

-- 제약조건을 변경하고자 한다면 기존의 제약조건을 삭제하고 다시 생성하는 방법밖에 없다.
-- 2.1. 기존의 제약조건을 삭제한다.
alter table tbl_yeyak
drop constraint CK_TBL_YEYAK_TICKETCNT;

select *
from user_constraints
where table_name = 'TBL_YEYAK' and constraint_type = 'C';

-- 2.2. 새로운 제약조건을 생성한다.
alter table tbl_yeyak
add constraint CK_TBL_YEYAK_TICKETCNT check(1 <= ticketcnt and ticketcnt <= 200);
-- ------------------------------------------------------------
-- CONSTRAINT_NAME          SEARCH_CONDITION
-- ------------------------------------------------------------
-- CK_TBL_YEYAK_TICKETCNT   1 <= ticketcnt and ticketcnt <= 200

select *
from user_constraints
where table_name = 'TBL_YEYAK' and constraint_type = 'C';

insert into tbl_yeyak(yeyakno, gogekid, registerday, ticketcnt)
values(seq_yeyakno.nextval, 'leess', default, 20);
-- 1 행 이(가) 삽입되었습니다.

insert into tbl_yeyak(yeyakno, gogekid, registerday, ticketcnt)
values(seq_yeyakno.nextval, 'leess', default, 201);
-- ORA-02290: check constraint (HR.CK_TBL_YEYAK_TICKETCNT) violated

---- **** 5개의 제약조건(Primary Key, Unique, Foreign key, Check, NOT NULL) 중 
/*   [제약조건의 삭제하기]는 
          alter table 테이블명 drop constraint 제약조건명; ==> 삭제하기
  
     [제약조건의 추가하기]는
          alter table 테이블명 add constraint 제약조건명 primary key(컬럼명);
          alter table 테이블명 add constraint 제약조건명 unique(컬럼명);   
          alter table 테이블명 add constraint 제약조건명 check(.....);   
          alter table 테이블명 add constraint 제약조건명 foreign key(컬럼명) references 부모테이블명(컬럼명); 
 
     그런데 특이하게도 NOT NULL 은 추가하기, 삭제하기의 문법이 다르다.
     NOT NULL 제약의 추가는 아래처럼 하는 것이 아니다.
    
     alter table 테이블명
     add constraint 제약조건명 제약조건설정값; 이 아니라
    
     alter table 테이블명
     modify 컬럼명 not null; <-- NOT NULL 제약의 추가이다.
     
     alter table 테이블명
     modify 컬럼명 null;     <-- NOT NULL 제약의 삭제이다.
*/

-- tbl_yeyak 테이블에서 ticketcnt 컬럼에 걸린 not null 제약을 없애겠다.
select *
from user_constraints
where table_name = 'TBL_YEYAK' and constraint_type = 'C';

alter table tbl_yeyak
drop constraint SYS_C007040;  -- 임의로 부여된 제약조건명이기 때문에 바로 파악할 수 없다.
-- 또는
alter table tbl_yeyak
modify ticketcnt null;

desc tbl_yeyak;
-- TICKETCNT            NUMBER(3) 

-- tbl_yeyak 테이블에서 ticketcnt 컬럼에 not null 제약을 추가하겠다.
alter table tbl_yeyak
modify ticketcnt not null;

desc tbl_yeyak;
-- TICKETCNT   NOT NULL NUMBER(3)


--- *** 제약조건의 비활성화 *** ---
select *
from tbl_yeyak;

select *
from tbl_gogek;
-- 고객으로 'hongkd'은 존재하지 않는다.

insert into tbl_yeyak(yeyakno, gogekid, ticketcnt)
values(seq_yeyakno.nextval, 'hongkd', 1);
-- ORA-02291: integrity constraint (HR.FK_TBL_YEYAK_GOGEKID) violated - parent key not found

-- TBL_YEYAK 테이블에 존재하는 foreign key 를 조회한다.
select A.constraint_name, constraint_type, r_constraint_name, status, column_name
from user_constraints A join user_cons_columns B
on A.constraint_name = B.constraint_name
where A.table_name = 'TBL_YEYAK' and
      A.constraint_type = 'R';
-- A.constraint_name    constraint_type r_constraint_name(참조 받는 기본키 제약조건명)  status  column_name
--------------------------------------------------------------------------------------------------------------------------------
-- FK_TBL_YEYAK_GOGEKID	R	            PK_TBL_GOGEK_GOGEKID	                    ENABLED	 GOGEKID

--- *** TBL_YEYAK 테이블에 존재하는 foreign key 인 FK_TBL_YEYAK_GOGEKID 제약조건의 비활성화 *** ---
alter table tbl_yeyak
disable constraint FK_TBL_YEYAK_GOGEKID;

select A.constraint_name, constraint_type, r_constraint_name, status, column_name
from user_constraints A join user_cons_columns B
on A.constraint_name = B.constraint_name
where A.table_name = 'TBL_YEYAK' and
      A.constraint_type = 'R';
-- A.constraint_name    constraint_type r_constraint_name(참조 받는 기본키 제약조건명)  status    column_name
--------------------------------------------------------------------------------------------------------------------------------
-- FK_TBL_YEYAK_GOGEKID	R	            PK_TBL_GOGEK_GOGEKID	                    DISABLED   GOGEKID

insert into tbl_yeyak(yeyakno, gogekid, ticketcnt)
values(seq_yeyakno.nextval, 'hongkd', 1);
-- 1 행 이(가) 삽입되었습니다.

insert into tbl_yeyak(yeyakno, gogekid, ticketcnt)
values(seq_yeyakno.nextval, 'youks', 1);

commit;

--- *** 제약조건의 활성화 *** ---
alter table tbl_yeyak
enable constraint FK_TBL_YEYAK_GOGEKID;
-- *Cause:    an alter table validating constraint failed because the table has child records.
-- foreign key 제약조건 FK_TBL_YEYAK_GOGEKID 에 위배되는 데이터(행)가 tbl_yeyak 테이블에 존재하므로 안된다.
-- 위에서 삽입한
-- insert into tbl_yeyak(yeyakno, gogekid, ticketcnt)
-- values(seq_yeyakno.nextval, 'hongkd', 1); 때문이다.

-- [퀴즈] tbl_yeyak 테이블에서 tbl_gogek 에 등록이 안된 gogekid 를 가지는 행을 추출하세요.
select distinct gogekid
from tbl_yeyak
minus
select gogekid
from tbl_gogek;

-- [퀴즈] tbl_yeyak 테이블에서 tbl_gogek 에 등록이 안된 gogekid 를 가지는 행을 삭제하세요.
delete from tbl_yeyak
where gogekid in (select distinct gogekid
                  from tbl_yeyak
                  minus
                  select gogekid
                  from tbl_gogek);
-- 2개 행 이(가) 삭제되었습니다.

commit;

select *
from tbl_yeyak;

--- *** 제약조건 위배하는 데이터(행) 삭제 후 제약조건의 활성화 *** ---
alter table tbl_yeyak
enable constraint FK_TBL_YEYAK_GOGEKID;
-- Table TBL_YEYAK이(가) 변경되었습니다.


-- *** === !!!!! Foreign Key 생성 시 옵션을 주지 않는 것 !!!!! === *** --

-- *** === !!!!! Foreign Key 생성 시 on delete cascade 옵션을 주는 것 !!!!! === *** --

-- *** === !!!!! Foreign Key 생성 시 on delete set null 옵션을 주는 것 !!!!! === *** --

-- 1. Foreign Key 생성 시 옵션을 주지 않는 것
create table tbl_buseo_1
(buno       number(2)               -- 10 20 30 ... 90
,buname     varchar2(100) not null  -- varchar2 의 최대 크기는 4000 byte 이다.
,constraint PK_tbl_buseo_1_buno primary key(buno)
,constraint CK_tbl_buseo_1_buno check(buno in(10,20,30,40,50,60,70,80,90))
-- buno 컬럼에 입력할 수 있는 값은 10 20 30 40 50 60 70 80 90 만 가능하다.
);

create table tbl_sawon_1
(sano       number(4)
,saname     varchar2(100) not null
,fk_buno    number(2)  -- foreign key 라는 것을 쉽게 구분하기 위해 표현, 참조하는 데이터 타입과 일치시켜야 한다.
,constraint PK_tbl_sawon_1_sano primary key(sano)
,constraint FK_tbl_sawon_1_fk_buno foreign key(fk_buno) references tbl_buseo_1(buno)
);

insert into tbl_buseo_1(buno, buname) values(10, '연구부');
insert into tbl_buseo_1(buno, buname) values(20, '영업부');
insert into tbl_buseo_1(buno, buname) values(30, '생산부');

commit;

insert into tbl_sawon_1(sano, saname, fk_buno) values(1001, '일미자', 10);
insert into tbl_sawon_1(sano, saname, fk_buno) values(1002, '이미자', 10);
insert into tbl_sawon_1(sano, saname, fk_buno) values(1003, '삼미자', 20);
insert into tbl_sawon_1(sano, saname, fk_buno) values(1004, '사미자', 20);
insert into tbl_sawon_1(sano, saname, fk_buno) values(1005, '오미자', 20);

commit;

select *
from tbl_buseo_1;

select *
from tbl_sawon_1;  -- 현재 30번 부서에 근무하는 사원은 없다.

-- 부모 테이블인 tbl_buseo_1 테이블에서 행을 삭제하려고 한다.
delete from tbl_buseo_1
where buno = 30;
-- 1 행 이(가) 삭제되었습니다.

delete from tbl_buseo_1
where buno = 20;
-- ORA-02292: integrity constraint (HR.FK_TBL_SAWON_1_FK_BUNO) violated - child record found
-- 참조무결성으로 인해 삭제가 불가하다.
-- tbl_buseo_1 테이블에 buno 컬럼의 값이 20 인 행을 참조하는 자식테이블 tbl_sawon_1의 행(삼미자, 사미자, 오미자)이 존재하므로 삭제가 불가하다.

rollback;

-- 2. Foreign Key 생성 시 on delete cascade 옵션을 주는 것
create table tbl_buseo_2
(buno       number(2)
,buname     varchar2(100) not null
,constraint PK_tb1_buseo_2_buno primary key(buno)
,constraint CK_tbl_buseo_2_buno check(buno in(10,20,30,40,50,60,70,80,90))
);

create table tbl_sawon_2
(sano       number(4)
,saname     varchar2(100) not null
,fk_buno    number(2)
,constraint PK_tbl_sawon_2_sano primary key(sano)
,constraint FK_tbl_sawon_2_fk_buno foreign key(fk_buno) references tbl_buseo_2(buno) on delete cascade
);

insert into tbl_buseo_2(buno, buname) values(10, '연구부');
insert into tbl_buseo_2(buno, buname) values(20, '영업부');
insert into tbl_buseo_2(buno, buname) values(30, '생산부');

commit;

insert into tbl_sawon_2(sano, saname, fk_buno) values(1001, '일미자', 10);
insert into tbl_sawon_2(sano, saname, fk_buno) values(1002, '이미자', 10);
insert into tbl_sawon_2(sano, saname, fk_buno) values(1003, '삼미자', 20);
insert into tbl_sawon_2(sano, saname, fk_buno) values(1004, '사미자', 20);
insert into tbl_sawon_2(sano, saname, fk_buno) values(1005, '오미자', 20);

commit;

select *
from tbl_buseo_2;

select *
from tbl_sawon_2;  -- 현재 30번 부서에 근무하는 사원은 없다.

-- 부모 테이블인 tbl_buseo_2 테이블에서 행을 삭제하려고 한다.
delete from tbl_buseo_2
where buno = 30;
-- 1 행 이(가) 삭제되었습니다.

delete from tbl_buseo_2
where buno = 20;
-- 1 행 이(가) 삭제되었습니다.
/*
  자식 테이블인 tbl_sawon_2 테이블에 foreign key 생성 시 on delete cascade 라는 옵션을 주었으므로
  부모 테이블인 tbl_buseo_2 테이블에서 buno 컬럼의 값이 20 인 행을 삭제하려고 할 때
  먼저 자식 테이블인 tbl_sawon_2 테이블에 fk_buno 컬럼의 값이 20 인 행(삼미자,사미자,오미자)을 delete(삭제)하고서
  그 다음에 부모 테이블인 tbl_buseo_2 테이블에서 buno 컬럼의 값이 20 인 행을 delete(삭제)한다.
*/

rollback;
/*
  foreign key 생성 시 on delete cascade 라는 옵션을 주는 경우는
  게시판에서 원글에 딸린 댓글이 있는 경우
  원글을 삭제하면 댓글은 남아 있을 필요가 없다.
  그러므로 이러한 경우에는 on delete cascade 라는 옵션을 주어서 만든다.
  
  create table 원글테이블명
  (원글번호     number primary key
  ,글제목       varchar2(200)
  );
  
  create table 댓글테이블명
  (댓글번호     number primary key
  ,댓글제목     varchar2(200)
  ,fk_원글번호  number
  ,constraint 제약조건명 foreign key(fk_원글번호) references 원글테이블명(원글번호) on delete cascade
  );
*/

-- 3. Foreign Key 생성 시 on delete set null 옵션을 주는 것
-- drop table tbl_sawon_3 purge;
-- drop table tbl_buseo_3 purge;

create table tbl_buseo_3
(buno       number(2)
,buname     varchar2(100) not null
,constraint PK_tb1_buseo_3_buno primary key(buno)
,constraint CK_tbl_buseo_3_buno check(buno in(10,20,30,40,50,60,70,80,90))
);

create table tbl_sawon_3
(sano       number(4)
,saname     varchar2(100) not null
,fk_buno    number(2)
,constraint PK_tbl_sawon_3_sano primary key(sano)
,constraint FK_tbl_sawon_3_fk_buno foreign key(fk_buno) references tbl_buseo_3(buno) on delete set null
-- on delete set null 을 사용하고자 한다면 foreign key 로 사용되는 fk_buno 컬럼은 반드시 null 을 허용해야 한다(not null 지정해도 테이블은 만들어지나, 해당 foreign key 를 참조받는 부모 테이블 데이터를 삭제할 때 오류 발생).
);

insert into tbl_buseo_3(buno, buname) values(10, '연구부');
insert into tbl_buseo_3(buno, buname) values(20, '영업부');
insert into tbl_buseo_3(buno, buname) values(30, '생산부');

commit;

insert into tbl_sawon_3(sano, saname, fk_buno) values(1001, '일미자', 10);
insert into tbl_sawon_3(sano, saname, fk_buno) values(1002, '이미자', 10);
insert into tbl_sawon_3(sano, saname, fk_buno) values(1003, '삼미자', 20);
insert into tbl_sawon_3(sano, saname, fk_buno) values(1004, '사미자', 20);
insert into tbl_sawon_3(sano, saname, fk_buno) values(1005, '오미자', 20);

commit;

select *
from tbl_buseo_3;

select *
from tbl_sawon_3;  -- 현재 30번 부서에 근무하는 사원은 없다.

-- 부모 테이블인 tbl_buseo_3 테이블에서 행을 삭제하려고 한다.
delete from tbl_buseo_3
where buno = 30;
-- 1 행 이(가) 삭제되었습니다.

delete from tbl_buseo_3
where buno = 20;
-- 1 행 이(가) 삭제되었습니다.
/*
  자식 테이블인 tbl_sawon_3 테이블에 foreign key 생성 시 on delete set null 이라는 옵션을 주었으므로
  부모 테이블인 tbl_buseo_3 테이블에서 buno 컬럼의 값이 20 인 행을 삭제하려고 할 때
  먼저 자식 테이블인 tbl_sawon_3 테이블에 fk_buno 컬럼의 값이 20 인 행(삼미자,사미자,오미자)의 해당 값을 null 로 변경하고서
  그 다음에 부모 테이블인 tbl_buseo_3 테이블에서 buno 컬럼의 값이 20 인 행을 delete(삭제)한다.
*/

rollback;


-- *** 테이블명 변경하기 *** --
-- tbl_yeyak 테이블명을 yeyak_tbl 로 변경해보겠다.
rename tbl_yeyak to yeyak_tbl;
-- 테이블 이름이 변경되었습니다.

select *
from yeyak_tbl;  -- 테이블명이 변경되어 조회된다.

select *
from tbl_yeyak;  -- 테이블명이 존재하지 않는다.


-- *** !!! 테이블을 drop 할때 purge 를 사용하는것과 사용하지 않는 것의 차이점 !!! *** --
-- drop table 삭제하고자하는테이블명;  ==> 휴지통에 테이블을 버리는 것이므로 다시 복원을 할 수 있다.

-- drop table 삭제하고자하는테이블명 purge;  ==> 영구히 테이블을 삭제하는 것이므로 다시 복원을 할 수 없다.

create table tbl_exam_1
(name       varchar2(20));
insert into tbl_exam_1(name) values('연습1');

create table tbl_exam_2
(name       varchar2(20));
insert into tbl_exam_2(name) values('연습2');

create table tbl_exam_3
(name       varchar2(20));
insert into tbl_exam_3(name) values('연습3');

create table tbl_exam_4
(name       varchar2(20));
insert into tbl_exam_4(name) values('연습4');

create table tbl_exam_5
(name       varchar2(20));
insert into tbl_exam_5(name) values('연습5');

commit;

select * from tab;
-- 결과물에서 BIN$ 로 시작하는 것은 휴지통에 버려진 테이블이다.

drop table tbl_exam_1;
-- Table TBL_EXAM_1이(가) 삭제되었습니다.

drop table tbl_exam_2;
-- Table TBL_EXAM_2이(가) 삭제되었습니다.

select *
from tbl_exam_1;
-- 00942. 00000 -  "table or view does not exist"

select *
from "BIN$GfLuTcZGT5ORo1OF3sbnJA==$0";  -- 휴지통에 있는 테이블은 "" 붙여야 읽을 수 있다.

-- *** 휴지통 조회하기 *** --
select *
from user_recyclebin;

-- *** 휴지통에 있는 테이블 복원하기 *** --
flashback table TBL_EXAM_1 to before drop;
-- Flashback을(를) 성공했습니다.

select *
from tbl_exam_1;
-- 복원 성공

-- *** 휴지통에 있는 특정 테이블을 영구히 삭제하기 *** --
purge table TBL_EXAM_2;
-- Table이(가) 비워졌습니다.

-- *** 휴지통에 있는 모든 테이블을 영구히 삭제하기 *** --
drop table tbl_exam_3;
drop table tbl_exam_4;

purge recyclebin;
-- Recyclebin이(가) 비워졌습니다.

select *
from user_recyclebin;

-- *** 테이블을 drop 할때 휴지통에 버리는것이 아니라 영구히 삭제하기 *** --
drop table tbl_exam_5 purge;
-- Table TBL_EXAM_5이(가) 삭제되었습니다.


----- ***** index(인덱스) ***** -----
-- index(==색인)를 사용하는 이유는 where 절이 있는 select 명령문의 속도를 향상시키기 위함이다.
-- index(==색인)는 어떤 컬럼에 만들어야 할까?
/*
  1. where 절에서 자주 사용되는 컬럼
  2. 선택도(selectivity)가 좋은 컬럼에 만들어야 한다.
  ※ 선택도(selectivity)가 좋다라는 것은 고유한 데이터일수록 이다.
  예: 성별컬럼 --> 선택도(selectivity)가 나쁘다. 왜나하면 남자 아니면 여자이므로 인덱스로 검색하는 것보다 테이블 풀스캔이 낫다.
      학번    --> 선택도(selectivity)가 좋다.
*/
create table tbl_student_1
(hakbun     varchar2(10) not null
,name       varchar2(20)
,email      varchar2(20)
,address    varchar2(20)
);

-- *** unique index 생성하기 *** --
create unique index idx_tbl_student_1_hakbun  -- 또는 create index/ unique index 는 해당 컬럼에 unique 제약을 준 것과 같은 결과를 낸다.
on tbl_student_1(hakbun);  -- asc 생략
-- on tbl_student_1(hakbun asc)
-- on tbl_student_1(hakbun desc)
-- Index IDX_TBL_STUDENT_1_HAKBUN이(가) 생성되었습니다.

-- *** non-unique index 생성하기 *** --
create index idx_tbl_student_1_name  -- 중복된 데이터가 있다면 unique를 빼야한다.
on tbl_student_1(name);

insert into tbl_student_1(hakbun, name, email, address)
values('0001', '황재성', 'hjs@naver.com', '서울시 강동구');

insert into tbl_student_1(hakbun, name, email, address)
values('0001', '황삼성', 'hss@naver.com', '서울시 강서구');
-- ORA-00001: unique constraint (HR.IDX_TBL_STUDENT_1_HAKBUN) violated

insert into tbl_student_1(hakbun, name, email, address)
values('0002', '황삼성', 'hss@naver.com', '서울시 강서구');

insert into tbl_student_1(hakbun, name, email, address)
values('0003', '여진구', 'yjg@naver.com', '서울시 강남구');

insert into tbl_student_1(hakbun, name, email, address)
values('0004', '여진구', 'yeo@gmail.com', '서울시 강북구');

commit;

-- TBL_STUDENT_1 테이블에 생성된 index 를 조회해본다.
select *
from user_indexes
where table_name = 'TBL_STUDENT_1';

select *
from user_ind_columns
where table_name = 'TBL_STUDENT_1';

select A.index_name, uniqueness, column_name, descend
from user_indexes A join user_ind_columns B
on A.index_name = B.index_name
where A.table_name = 'TBL_STUDENT_1';

-- 테이블을 drop 하면 자동적으로 그 테이블에 생성돼 있던 모든 인덱스들은 자동적으로 drop 된다.
drop table tbl_student_1 purge;

select *
from tbl_student_1      -- Table Full Scan
where hakbun = '0001';  -- where 절에 hakbun 이 있으므로 오라클은 hakbun 컬럼에 index 가 존재하는지 여부를 검사해서
                        -- index가 존재하면 Table Full Scan 하지 않고 index를 통해서 데이터를 조회해온다.
                        
select *
from tbl_student_1
where name = '여진구';  -- where 절에 name 이 있으므로 오라클은 name 컬럼에 index 가 존재하는지 여부를 검사해서
                       -- index가 존재하면 Table Full Scan 하지 않고 index를 통해서 데이터를 조회해온다.
                       
-- *** index 삭제하기 *** --
drop index IDX_TBL_STUDENT_1_NAME;
-- Index IDX_TBL_STUDENT_1_NAME이(가) 삭제되었습니다.

drop index IDX_TBL_STUDENT_1_HAKBUN;
-- Index IDX_TBL_STUDENT_1_HAKBUN이(가) 삭제되었습니다.

--- *** 복합인덱스(composite index) 생성하기 *** ---
-- 복합인덱스(composite index)란? 2개 이상의 컬럼으로 묶어진 인덱스를 말한다.
select *
from tbl_student_1
where name = '여진구' and address = '서울시 강남구';

create index idx_tbl_student_1_cp
on tbl_student_1(name, address);
-- Index IDX_TBL_STUDENT_1_CP이(가) 생성되었습니다.

-- Primary Key 제약 또는 Unique 제약을 주면 자동적으로 해당 컬럼에 unique한 index가 생성된다. ==> 굳이 index 를 만들 필요가 없다.
-- 제약조건명이 index 명으로 사용된다.
create table tbl_student_2
(hakbun     varchar2(10)
,name       varchar2(20)
,email      varchar2(20) not null
,address    varchar2(20)
,constraint PK_tbl_student_2_hakbun primary key(hakbun)
,constraint UK_tbl_student_2_email unique(email)
);

select A.index_name, uniqueness, column_name, descend
from user_indexes A join user_ind_columns B
on A.index_name = B.index_name
where A.table_name = 'TBL_STUDENT_2';

-- Primary Key 제약 또는 Unique 제약으로 생성된 index 의 제거는
-- drop index index명; 이 아니라
-- alter table 테이블명 drop constraint 제약조건명; 이다.
-- 제약조건을 삭제하면 자동적으로 index 도 삭제가 된다.
select A.constraint_name, constraint_type, search_condition, status, column_name
from user_constraints A join user_cons_columns B
on A.constraint_name = B.constraint_name
where A.table_name = 'TBL_STUDENT_2';

drop index PK_TBL_STUDENT_2_HAKBUN;
-- 오류 ORA-02429: cannot drop index used for enforcement of unique/primary key

alter table tbl_student_2
drop constraint PK_TBL_STUDENT_2_HAKBUN;


---- **** 계층형 쿼리 **** ----
-- 계층형 쿼리는 답변형 게시판에서 사용된다.
-- 또한 전자결제에서도 사용된다.
select *
from employees;

-- 보고 계층: 사원번호 104 => 103 => 102 => 100
select level  -- 계층의 번호를 나타냄
     , employee_id AS 사원번호
     , first_name || ' ' || last_name AS 사원명
     , manager_id AS 사수번호
from employees
start with employee_id = 104                -- 103                  102                 100
connect by prior manager_id = employee_id;
--                       103 = employee_id;    102 = employee_id;   100 = employee_id;  null = employee_id;
-- prior 다음에 나오는 manager_id 는 start with 되는 행의 manager_id 값이다.

-- 명령 계층: 사원번호 100 => 아래로
select level
     , employee_id AS 사원번호
     , first_name || ' ' || last_name AS 사원명
     , manager_id AS 사수번호
from employees
start with employee_id = 100                -- 101                  108                 109
connect by prior employee_id = manager_id;
--                       100 = manager_id;     101 = manager_id;    108 = manager_id;   109 = manager_id;
-- prior 다음에 나오는 employee_id 는 start with 되는 행의 employee_id 값이다.


--------------------------------------------------------------------------------------------------------------------------------
---- **** PL/SQL(Procedure Language SQL) **** ---- 오라클에서 프로그래밍 하는 것
-- 1. 사용자 정의 함수
-- *** 사용자 정의 함수 *** --
/*
  [문법]
  create or replace function 함수명
  (파라미터변수명 in 파라미터변수타입)
  return 리턴시킬타입
  is
    변수선언
  begin
    명령문
    return 값;
  end 함수명;
*/

create or replace function func_gender
(p_jubun in varchar2)  -- (p_jubun in varchar2(13)) 처럼 자리수를 쓰면 오류!!
return varchar2        -- varchar2(10) 처럼 자리수를 쓰면 오류!!
is
    v_genderNum varchar2(1);  -- is 와 begin 사이는 변수를 선언하는 부분이다. 변수 선언 시에는 자리수를 쓴다.
    v_gender    varchar2(6);
begin
    -- p_jubun 이 '9510201234567' 이라고 한다면
    v_genderNum := substr(p_jubun, 7, 1);  -- 변수에 대입 :=
      
    /*
      if 조건1 then 실행문장1;
      elsif 조건2 then 실행문장2;
      else 실행문장3;
      end if;
    */
    if v_genderNum in('1','3') then v_gender := '남';
    else v_gender := '여';
    end if;
    
    return v_gender;
end func_gender;
-- Function FUNC_GENDER이(가) 컴파일되었습니다.

select func_gender('9710202234567')
from dual;

-- select문을 이용한 사용자 정의 함수
create or replace function func_gender_2
(p_jubun in varchar2)
return varchar2
is
    v_gender varchar2(6);
begin
    select case when substr(p_jubun, 7, 1) in('2','4') then '여' else '남' end
    into v_gender
    from dual;
    
    return v_gender;
end func_gender_2;
-- Function FUNC_GENDER_2이(가) 컴파일되었습니다.

select func_gender_2('9710202234567')
from dual;

create or replace function func_age
(p_jubun in varchar2)
return number
is
    v_ageNum varchar2(1);
    n_age    number(3);
begin
    v_ageNum := substr(p_jubun, 7, 1);
    
    if v_ageNum in('1','2') then n_age := extract(year from sysdate) - (to_number(substr(p_jubun, 1, 2)) + 1900) + 1;
    else n_age := extract(year from sysdate) - (to_number(substr(p_jubun, 1, 2)) + 2000) + 1;
    end if;
    
    return n_age;
end func_age;
-- Function FUNC_AGE이(가) 컴파일되었습니다.
/*
create or replace function func_age
(p_jubun IN varchar2)        
return varchar2              
is
    v_genderNum  varchar2(1);
    v_birthYear  number(4);
begin
    v_genderNum := substr(p_jubun,7,1);  
    v_birthYear := to_number(substr(p_jubun,1,2));
          
    if v_genderNum in('1','2') then v_birthYear := v_birthYear + 1900;
    else v_birthYear := v_birthYear + 2000;
    end if;
            
    return extract(year from sysdate) - v_birthYear + 1;
end func_age;
*/

select func_age('9710202234567')
from dual;

create or replace function func_age_2
(p_jubun in varchar2)
return number
is
    n_age number(3);
begin
    select extract(year from sysdate) - (to_number(substr(p_jubun,1,2)) + (case when substr(p_jubun,7,1) in('1','2') then 1900 else 2000 end)) + 1
    into n_age
    from dual;
    
    return n_age;
end func_age_2;

select func_age_2('9710202234567')
from dual;

select employee_id AS 사원번호
     , first_name || ' ' || last_name AS 사원명
     , jubun AS 주민번호
     , func_gender(jubun) AS 성별
     , func_gender_2(jubun) AS 성별2
     , func_age(jubun) AS 현재나이
     , func_age_2(jubun) AS 현재나이2
from employees;
