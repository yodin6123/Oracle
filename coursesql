show user;
-- USER이(가) "HR"입니다.

select * from dba_users;
-- 오라클 서버에 존재하는 모든 사용자 계정 정보를 조회해주는 것이다.
-- ORA-00942: table or view does not exist
-- 관리자 권한이 없으므로 조회할 수 없다.

select * from tab;
-- 현재 오라클 서버에 접속한 사용자(지금은 HR) 소유의 테이블명과 뷰명을 조회해주는 것이다.

select *
from departments; -- 부서 테이블 / 오라클은 데이터 값에서 영문의 첫글자만 대문자로 작성하며, 나머지는 대소문자 구분하지 않는다.
/*
    department_id   => 부서번호 컬럼(column == field == attribute == 열)
    department_name => 부서명 컬럼
    manager_id      => 부서장의 사원번호 컬럼
    location_id     => 부서위치
    
    10	Administration	200	1700 => row == record == tuple == 행
    
    departments  => (전체를 통틀어) table = entity(개체) = 테이블
*/

describe departments; -- departments 테이블의 컬럼 구성 타입을 조회
/*
-------------------------------------------------
컬럼명           널여부                데이터타입
-------------------------------------------------
DEPARTMENT_ID   NOT NULL(필수입력사항) NUMBER(4)      => 숫자타입
DEPARTMENT_NAME NOT NULL(필수입력사항) VARCHAR2(30)   => 문자열타입
MANAGER_ID              (선택입력사항) NUMBER(6)      **date: 날짜타입
LOCATION_ID             (선택입력사항) NUMBER(4)
*/

select *
from employees; -- 사원테이블

desc employees; -- describe 줄여서 쓸 수 있다.
/*
EMPLOYEE_ID    NOT NULL NUMBER(6)    => 사원번호
FIRST_NAME              VARCHAR2(20) => 성
LAST_NAME      NOT NULL VARCHAR2(25) => 이름
EMAIL          NOT NULL VARCHAR2(25) => 이메일
PHONE_NUMBER            VARCHAR2(20) => 전화번호
HIRE_DATE      NOT NULL DATE         => 입사일자
JOB_ID         NOT NULL VARCHAR2(10) => 직종아이디
SALARY                  NUMBER(8,2)  => 기본급여
COMMISSION_PCT          NUMBER(2,2)  => 커미션(수당)퍼센티지(본인 급여에 대한 비율: 0.2는 기본급여(salary)의 20% 라는 의미)
MANAGER_ID              NUMBER(6)    => 직속상관(사수)의 사원번호
DEPARTMENT_ID           NUMBER(4)    => 본인이 근무하는 부서번호
*/

select *
from locations; -- 부서의 위치를 알려주는 테이블

select *
from countries; -- 국가 정보를 알려주는 테이블

select *
from regions; -- 대륙 정보를 알려주는 테이블

/*
    ==== 아주아주아주아주아주아주아주아주아주아주 중요함(필수암기!!!!!!!!!!) ====
    >>>> select문의 처리 순서 <<<<
    
    select 컬럼명          -- 5 컬럼명 대신에 * 을 쓰면 * 은 모든 컬럼을 뜻하는 것이다.
    from 테이블명(뷰명)     -- 1
    where 조건절           -- 2 where 절이 뜻하는 것은 해당 테이블(뷰)에서 조건에 만족하는 행을 메모리(RAM)에 로딩(올리는 것)해주는 것이다.
    group by절            -- 3
    having 그룹함수 조건절  -- 4
    order by절            -- 6
*/

------ *** NULL 을 처리해주는 함수 *** ------
---- NULL 은 존재하지 않는 것이므로 사칙연산( + - * / )에 NULL 이 포함되어지면 그 결과는 무조건 NULL 이다.
1. nvl
    select 1+2
    from departments; -- departments 수 만큼 값 로딩
    
    select 1+2, 1+null, 3*0, null*0, 2-1, 2-null, 5/2, 5/null
    from dual; -- 한 번만 로딩
    
    select nvl(7,3), nvl(null,3), -- nvl(a,b): a 값이 null이 아니라면 a 값을 주고, null이라면 두 번째인 b 값을 준다.
           nvl('이순신','거북선'), nvl(null,'거북선')
    from dual;
    
2. nvl2
    select nvl2(7,3,2), nvl2(null,3,2), -- nvl2(a,b,c): a 값이 null이 아니라면 b 값을 주고, null이라면 c 값을 준다.
           nvl2('이순신','거북선','구국영웅'), nvl2(null,'거북선','구국영웅')
    from dual;
    
    
    select employee_id as "사원번호" -- (as) 별칭(alias)
         , first_name "성"
         , last_name 이름
         , salary "기본 급여" -- 공백이 있는 글자를 쓸 때는 ""를 붙여야한다(없으면 생략 가능).
         , commission_pct as "수당퍼센티지"
         , nvl(salary + (salary * commission_pct), salary) as "월급"
         , nvl2(commission_pct, salary + (salary * commission_pct), salary) as "월급2"
    from employees;
    
------ *** 비교연산자 *** ------
1. 같다.        =
2. 같지않다.    !=  <>  ^=
3. 크다, 작다.  >   <
4. 같거나크다, 같거나작다. >= <=
5. NULL 은 존재하지 않는 것이므로 비교대상이 될 수가 없다.
   그러므로 비교연산( = != <> ^= > < >= <= )을 할 수가 없다.
   그래서 비교연산을 하려면 nvl()함수, nvl2()함수를 사용하여 처리한다.
   
-- employees 테이블에서 부서번호 30번에 근무하는 사원들만
-- 사원번호, 사원명, 월급, 부서번호를 나타내세요.

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명 -- a || b : a 컬럼과 b 컬럼을 합친다.
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호 -- 일단 메모리에는 where 조건을 만족하는 모든 테이블의 값이 올라간다. 그 후 select를 거쳐 원하는 값만 뽑아낸다.
    from employees
    where department_id = 30;
    
    
-- employees 테이블에서 부서번호가 null 인 사원들만
-- 사원번호, 사원명, 월급, 부서번호를 나타내세요.

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명 -- a || b : a 컬럼과 b 컬럼을 합친다.
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where department_id = null; --> 데이터가 출력되지 않는다.
                                --> 왜냐하면 NULL 은 존재하지 않는 것이므로 비교대상이 될 수가 없다.
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호 -- 꺼낼 때는 원래 값인 null을 뽑아낸다.
    from employees
    where nvl(department_id, -9999) = -9999 -- 회사에 존재하지 않는 임의의 값 부여해 비교할 수 있도록 한다.
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명 -- a || b : a 컬럼과 b 컬럼 값을 합친다.
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where department_id is null; -- null 은 is 연산자를 사용하여 구한다.
                                 -- department_id 가 null 인 행들만 보고자 할 경우.
    
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명 -- a || b : a 컬럼과 b 컬럼 값을 합친다.
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where department_id is not null; -- null 은 is 연산자를 사용하여 구한다.
                                     -- department_id 가 null 이 아닌 행들만 보고자 할 경우.
    
    
-- 정렬(오름차순정렬, 내림차순정렬)을 할때 null 은 존재하지 않는 것이므로
-- 오라클에서는 가장 큰것으로 간주를 하고, MS-SQL 에서는 가장 작은것으로 간주한다.
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
--  order by nvl(salary + (salary*commission_pct), salary); -- asc; -- 오름차순은 asc 을 생략할 수 있다.
    order by nvl(salary + (salary*commission_pct), salary) desc; -- 내림차순은 desc 을 생략할 수 없다.
    
    -- 또는
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
--  order by 월급 -- asc; -- 오름차순 -- select 다음 순서이기 때문에 월급(alias)을 받아온다.
    order by 월급 desc; -- 내림차순 -- select 다음 순서이기 때문에 월급(alias)을 받아온다.
    
    -- 또는
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
--  order by 3 -- asc; -- 오름차순 -- 3번째 컬럼을 의미한다.
    order by 3 desc; -- 내림차순 -- 3번째 컬럼을 의미한다.
    
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    order by department_id; -- 부서번호의 오름차순 정렬 / null 가장 큰 값으로 정렬
    
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    order by department_id asc, 3 desc; -- 1차정렬은 department_id(부서번호)의 오름차순으로 정렬시킨 후
                                        -- 2차정렬은 동일한 부서번호내에서는 월급의 내림차순으로 정렬하겠다.
                                        -- order by department_id, 3 desc; => 부서번호 오름차순(생략), 월급 내림차순 (O)
                                                                    --     => 모두 내림차순 (X)
                                                                    
-- employees 테이블에서 수당퍼센티지가 null 인 사원들만
-- 사원번호, 사원명, 월급(기본급여+수당금액), 부서번호를 나타내되
-- 부서번호의 오름차순으로 정렬한 후 동일한 부서번호내에서는 월급의 내림차순으로 나타내세요.

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where commission_pct is null
    order by department_id, 3 desc;
    
-- employees 테이블에서 수당퍼센티지가 null 이 아닌 사원들만
-- 사원번호, 사원명, 월급(기본급여+수당금액), 부서번호를 나타내되
-- 부서번호의 오름차순으로 정렬한 후 동일한 부서번호내에서는 월급의 내림차순으로 나타내세요.

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where commission_pct is not null
    order by department_id, 3 desc;
    
    -- 또는
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where not commission_pct is null -- 컬럼명 앞에 not => 부정
    order by department_id, 3 desc;
    
-- employees 테이블에서 월급(기본급여+수당금액)이 10000 보다 큰 사원들만
-- 사원번호, 사원명, 월급(기본급여+수당금액), 부서번호를 나타내되
-- 부서번호의 오름차순으로 정렬한 후 동일한 부서번호내에서는 월급의 내림차순으로 나타내세요.
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where nvl(salary + (salary*commission_pct), salary) > 10000
    order by 부서번호, nvl(salary + (salary*commission_pct), salary) desc;

-- employees 테이블에서 부서번호가 50번 부서가 아닌 사원들만
-- 사원번호, 사원명, 월급(기본급여+수당금액), 부서번호를 나타내되
-- 부서번호의 오름차순으로 정렬한 후 동일한 부서번호내에서는 월급의 내림차순으로 나타내세요.
    desc employees; -- 데이터 구조 확인(조건을 따지기 위해)

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where nvl(department_id, -9999) <> 50
    order by 4, 월급 desc;
    
    -- 또는
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where not nvl(department_id, -9999) = 50
    order by 4, 월급 desc;
    
/*
    === AND, OR, NOT 연산자가 혼용되어지면 우선순위를 따르는데
        NOT > AND > OR 의 순위를 따라간다.
        우선순위에 있어서 최우선은 ( ) 괄호이다. ===
        
        OR 연산자와 같은 것이 IN() 이다. IN()는 괄호가 있는 OR 이다.
        범위연산자가 있는데 between A and B 가 A 이상 B 이하를 나타내는 것이다.
*/

    select 2+3*4
    from dual; -- 한 개만 보기 위한 가상테이블
    
/*
    employees 테이블에서 부서번호가 30, 50, 60번 부서에서 근무하는 사원들 중에
    연봉(월급*12)이 20000 이상 60000 이하인 사원들만
    사원번호, 사원명, 연봉(월급*12), 부서번호를 나타내되
    부서번호의 오름차순으로 정렬한 후, 연봉의 내림차순으로 정렬하여 출력하세요.
*/

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary)*12 as 연봉
         , department_id as 부서번호
    from employees
    where department_id = 30 or department_id = 50 or department_id = 60 and -- and 우선순위에 따라 부서번호가 60번인 사람만 아래 조건을 검색한다.
          20000 <= nvl(salary + (salary*commission_pct), salary)*12 and
          nvl(salary + (salary*commission_pct), salary)*12 <= 60000
    order by 4, 3 desc;
    
    /*
        !!! and 와 or 가 혼용되어지면 우선순위는 and 가 먼저 한다. !!!
    */
        
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary)*12 as 연봉
         , department_id as 부서번호
    from employees
    where (department_id = 30 or department_id = 50 or department_id = 60) and -- or 조건을 우선 수행하기 위해 괄호를 써야한다.
          20000 <= nvl(salary + (salary*commission_pct), salary)*12 and
          nvl(salary + (salary*commission_pct), salary)*12 <= 60000
    order by 4, 3 desc;
    
    /*
        !!! 연산자의 우선순위에서 괄호() 가 제일 우선한다. !!!
    */
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary)*12 as 연봉
         , department_id as 부서번호
    from employees
    where department_id in(30,50,60) and -- 부서번호 30 또는 50 또는 60
          nvl(salary + (salary*commission_pct), salary)*12 between 20000 and 60000 -- 연봉 20000 이상 60000 이하
    order by 4, 3 desc;
    
    -- 대용량 데이터베이스인 경우 in() 보다는 or를, between A and B 보다는 <= >= 를 사용할 것을 권장한다.
    -- 왜냐하면 in 은 내부적으로 or 로 변경되어서 사용되고, 
    -- 또한 between A and B 도 <= >= 로 변경되어서 사용되기 때문이다.
    -- 대용량 데이터베이스의 기준은 어떤 테이블의 행의 갯수가 100만건을 넘을 경우를 말한다.
    -- 소규모 데이터베이스의 기준은 어떤 테이블의 행의 갯수가 1만건 미만인 경우를 말한다.
    

/*
    employees 테이블에서 부서번호가 50, 80번 부서에서 근무하지 않는 사원들 중에
    월급이 4000 이상인 사원들만
    사원번호, 사원명, 월급, 부서번호를 나타내되
    부서번호의 오름차순으로 정렬한 후, 월급의 내림차순으로 정렬하여 출력하세요.
*/

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where nvl(department_id, -9999) != 50 and nvl(department_id, -9999) != 80 and
          nvl(salary + (salary*commission_pct), salary) >= 4000
    order by 4, 3 desc;
    
    -- 또는
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where not nvl(department_id, -9999) in(50,80) and -- 부서번호가 50 또는 80이 아닌 / >= 4000 까지 전체에 not 이 적용되지 않는다.
          nvl(salary + (salary*commission_pct), salary) >= 4000
    order by 4, 3 desc;
    
    -- 또는
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where nvl(department_id, -9999) not in(50,80) and -- 부서번호가 50 또는 80이 아닌 / 부정하고자 하는 표현 앞에 붙여 조금 더 명확하게 표현
          nvl(salary + (salary*commission_pct), salary) >= 4000
    order by 4, 3 desc;
    /*
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , nvl(salary + (salary*commission_pct), salary) as 월급
         , department_id as 부서번호
    from employees
    where nvl(department_id, -9999) != 50 and
          nvl(department_id, -9999) != 80 and
          nvl(salary + (salary*commission_pct), salary) >= 4000
    order by 4, 3 desc;
    */
    
--- *** ===== 범위 연산자 ===== *** ---
--      >  <  >=  <==
--      between A and B
--      범위 연산자에는 데이터가 숫자 뿐만 아니라 문자, 날짜까지 모두 사용가능하다.
    desc employees;
    -- HIRE_DATE    DATE => DATE 타입의 기본적인 표현방식은 'YY/MM/DD' 으로 나타내어진다.
    --                      YY 은 년도의 2자리만 나타낸다. 50 ~ 99 은 1950 ~ 1999 이다.
    --                      YY 은 년도의 2자리만 나타낸다. 00 ~ 49 은 2000 ~ 2049 이다.
    --                      MM 은 월이고, DD 는 일이다.
    
    -- **** ==== 현재 시각을 알려주는 것 ==== **** --
    select sysdate, current_date, localtimestamp, current_timestamp, systimestamp
    from dual;

    select sysdate, to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss')
    from dual;
    
    select sysdate - 1, sysdate, sysdate + 1 -- 숫자의 단위는 일수이다.
    from dual;

    select to_char(sysdate - 1, 'yyyy-mm-dd'), to_char(sysdate, 'yyyy-mm-dd'), to_char(sysdate + 1, 'yyyy-mm-dd')
    from dual;

    select to_char(sysdate - 1/24, 'yyyy-mm-dd hh24:mi:ss'), to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss'), to_char(sysdate + 1/24, 'yyyy-mm-dd hh24:mi:ss') -- 1시간 전, 현재, 1시간 후
    from dual;

--  select '2020-08-01' + 2 -- 날짜 타입이 아닌 문자 타입이기 때문에 연산 불가
--  from dual;
    select to_date('2020/08/01', 'yyyy/mm/dd') + 2, -- 문자 타입을 날짜 타입으로 (형식에 맞춰서) 변환 => 변환된 날짜는 기본형식으로 출력된다. / 기본적으로 없는 날짜는 변환할 수 없다.
           to_char(to_date('2020-08-01', 'yyyy-mm-dd') + 2, 'yyyy-mm-dd')
    from dual;

    select employee_id, first_name, last_name, hire_date, to_char(hire_date, 'yyyy-mm-dd') -- 날짜의 형식을 지정한 문자열로 바꾸는 것
    from employees
    where '2005-01-01' <= hire_date and hire_date <= '2006-12-31'; -- 날짜로 자동으로 형변환해 비교한다.
    --원래는
    select employee_id, first_name, last_name, hire_date, to_char(hire_date, 'yyyy-mm-dd') -- 날짜의 형식을 지정한 문자열로 바꾸는 것
    from employees
    where to_date('2005-01-01', 'yyyy-mm-dd') <= hire_date and hire_date <= to_date('2006-12-31', 'yyyy-mm-dd');
    
    
    'A' --> 65(문자의 10진수 값)
    'a' --> 97
    '0' --> 48
    ' ' --> 32
    select ascii('A'), ascii('a'), ascii('0'), ascii(' ')
    from dual;
    
    select chr(65), chr(97), chr(48), chr(32)
    from dual;
    
    select first_name
    from employees
    where 'Elj' <= first_name and first_name <= 'H'; -- Elizabeth Elj Ellen
    
    
---- **** employees 테이블에 jubun(주민번호) 이라는 컬럼을 추가하겠다 **** ----
---- jubun(주민번호, - 제외) 이라는 컬럼은 숫자 타입이 아니라 문자 타입이어야 한다.!!!!!!!
    select 9710201234567, '9710201234567' -- 출력 시 숫자는 오른쪽 정렬, 문자는 왼쪽 정렬
    from dual;
    
    select 0110204234567, '0110204234567' -- 숫자는 맨 앞에 0 일 경우 생략된다. => 문자 타입으로 해야 한다.
    from dual;
    
    desc employees;
    
    alter table employees
    add jubun varchar2(13);
    -- 주민번호 열 추가 자료형(길이)
    
    select *
    from employees;
    
    update employees set jubun = '6010151234567'
    where employee_id = 100;
    
    update employees set jubun = '8510151234567'
    where employee_id = 101;
    
    update employees set jubun = '6510152234567'
    where employee_id = 102;
    
    update employees set jubun = '7510151234567'
    where employee_id = 103;
    
    update employees set jubun = '6110152234567'
    where employee_id = 104;
    
    update employees set jubun = '6510151234567'
    where employee_id = 105;
    
    update employees set jubun = '6009201234567'
    where employee_id = 106;
    
    update employees set jubun = '0803153234567'
    where employee_id = 107;
    
    update employees set jubun = '0712154234567'
    where employee_id = 108;
    
    update employees set jubun = '8810151234567'
    where employee_id = 109;
    
    update employees set jubun = '8908152234567'
    where employee_id = 110;
    
    update employees set jubun = '9005052234567'
    where employee_id = 111;
    
    update employees set jubun = '6610151234567'
    where employee_id = 112;
    
    update employees set jubun = '6710151234567'
    where employee_id = 113;
    
    update employees set jubun = '6709152234567'
    where employee_id = 114;
    
    update employees set jubun = '6110151234567'
    where employee_id = 115;
    
    update employees set jubun = '6009301234567'
    where employee_id = 116;
    
    update employees set jubun = '6110152234567'
    where employee_id = 117;
    
    update employees set jubun = '7810151234567'
    where employee_id = 118;
    
    update employees set jubun = '7909151234567'
    where employee_id = 119;
    
    update employees set jubun = '7702152234567'
    where employee_id = 120;
    
    update employees set jubun = '7009151234567'
    where employee_id = 121;
    
    update employees set jubun = '7111011234567'
    where employee_id = 122;
    
    update employees set jubun = '8010131234567'
    where employee_id = 123;
    
    update employees set jubun = '8110191234567'
    where employee_id = 124;
    
    update employees set jubun = '9012132234567'
    where employee_id = 125;
    
    update employees set jubun = '9406251234567'
    where employee_id = 126;
    
    update employees set jubun = '9408252234567'
    where employee_id = 127;
    
    update employees set jubun = '9204152234567'
    where employee_id = 128;
    
    update employees set jubun = '8507251234567'
    where employee_id = 129;
    
    update employees set jubun = '6511111234567'
    where employee_id = 130;
    
    update employees set jubun = '0010153234567'
    where employee_id = 131;
    
    update employees set jubun = '0005254234567'
    where employee_id = 132;
    
    update employees set jubun = '0110194234567'
    where employee_id = 133;
    
    update employees set jubun = '0412154234567'
    where employee_id = 134;
    
    update employees set jubun = '0503253234567'
    where employee_id = 135;
    
    update employees set jubun = '9510012234567'
    where employee_id = 136;
    
    update employees set jubun = '9510021234567'
    where employee_id = 137;
    
    update employees set jubun = '9610041234567'
    where employee_id = 138;
    
    update employees set jubun = '9610052234567'
    where employee_id = 139;
    
    update employees set jubun = '7310011234567'
    where employee_id = 140;
    
    update employees set jubun = '7310092234567'
    where employee_id = 141;
    
    update employees set jubun = '7510121234567'
    where employee_id = 142;
    
    update employees set jubun = '7612012234567'
    where employee_id = 143;
    
    update employees set jubun = '7710061234567'
    where employee_id = 144;
    
    update employees set jubun = '7810052234567'
    where employee_id = 145;
    
    update employees set jubun = '6810251234567'
    where employee_id = 146;
    
    update employees set jubun = '6811062234567'
    where employee_id = 147;
    
    update employees set jubun = '6712052234567'
    where employee_id = 148;
    
    update employees set jubun = '6011251234567'
    where employee_id = 149;
    
    update employees set jubun = '6210062234567'
    where employee_id = 150;
    
    update employees set jubun = '6110191234567'
    where employee_id = 151;
    
    update employees set jubun = '5712062234567'
    where employee_id = 152;
    
    update employees set jubun = '5810231234567'
    where employee_id = 153;
    
    update employees set jubun = '6311051234567'
    where employee_id = 154;
    
    update employees set jubun = '6010182234567'
    where employee_id = 155;
    
    update employees set jubun = '6110191234567'
    where employee_id = 156;
    
    update employees set jubun = '6210112234567'
    where employee_id = 157;
    
    update employees set jubun = '6311132234567'
    where employee_id = 158;
    
    update employees set jubun = '8511112234567'
    where employee_id = 159;
    
    update employees set jubun = '8710131234567'
    where employee_id = 160;
    
    update employees set jubun = '8710072234567'
    where employee_id = 161;
    
    update employees set jubun = '9010171234567'
    where employee_id = 162;
    
    update employees set jubun = '9112072234567'
    where employee_id = 163;
    
    update employees set jubun = '9110241234567'
    where employee_id = 164;
    
    update employees set jubun = '9212251234567'
    where employee_id = 165;
    
    update employees set jubun = '9310232234567'
    where employee_id = 166;
    
    update employees set jubun = '9811151234567'
    where employee_id = 167;
    
    update employees set jubun = '9810252234567'
    where employee_id = 168;
    
    update employees set jubun = '9910301234567'
    where employee_id = 169;
    
    update employees set jubun = '0910153234567'
    where employee_id = 170;
    
    update employees set jubun = '1011153234567'
    where employee_id = 171;
    
    update employees set jubun = '1006153234567'
    where employee_id = 172;
    
    update employees set jubun = '1111154234567'
    where employee_id = 173;
    
    update employees set jubun = '1209103234567'
    where employee_id = 174;
    
    update employees set jubun = '1207154234567'
    where employee_id = 175;
    
    update employees set jubun = '0906153234567'
    where employee_id = 176;
    
    update employees set jubun = '0812113234567'
    where employee_id = 177;
    
    update employees set jubun = '9810132234567'
    where employee_id = 178;
    
    update employees set jubun = '8712111234567'
    where employee_id = 179;
    
    update employees set jubun = '8310012234567'
    where employee_id = 180;
    
    update employees set jubun = '6510191234567'
    where employee_id = 181;
    
    update employees set jubun = '6510221234567'
    where employee_id = 182;
    
    update employees set jubun = '6510232234567'
    where employee_id = 183;
    
    update employees set jubun = '8512131234567'
    where employee_id = 184;
    
    update employees set jubun = '8510182234567'
    where employee_id = 185;
    
    update employees set jubun = '7510192234567'
    where employee_id = 186;
    
    update employees set jubun = '8512192234567'
    where employee_id = 187;
    
    update employees set jubun = '9511151234567'
    where employee_id = 188;
    
    update employees set jubun = '7509302234567'
    where employee_id = 189;
    
    update employees set jubun = '8510161234567'
    where employee_id = 190;
    
    update employees set jubun = '9510192234567'
    where employee_id = 191;
    
    update employees set jubun = '0510133234567'
    where employee_id = 192;
    
    update employees set jubun = '0810194234567'
    where employee_id = 193;
    
    update employees set jubun = '0910183234567'
    where employee_id = 194;
    
    update employees set jubun = '1010134234567'
    where employee_id = 195;
    
    update employees set jubun = '9510032234567'
    where employee_id = 196;
    
    update employees set jubun = '9710181234567'
    where employee_id = 197;
    
    update employees set jubun = '9810162234567'
    where employee_id = 198;
    
    update employees set jubun = '7511171234567'
    where employee_id = 199;
    
    update employees set jubun = '7810172234567'
    where employee_id = 200;
    
    update employees set jubun = '7912172234567'
    where employee_id = 201;
    
    update employees set jubun = '8611192234567'
    where employee_id = 202;
    
    update employees set jubun = '7810252234567'
    where employee_id = 203;
    
    update employees set jubun = '7803251234567'
    where employee_id = 204;
    
    update employees set jubun = '7910232234567'
    where employee_id = 205;
    
    update employees set jubun = '8010172234567'
    where employee_id = 206;
    
    commit;
    
    select *
    from employees;
    
    
    ---------------------------------------------------------------------------------------------------------------
                ---- >>> 단일행 함수 <<< ----
    /*
        ※ 단일행 함수의 종류
        
        1. 문자함수
        2. 숫자함수
        3. 날짜함수
        4. 변환함수
        5. 기타함수
    */
    ---------------------------------------------------------------------------------------------------------------
    
    ---- >>> 1. 문자함수 <<< ----
    
    -- 1.1 upper()   ==> 문자열을 모두 대문자로 변환시켜주는 것
    -- 1.2 lower()   ==> 문자열을 모두 소문자로 변환시켜주는 것
    -- 1.3 initcap() ==> 문자열을 단어별(구분자가 공백) 첫글자만 대문자, 나머지는 모두 소문자로 변환시켜주는 것
    
    select 'kOreA SEOul', upper('kOreA SEOul'), lower('kOreA SEOul'), initcap('kOreA SEOul')
    from dual;
    
    select *
    from employees
    where last_name = 'King';
    
    select *
    from employees
    where last_name = 'king';
    
    select *
    from employees
    where last_name = 'KING';
    
    select *
    from employees
    where last_name = 'kINg'; -- 오라클은 데이터 입력 값은 반드시 대소문자 구분해야 한다.
    -- 구분없이 일치하는 검색 결과를 출력되도록 해보세요.
    select *
    from employees
    where upper(last_name) = upper('kINg'); -- lower, initcap 모두 가능
    
    -- 1.4 substr : 문자열 중 특정문자 또는 문자열의 특정 일부분을 선택해올 때 사용한다.
    select '쌍용교육센터'
         , substr('쌍용교육센터', 2, 3) -- 문자열 '쌍용교육센터'에서 2번째 글자부터 3글자를 뽑아온다(java의 인덱스 개념이 아니다).
         , substr('쌍용교육센터', 2) -- 뽑을 글자 수를 지정하지 않으면 끝까지 뽑아온다.
    from dual;
    
-- *** employees 테이블에서 성별이 '여자'만 사원번호, 사원명, 주민번호를 나타내세요. ***
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
    from employees
    where substr(jubun, 7, 1) = '2' or substr(jubun, 7, 1) = '4'; -- 문자이므로 홑따옴표를 붙여준다.
    
-- *** employees 테이블에서 1990년 ~ 1995년에 태어난 사원중 성별이 '남자'만
-- 사원번호, 사원명, 주민번호를 나타내세요. ***
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
    from employees
    where '90' <= substr(jubun, 1, 2) and
          substr(jubun, 1, 2) <= '95' and
          substr(jubun, 7, 1) = '1';
          
    --- **** 1.5  instr : 어떤 문자열에서 명명된 문자의 위치를 알려주는 것 **** -- java의 indexOf와 유사 개념(하지만 index가 아닌 몇번째 글자인지의 위치)
    select instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', 1, 1)
      -- 3(앞 글자 기준)
      -- '쌍용교육센터 서울교육대학교 교육문화원' 에서 '교육'이 나온 위치를 찾는데
      -- 출발점은 1 번째부터 1번째로 나오는 '교육'의 위치를 알려달라는 말이다. 
      
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', 1, 2)
      -- 10(공백 포함)
      -- '쌍용교육센터 서울교육대학교 교육문화원' 에서 '교육'이 나온 위치를 찾는데
      -- 출발점은 1 번째부터 2번째로 나오는 '교육'의 위치를 알려달라는 말이다.
      
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', 4, 1)
      -- 10(출력 값은 첫 글자로부터의 위치)
      -- '쌍용교육센터 서울교육대학교 교육문화원' 에서 '교육'이 나온 위치를 찾는데
      -- 출발점은 4 번째부터 1번째로 나오는 '교육'의 위치를 알려달라는 말이다.
      
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', 4, 3)
      -- 0(찾고자 하는 문자가 없음)
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', 1)
      -- 3
      -- , 1이 생략되어 있다(1번째로 나오는 문자의 위치)
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', 4)
      -- 10
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', -1, 1)
      -- 16(위치 출력은 역순이 아닌 원래 순서대로 해당하는 위치
      -- 출발점은 문자열의 끝에서부터 역순으로 1번째로 나오는 '교육'의 위치
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', -5, 2)
      -- 10(역순은 첫 글자를 기준으로 시작점이 찾고자하는 문자를 포함할 경우 횟수에 포함)
      -- 출발점은 문자열의 끝에서부터 역순으로 1번째로 나오는 '교육'의 위치
      ,  instr('쌍용교육센터 서울교육대학교 교육문화원', '교육', -1)
    from dual;
    
    --- **** 1.6 reverse : 어떤 문자열을 거꾸로 보여주는 것이다. **** --
    select 'ORACLE', reverse('ORACLE')
         , '대한민국', reverse('대한민국') -- 한글 거꾸로는 깨진다.
         , reverse(reverse('대한민국')) -- 거꾸로를 거꾸로 복구하는 것은 정상 출력
    from dual;
    

-- [퀴즈] --
  create table tbl_files
  (fileno      number(3)
  ,filepath    varchar2(200)
  );
  
  insert into tbl_files(fileno, filepath)
  values(1, 'c:\myDocuments\resume.hwp');
  
  insert into tbl_files(fileno, filepath)
  values(2, 'd:\mymusic.mp3');
  
  insert into tbl_files(fileno, filepath)
  values(3, 'c:\myphoto\2020\08\face.jpg');
  
  commit;
  
  select *
  from tbl_files;
  
  -- 아래와 같이 나오도록 하세요. --
 /* 
  ---------------------------
    파일번호    파일명
  --------------------------- 
       1	   resume.hwp
       2	   mymusic.mp3
       3	   face.jpg
  ----------------------------
 */
    select fileno as 파일번호
         , reverse(substr( reverse(filepath), 1, instr(reverse(filepath),'\',1)-1 )) as 파일명1
         , substr(filepath, instr(filepath, '\', -1)+1) as 파일명2
    from tbl_files;
    
    --- **** 1.7 lpad : 왼쪽부터 문자를 자리채움 **** --
    --- **** 1.8 rpad : 오른쪽부터 문자를 자리채움 **** --
    select lpad('교육센터', 20, '*') -- 20byte를 확보해서 거기에 '교육센터'를 넣은 후, 빈공간(12byte)이 있으면 왼쪽부터 *(크기만큼 반복) 로 채워라.
         , rpad('교육센터', 20, '*') -- 20byte를 확보해서 거기에 '교육센터'를 넣은 후, 빈공간(12byte)이 있으면 오른쪽부터 *(크기만큼 반복) 로 채워라.
    from dual;
    
    --- **** 1.9 ltrim : 왼쪽부터 문자를 제거한다. **** --
    --- **** 1.10 rtrim : 오른쪽부터 문자를 제거한다. **** --
    --- **** 1.11 trim : 왼쪽, 오른쪽 모두부터 공백문자를 제거한다. **** --
    select ltrim('abbbcccccdaabbccdTabbdddSSS', 'abcd') -- 연속된 abcd가 아니라 a 또는 b 또는 c 또는 d 를 의미한다. => 해당하는 문자가 있을 경우 자르고, 아닌 글자가 나오는 지점에서 멈춘다.
         , rtrim('abbbcccccdaabbccdTabbddd', 'abcd')
      -- , trim('abbbcccccdaabbccdTdabcSabbddd', 'abcd') -- TdabcS (X), 오류, 공백문자만 제거할 수 있다.
         , rtrim(ltrim('abbbcccccdaabbccdTdabcSabbddd', 'abcd'), 'abcd') -- TdabcS(양쪽 자르기)
    from dual;
    
    select '쌍용' || '                              교육                             센터'
         , '쌍용' || ltrim('                              교육                             센터') -- 제거해야할 문자를 정하지 않으면 공백을 제거한다.
         , '쌍용                                    ' || '교육                             센터'
         , rtrim('쌍용                                    ') || '교육                             센터'
         , '쌍용' || trim('                               교육                             ') || '센터'
    from dual;
    
    --- **** 1.12 translate **** --
    select translate('010-3456-7890'      -- 문자열에서
                   , '0123456789'         -- 해당 문자가 있으면
                   , '영일이삼사오육칠팔구') -- 해당 문자로 바꿔라(0123456789와 일대일 매핑으로 짝지어져있다).
    from dual;
    
    --- **** 1.13 replace(치환) **** --
    select replace('쌍용교육센터 서울교육대학교 교육문화원'  -- 문자열에서
                 , '교육'                               -- 해당 문자가 있으면
                 , 'education')                         -- 해당 문자로 바꿔라 / translate와 차이는 일대일과 전체의 차이
    from dual;
    
    --- **** 1.14 length => 문자열의 길이를 알려주는 것 **** --
    select length('쌍용center')  -- 8(byte의 크기가 아니다)
    from dual;
    
    
    ---- **** ====== like 연산자 ====== **** ----
    select *
    from employees
    where department_id = 30;
    
    select *
    from employees
    where department_id like 30;
    
    /*
        like 연산자와 함께 사용되어지는 % 와 _ 를 wild character 라고 부른다.
        like 연산자와 함께 사용되어지는 % 의 뜻은 글자가 있든지 없든지 관계없다라는 말(글자수와도 관계없음)
        like 연산자와 함께 사용되어지는 _ 의 뜻은 반드시 아무글자 1개만을 뜻하는 것이다.
    */
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
    from employees
    where jubun like '90____2%' or -- 90년생 월 2자리 일 2자리 여자라는 조건
          jubun like '91____1%';
          
-- employees 테이블에서 first_name 컬럼의 값이 'J'로 시작하는 사원들만
-- 사원번호, 이름, 성, 기본급여를 나타내세요.
    select employee_id AS 사원번호
         , last_name AS 이름
         , first_name AS 성
         , salary AS 기본급여
    from employees
    where first_name like 'J%';
    -- 성이 소문자 s로 끝나는 사원
    select employee_id AS 사원번호
         , last_name AS 이름
         , first_name AS 성
         , salary AS 기본급여
    from employees
    where first_name like '%s';
    -- 성에 ee 가 들어가는 사원
    select employee_id AS 사원번호
         , last_name AS 이름
         , first_name AS 성
         , salary AS 기본급여
    from employees
    where first_name like '%ee%';
    -- 성에 최소한 e가 두번 들어가는 사원
    select employee_id AS 사원번호
         , last_name AS 이름
         , first_name AS 성
         , salary AS 기본급여
    from employees
    where first_name like '%e%e%';
    -- 이름이 F로 시작하고 세번째에는 e 가 들어가는 사원
    select employee_id AS 사원번호
         , last_name AS 이름
         , first_name AS 성
         , salary AS 기본급여
    from employees
    where last_name like 'F_e%';
    
    
-- *** like 연산자와 함께 사용되어지는 % 와 _ 는 어떤 뜻을 가지고 있는 wild character 인데 
  --     이러한 wild character 를 없애버리도록 해본다. *** --
  create table tbl_watch
  (watchname   Nvarchar2(10)  -- varchar2 의 단위는 byte , Nvarchar2 의 단위는 글자 수(영어권에서는 글자 수 = byte이므로 서로 같다)
  ,bigo        Nvarchar2(100)
  );
  
  insert into tbl_watch(watchname, bigo)
  values('금시계', '순금 99.99% 함유 고급시계');
  
  insert into tbl_watch(watchname, bigo)
  values('은시계', '고객만족도 99.99점 획득한 고급시계');
  
  commit;
  
  select *
  from tbl_watch;
  
  -- tbl_watch 테이블에서 bigo 컬럼에 99.99% 라는 글자가 들어있는 행만 추출하세요 --
  select *
  from tbl_watch
  where bigo like '%99.99%%'; -- % 를 percent 로 인식하지 않고 wild character 로 인식한다.
  
  select *
  from tbl_watch
  where bigo like '%99.99\%%' escape '\';
  -- % 를 wild character 기능에서 탈출시켜야만 퍼센트라고 인식된다.
  -- escape 다음에 정의된 글자(아무거나 지정할 수 있다)를 탈출시키고자 하는 wild character 앞에 적어주면, 그 한글자만 탈출한다.
  
  select *
  from tbl_watch
  where bigo like '%99.992%%' escape '2';
  
  select *
  from tbl_watch
  where bigo like '%99.99a%%' escape 'a'; -- 숫자나 문자는 검색하고자 하는 값으로 혼동할 수 있으므로 가급적 특수문자로 사용한다.
  
  
    ---- >>> 2. 숫자함수 <<< ----
    -- 2.1 mod : 나머지를 구해주는 것.
    select 5/2, mod(5,2), trunc(5/2) -- 소수점 이하를 제거하는 함수 => 몫
    from dual;
    
    -- 2.2 round : 반올림을 해주는 것.
    select 94.547
         , round(94.547)     -- 95
         , round(94.547, 0)  -- 95,    0 은 정수 1자리까지 반올림(, 0 은 생략 가능)
         , round(94.547, 1)  -- 94.5,  1 은 소수 첫째자리까지만 나타내준다.
         , round(94.547, 2)  -- 94.55, 2 는 소수 둘째자리까지만 나타내준다.
         , round(94.547, -1) -- 90,    -1 은 정수 10자리까지 반올림
         , round(94.547, -2) -- 100,   -2 은 정수 100자리까지 반올림
    from dual;
    
    -- 2.3 trunc : 절삭 해주는 것
    select 94.547
         , trunc(94.547)     -- 94
         , trunc(94.547, 0)  -- 94,    0 은 정수 1자리까지를 제외한 아래 자리는 자른다(, 0 은 생략 가능).
         , trunc(94.547, 1)  -- 94.5,  1 은 소수 첫째자리까지
         , trunc(94.547, 2)  -- 94.54, 2 는 소수 둘째자리까지
         , trunc(94.547, -1) -- 90,    -1 은 정수 10자리까지
         , trunc(94.547, -2) -- 0,   -2 은 정수 100자리까지
    from dual;
    

create table tbl_sungjuk
(hakbun   varchar2(20) 
,name     varchar2(20)
,kor      number(3)
,eng      number(3)
,math     number(3)
);

insert into tbl_sungjuk(hakbun, name, kor, eng, math)
values('SIST001','한석규', 90, 92, 93);

insert into tbl_sungjuk(hakbun, name, kor, eng, math)
values('SIST002','두석규', 100, 100, 100);

insert into tbl_sungjuk(hakbun, name, kor, eng, math)
values('SIST003','세석규', 71, 72, 73);

insert into tbl_sungjuk(hakbun, name, kor, eng, math)
values('SIST004','네석규', 89, 87, 81);

insert into tbl_sungjuk(hakbun, name, kor, eng, math)
values('SIST005','오석규', 60, 50, 40);

insert into tbl_sungjuk(hakbun, name, kor, eng, math)
values('SIST006','육석규', 80, 81, 87);

commit;

select *
from tbl_sungjuk;

/*
-------------------------------------------------------------------------
학번  성명  국어  영어  수학  총점  평균(소수부첫째자리까지 나타내되 반올림)  학점
-------------------------------------------------------------------------
*/
    select hakbun AS 학번
         , name AS 성명
         , kor AS 국어
         , eng AS 영어
         , math AS 수학
         , kor + eng + math AS 총점
         , round((kor+eng+math)/3, 1) AS 평균
         , case trunc((kor+eng+math)/3, -1)
           when 100 then 'A'
           when 90 then 'A'
           when 80 then 'B'
           when 70 then 'C'
           when 60 then 'D'
           else 'F' end AS 학점
         , decode(trunc((kor+eng+math)/3, -1), 100, 'A', 90, 'A', 80, 'B', 70, 'C', 60, 'D', 'F') AS 학점
    from tbl_sungjuk;
    
    -- 2.4 power : 거듭제곱
    select 2*2*2*2*2, power(2,5)
    from dual;
    
    -- 2.5 sqrt : 제곱근
    select sqrt(4), sqrt(16), sqrt(2), sqrt(3)
    from dual;
    
    -- 2.6 sin, cos, tan, asin, acos, atan
    select sin(90), cos(90), tan(90),
           asin(0.3), acos(0.3), atan(0.3)
    from dual;
    
    -- 2.7 log
    select log(10,100)
    from dual;
    
    -- 2.8 ascii , chr
    select ascii('A'), ascii('a'), ascii('0'), ascii(' ')
    from dual;
    
    select chr(65), chr(97), chr(48), chr(32)
    from dual;
    
    -- 2.9 sign : 결과값이 양수라면 1, 결과값이 0 이면 0, 결과값이 음수라면 -1
    select sign(5-2), sign(5-5), sign(2-5)
    from dual;
    
    -- 2.10 ceil , floor
    -- ceil(실수) ==> 입력된 실수 보다 큰 최소의 정수를 나타내어준다.
    -- ceil(정수) ==> 입력되어진 정수 그대로 나온다.
    select ceil(10.1), ceil(-10.1), ceil(10), ceil(-10)
    from dual;
    
    -- floor(실수) ==> 입력된 실수 보다 작은 최대의 정수를 나타내어준다.
    -- floor(정수) ==> 입력되어진 정수 그대로 나온다.
    select floor(10.1), floor(-10.1), floor(10), floor(-10)
    from dual;
    
    
    ---- >>> 3. 날짜함수 <<< ----
    -- DATE 타입의 기본적인 표현방식은 'YY/MM/DD' 으로 나타내어진다.
    --                      YY 은 년도의 2자리만 나타낸다. 50 ~ 99 은 1950 ~ 1999 이다.
    --                      YY 은 년도의 2자리만 나타낸다. 00 ~ 49 은 2000 ~ 2049 이다.
    --                      MM 은 월이고, DD 는 일이다.
    
    -- **** ==== 현재 시각을 알려주는 것 ==== **** --
    select sysdate, current_date, localtimestamp, current_timestamp, systimestamp
    from dual;
    
    /*
        날짜 + 숫자 = 날짜
        날짜 - 숫자 = 날짜
        
        여기서 숫자의 단위는 일 이다.
    */
    
    select sysdate - 1 AS 어제시각
         , sysdate AS 현재시각
         , sysdate + 1 AS 내일시각
    from dual;
    
    select to_char(sysdate - 1, 'yyyy-mm-dd hh24:mi:ss') AS 어제시각
         , to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') AS 현재시각
         , to_char(sysdate + 1, 'yyyy-mm-dd hh24:mi:ss') AS 내일시각
    from dual;
    
    -- 1 kg = 1000 g
    -- 1 g = 1/1000 kg
    -- 1 일 = 24시간
    -- [퀴즈] 현재시각 및 현재시각으로 부터 1일 2시간 3분 4초 뒤를 나타내세요
    --        yyyy-mm-dd hh24:mi:ss
    select to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') AS 현재시각
         , to_char(sysdate + (86400+7200+180+4)/86400, 'yyyy-mm-dd hh24:mi:ss') AS "1일 2시간 3분 4초 뒤"
    from dual;
    
    
    -- 3.1 add_months(날짜, 숫자) => 날짜에서 숫자만큼 개월 수를 더해주는 것. 숫자는 단위는 개월
    select to_char(add_months(sysdate, -2), 'yyyy-mm-dd hh24:mi:ss') AS "2개월전"
         , to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') AS 현재
         , to_char(add_months(sysdate, 2), 'yyyy-mm-dd hh24:mi:ss') AS "2개월후"
    from dual;
    
    -- ***[퀴즈] 오늘 부로 김민성씨가 또 군대에 끌려갑니다.
    --           근무개월수가 18개월 이라고 할때 제대일자(년-월-일)를 구하세요.
    select to_char(add_months(sysdate, 18), 'yyyy-mm-dd') AS 제대일자
    from dual;
    
    -- 3.2 months_between(날짜1, 날짜2)
    --     날짜1 - 날짜2 값으로 숫자가 나오는데 그 단위는 개월이다.
    --     즉, 두 날짜의 개월차이를 구할때 사용한다.
    select months_between(add_months(sysdate, 18), sysdate)
    from dual;
    
    --    *기본적으로 날짜1 - 날짜2 은 숫자가 나오는데 그 단위는 일 이다.
    select sysdate + 3 - sysdate
    from dual;
    
    -- 3.3 last_day(특정날짜) ==> 특정날짜가 포함된 달력에서 맨 마지막날을 알려주는 것이다 / 형식은 기본날짜형식으로 나온다.
    select to_char(last_day(sysdate), 'yyyy-mm-dd')
         , last_day('2019-02-05') -- 자동형변환(to_date('2019-02-05', 'yyyy-mm-dd'))
         , to_char(last_day(to_date('2019-02-05', 'yyyy-mm-dd')), 'yyyy-mm-dd')
         , to_char(last_day(to_date('2020-02-05', 'yyyy-mm-dd')), 'yyyy-mm-dd')
    from dual;
    
/*
   [퀴즈]
   employees 테이블에서
   사원번호, 사원명, 주민번호, 성별, 현재나이, 월급, 입사일자, 정년퇴직일 을 나타내세요.

   여기서 정년퇴직일이라 함은 
   해당 사원의 생월이 3월에서 8월에 태어난 사람은 
   해당사원의 나이(한국나이)가 63세가 되는 년도의 8월 31일로 하고,
   해당사원의 생월이 9월에서 2월에 태어난 사람은 
   해당사원의 나이(한국나이)가 63세가 되는 년도의 2월말일(2월28일 또는 2월29일)로 한다.
*/
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS 성별
         , extract(year from sysdate) - (substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 AS 현재나이
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         , to_char(hire_date, 'yyyy-mm-dd') AS 입사일자
         -- 원하는 월을 결과값으로 반환하기 위해 임의의 8월의 날을 문자 형식으로 연도와 결합해주자.
--       , case  
--         when substr(jubun,3,2) between '03' and '08' then to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || '-08-01'), 'yyyy-mm-dd')
--         else to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || '-02-01'), 'yyyy-mm-dd')
--         end AS 정년퇴직일
         , to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || case when substr(jubun,3,2) between '03' and '08' then '-08-01' else '-02-01' end), 'yyyy-mm-dd') AS 정년퇴직일
    from employees;
    
    -- 3.4 next_day(특정날짜, '일') '일' : '일' ~ '토'
    --     ==> 특정날짜로 부터 다음번에 돌아오는 가장 빠른 '일'~'토'의 날짜를 알려주는 것이다.
    select sysdate
         , next_day(sysdate, '금') -- 해당 날짜 다음날부터 돌아오는 가장 빠른 금요일
         , next_day(sysdate, '토')
    from dual;
    
    -- 3.5 extract ==> 날짜에서 년, 월, 일을 숫자형태로 추출해주는 함수이다.
    select sysdate
         , extract(year from sysdate), to_char(sysdate, 'yyyy')
         , extract(month from sysdate), to_char(sysdate, 'mm')
         , extract(day from sysdate), to_char(sysdate, 'dd')
    from dual;
    
    -- 3.6 to_yminterval, to_dsinterval
    --     현재일로 부터 1년 2개월 3일 4시간 5분 6초 뒤를 나타내시오.
    select to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') AS 현재시각
         , to_char(sysdate + to_yminterval('01-02') + to_dsinterval('003 04:05:06') -- yminterval(1년 2개월), dsinterval(3일 4시간 5분 6초)
                 , 'yyyy-mm-dd hh24:mi:ss') AS "1년2개월3일4시간5분6초" -- alias는 최대 30byte
    from dual;
    

create table tbl_loan
(gejanum        varchar2(10)   -- 통장번호
,loanmoney      number         -- 대출금
,interestrate   number(2,2)    -- 이자율
,paymentdate    varchar2(2)    -- 이자를내는날짜 '01', '05', '16', '20', 매월말일 '00'
);           

insert into tbl_loan(gejanum, loanmoney, interestrate, paymentdate)
values('10-1234-01', 5000, 0.03, '01');

insert into tbl_loan(gejanum, loanmoney, interestrate, paymentdate)
values('10-1234-02', 5000, 0.03, '05');

insert into tbl_loan(gejanum, loanmoney, interestrate, paymentdate)
values('10-1234-03', 5000, 0.03, '16');

insert into tbl_loan(gejanum, loanmoney, interestrate, paymentdate)
values('10-1234-04', 5000, 0.03, '00');

commit;

select *
from tbl_loan;

---- *** 해당날짜에 대한 요일명을 알아오는 것 *** ----
select to_char(sysdate, 'day') -- '금요일'(windows), 'Friday'(linux)
     , to_char(sysdate, 'dy')  -- '금'            , 'Fri'
     , to_char(sysdate, 'd')   -- 6               , 6 ( 1(일) 2(월) 3(화) 4(수) 5(목) 6(금) 7(토) ) - 호환 위해 주로 사용
from dual;

select decode(to_char(sysdate, 'd'), '1', '일'
                                   , '2', '월'
                                   , '3', '화'
                                   , '4', '수'
                                   , '5', '목'
                                   , '6', '금'
                                   , '7', '토') AS 오늘의요일명 -- 요일명을 표시할 때 이 코드로 주로 사용
from dual;

select T.*
     , (이번달이자납부일 - 지난달이자납부일)*loanmoney*interestrate -- 날짜 - 날짜 = 숫자(단위 : 일)
from
(
    select gejanum, loanmoney, interestrate, paymentdate
         , decode( to_char(currentpaymentdate, 'd'), '1', currentpaymentdate+1
                                                   , '7', currentpaymentdate+2
                                                        , currentpaymentdate ) AS 이번달이자납부일
         , decode( to_char(prevpaymentdate, 'd'), '1', prevpaymentdate+1
                                                , '7', prevpaymentdate+2
                                                     , prevpaymentdate ) AS 지난달이자납부일
    from
    (
        select gejanum, loanmoney, interestrate, paymentdate
             , decode(paymentdate, '00', last_day(sysdate)
                                       , to_date( to_char(sysdate, 'yyyy-mm-') || paymentdate, 'yyyy-mm-dd' )) AS currentpaymentdate -- 위는 날짜 아래는 문자 타입이기 때문에 기본적으로 형변환을 해야하지만 자동형변환도 이루어진다.
             , decode(paymentdate, '00', last_day(add_months(sysdate, -1))
                                       , to_date( to_char(add_months(sysdate, -1), 'yyyy-mm-') || paymentdate, 'yyyy-mm-dd' )) AS prevpaymentdate
        from tbl_loan
    ) V
) T;
    

---- **** 아주아주아주아주아주아주아주아주아주아주아주 중요 !!!!!!! **** ----
--     inline view (인라인 뷰)
/*
       View(뷰)는 테이블은 아니지만 select 되어진 결과물이 테이블 형태를 띄기 때문에
       select 구문을 마치 테이블 처럼 보는것(간주하는것)을 말한다.
       View(뷰)는 inline view (인라인 뷰) 와 Stored View (저장된 뷰)가 있다.
       inline view (인라인 뷰)는 1회용이라고 볼 수 있고,
       Stored View (저장된 뷰)는 저장되었기 때문에 언제든지 꺼내어 사용할 수 있다.
*/
    
-- *** 퇴직금이라함은 근무년수*월급 으로 하겠다. ***
--     만약에 27개월 근무를 했다면 27/12 * 월급 ==> 2.25 * 월급 ==> trunc(2.25) * 월급
--     정년퇴직일에서 입사일까지 개월의 차이를 구하면 되겠다.
--     trunc( trunc(months_between(정년퇴직일, 입사일))/12 ) * 월급

    select V.*
         , trunc( trunc(months_between(V.정년퇴직일, V.입사일자))/12 ) * V.월급 AS 퇴직금
    from
    (
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS 성별
         , extract(year from sysdate) - (substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 AS 현재나이
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         , to_char(hire_date, 'yyyy-mm-dd') AS 입사일자
         , to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || case when substr(jubun,3,2) between '03' and '08' then '-08-01' else '-02-01' end), 'yyyy-mm-dd') AS 정년퇴직일
    from employees
    ) V; -- inline view 라고 부른다 / 결과물을 하나의 테이블로 만들어 해당 테이블 및 컬럼 자체를 활용할 수 있도록 한다.
    
    
    select V.*  -- * 앞에는 생략 불가
         , trunc( trunc(months_between(정년퇴직일, 입사일자))/12 ) * 월급 AS 퇴직금  -- V. (테이블명.) 은 생략이 가능하다.
    from
    (
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS 성별
         , extract(year from sysdate) - (substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 AS 현재나이
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         , to_char(hire_date, 'yyyy-mm-dd') AS 입사일자
         , to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || case when substr(jubun,3,2) between '03' and '08' then '-08-01' else '-02-01' end), 'yyyy-mm-dd') AS 정년퇴직일
    from employees
    ) V
    where 현재나이 >= 50 and 성별 = '여';
    
--- >>> *** Stored View(저장된 뷰) *** <<< ---
    create or replace view 뷰명
    as
    select 문장;
    
    create or replace view view_employees_retire
    as
    select employee_id -- 일반적으로 호환을 위해 컬럼 이름을 영어로 지정한다.
         , first_name || ' ' || last_name AS ename
         , jubun
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS gender
         , extract(year from sysdate) - (substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 AS age
         , nvl(salary + (salary*commission_pct), salary) AS monthsal
         , to_char(hire_date, 'yyyy-mm-dd') AS hire_date
         , to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || case when substr(jubun,3,2) between '03' and '08' then '-08-01' else '-02-01' end), 'yyyy-mm-dd') AS retire_date
    from employees; -- 생성 완료
    
    select *
    from view_employees_retire;
    
    select employee_id, ename, jubun, gender, age, monthsal, hire_date, retire_date, trunc( trunc(months_between(retire_date, hire_date))/12 ) * monthsal AS 퇴직금 -- 추가 컬럼을 지정할 때는 * 이 아닌 전체 컬럼명을 직접 기입해야 한다.
    from view_employees_retire
    where age >= 50 and gender = '남';
    
    select * from tab;
    -- 현재 오라클 서버에 접속한 사용자(지금은 HR) 소유의 테이블명과 뷰명을 조회해주는 것이다.
    
    select *
    from locations;  -- 테이블인지 뷰인지 알 수 없다.
    
    select *
    from tbl_board;  -- 확인하지 않아도 테이블임을 알 수 있다.
    
    select *
    from view_employees_retire;  -- 확인하지 않아도 뷰임을 알 수 있다.
    
    desc view_employees_retire;
    
    --- *** 테이블이나 뷰를 생성한 이후에는 반드시 코멘트(주석)를 꼭 달아주도록 합시다.!!! *** ---
    select *
    from user_tab_comments;
    
    comment on table view_employees_retire
    is '사원들의 정년퇴직일과 퇴직금을 알려주는 VIEW';
    
    --- *** 생성한 테이블이나 뷰의 컬럼에도 반드시 코멘트(주석)를 꼭 달아주도록 합시다.!!! *** ---
    select *
    from user_col_comments
    where table_name = 'EMPLOYEES';  -- 데이터 값만큼은 대소문자를 구분해주어야 한다!
    
    comment on column employees.jubun
    is '주민등록번호';
    
    comment on column view_employees_retire.gender
    is '성별';
    
    comment on column view_employees_retire.retire_date
    is '정년퇴직일자';
    
    select *
    from user_col_comments
    where table_name = 'VIEW_EMPLOYEES_RETIRE';
    
    --- **** Stored View(저장된 view)의 원본소스(select문)를 보겠다. **** ---
    select *
    from user_views -- 저장한 view 목록
    where view_name = 'VIEW_EMPLOYEES_RETIRE';
    /*
    "select employee_id -- 일반적으로 호환을 위해 컬럼 이름을 영어로 지정한다.
         , first_name || ' ' || last_name AS ename
         , jubun
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS gender
         , extract(year from sysdate) - (substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 AS age
         , nvl(salary + (salary*commission_pct), salary) AS monthsal
         , to_char(hire_date, 'yyyy-mm-dd') AS hire_date
         , to_char(last_day(to_char(63+(substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end)-1) || case when substr(jubun,3,2) between '03' and '08' then '-08-01' else '-02-01' end), 'yyyy-mm-dd') AS retire_date
    from employees"
    */
    
    --- **** Stored View(저장된 view)의 원본소스(select문)를 변경하겠다. **** ---
    create or replace view view_employees_retire  -- 기존의 view를
    as
    select department_id, department_name  -- 해당 select문으로 변경.
    from departments;
    
    create view view_test1  -- 없는 view 추가가능
    as
    select employee_id, first_name
    from employees;
    
    replace view view_test1  -- 변경은 단독으로 요구할 수 없다. => create or replace
    as
    select employee_id, first_name, salary
    from employees;
    
    create or replace view view_test1  -- view 가 없으면 만들고, 있으면 교체
    as
    select employee_id, first_name, salary
    from employees;
    
    select *
    from view_test1;
    
    select *
    from user_views;
    
    --- **** Stored View(저장된 view) 삭제하기 **** ---
    drop view view_test1;
    
    select * from tab;
    
    
    ---- >>> 4. 변환함수 <<< ----
    -- 4.1 to_char()   => 날짜를 문자형태로 변환, 숫자를 문자형태로 변환
    select to_char(sysdate, 'yyyy') AS 년도
         , to_char(sysdate, 'mm') AS 월
         , to_char(sysdate, 'dd') AS 일
         , to_char(sysdate, 'hh24') AS "24시간"
         , to_char(sysdate, 'hh am') AS "12시간"
         , to_char(sysdate, 'hh pm') AS "12시간"
         , to_char(sysdate, 'mi') AS 분
         , to_char(sysdate, 'ss') AS 초
         , to_char(sysdate, 'q') AS 분기 --  1월~3월 : 1 , 4월~6월 : 2 , 7월~9월 : 3 , 10월~12월 : 4   
         , to_char(sysdate, 'day') AS 요일명
         , to_char(sysdate, 'dy') AS 요일명
    from dual;
 
    select to_char(sysdate, 'ddd') -- 올해 중 몇 번째 날
         , to_char(sysdate, 'dd')  -- 이번달 중 몇 번째 날
         , to_char(sysdate, 'd')   -- 이번주 중 몇 번째 날(요일)
    from dual;
 
    select to_char(sysdate, 'sssss') -- 지정 날짜의 0시 0분 0초부터 흐른 시간(초 단위)
    from dual;
 
    select 123456789
         , to_char(123456789, '999,999,999') -- 9개의 숫자를 3자리마다 콤마를 찍은 문자형태로 변환
         , to_char(123456789, '$999,999,999')
         , to_char(123456789, 'L999,999,999') -- 해당 지역의 화폐 기호를 붙인다.
    from dual;
    
    -- 4.2 to_date()   => 문자를 날짜형태로 변환
    select to_date('2020-08-13', 'yyyy-mm-dd') + 1 -- 시, 분, 초를 작성하지 않으면 0시 0분 0초로 저장된다.
    from dual;
    
    -- 4.3 to_number() => 문자를 숫자형태로 변환
    select '5'+'2'
         , to_number('5')+to_number('2')
    from dual;
    
    
    ---- >>> 5. 기타함수 <<< ----
    -- 5.1 case when then else end (암기!!!)
    select case 5-2
           when 4 then '5-2=4 입니다.' -- 케이스가 참일때 실행하고 끝, 거짓이면 내려간다.
           when 1 then '5-2=1 입니다.'
           when 3 then '5-2=3 입니다.'
           else '나는 수학을 몰라요ㅜㅜ' -- 모두 거짓일때 else
           end AS 결과
    from dual;
    -- 같다의 조건만 가능하다.
    
    select case
           when 4>5 then '4는 5보다 큽니다.'
           when 5>7 then '5는 7보다 큽니다.'
           when 3>2 then '3은 2보다 큽니다.'
           else '나는 수학을 몰라요ㅜㅜ' -- 모두 거짓일때 else
           end AS 결과
    from dual;
    -- case를 작성하지 않고 when에서 참, 거짓 조건을 따진다.
    
    -- 5.2 decode(case when then else end는 ms에서도 사용하지만, decode는 오라클에서만 쓴다)
    select decode(5-2, 4, '5-2=4 입니다.'
                     , 1, '5-2=1 입니다.'
                     , 3, '5-2=3 입니다.'
                        , '나는 수학을 몰라요ㅜㅜ') AS 결과
    from dual;
    
-- employees 테이블에서 아래와 같이 나오도록 하세요.
/*
    -------------------------------
    사원번호 사원명 주민번호       성별
    -------------------------------
    예)
     ....    ...  9610201234567 남
     ....    ...  9510202234567 여
*/

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
         , case substr(jubun,7,1)
           when '1' then '남'
           when '2' then '여'
           when '3' then '남'
           when '4' then '여'
           else '외국인입니다.'
           end as 성별
    from employees
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
         , decode(substr(jubun,7,1), '1', '남'
                                   , '2', '여'
                                   , '3', '남'
                                   , '4', '여'
                                        , '외국인입니다.') as 성별
    from employees
    
-- employees 테이블에서 아래와 같이 나오도록 하세요.
/*
    ------------------------------------------
    사원번호 사원명 주민번호       성별  태어난연도
    ------------------------------------------
    예)
     ....    ...  9610201234567 남   1996
     ....    ...  9510202234567 여   1995
     ....    ...  0010203234567 남   2000
*/

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
         , case substr(jubun,7,1)
           when '1' then '남'
           when '2' then '여'
           when '3' then '남'
           when '4' then '여'
           else '외국인입니다.'
           end as 성별
         , case
           when substr(jubun,1,2) >= '50' then '19' || substr(jubun,1,2)
           when substr(jubun,1,2) <= '49' then '20' || substr(jubun,1,2)
           end as 태어난년도
    from employees
    -- 연도로 비교
    
    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
         , case substr(jubun,7,1)
           when '1' then '남'
           when '2' then '여'
           when '3' then '남'
           when '4' then '여'
           end as 성별
         , decode(substr(jubun,7,1), '1', '19' || substr(jubun,1,2)
                                   , '2', '19' || substr(jubun,1,2)
                                   , '3', '20' || substr(jubun,1,2)
                                   , '4', '20' || substr(jubun,1,2)) as 태어난년도
    from employees
    -- 뒷자리의 첫 수(1, 2는 90년생, 3, 4는 2000년생)에 따라 실행
    
    select sysdate
         , to_char(sysdate, 'yyyy')   -- 문자로 연도 추출
         , extract(year from sysdate) -- 숫자로 연도 추출
    from dual;
    
    select '1997'
         , to_number('1997')
         , '1997'+1 -- 문자열 + 숫자 => 자동 형변환
         , '1997'+'1' -- 자동 형변환
         , to_number('1997')+1 -- 형변환 후 연산하는 것이 정석
    from dual;
    
-- employees 테이블에서 아래와 같이 나오도록 하세요.
/*
    ----------------------------------------------------
    사원번호 사원명 주민번호       성별  태어난연도   현재나이
    ----------------------------------------------------
    예)
     ....    ...  9610201234567 남   1996        현재년도 - 태어난년도 + 1
     ....    ...  9510202234567 여   1995
     ....    ...  0010203234567 남   2000
*/

    select employee_id as 사원번호
         , first_name || ' ' || last_name as 사원명
         , jubun as 주민번호
         , case substr(jubun,7,1)
           when '1' then '남'
           when '2' then '여'
           when '3' then '남'
           when '4' then '여'
           else '외국인입니다.'
           end as 성별
           /*
           2.
           case when substr(jubun,7,1) in('2','4') then '여' else '남' end as 성별
           3.
           decode(substr(jubun,7,1), '1', '남'
                                   , '3', '남'
                                        , '여') as 성별
           */
         , case
           when substr(jubun,1,2) >= '50' then '19' || substr(jubun,1,2)
           when substr(jubun,1,2) <= '49' then '20' || substr(jubun,1,2)
           end as 태어난년도
           /*
           1.
           case when substr(jubun,7,1) in('1','2') then '19' else '20' end || substr(jubun,1,2) as 태어난년도 -- 공통적인 부분을 end에 묶어 적을 수 있다.
           2.
           substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1990 else 2000 end as 태어난년도  -- 자동형변환
           */
         , case
           when substr(jubun,1,2) >= '50' then extract(year from sysdate) - to_number('19' || substr(jubun,1,2)) + 1
           when substr(jubun,1,2) <= '49' then extract(year from sysdate) - to_number('20' || substr(jubun,1,2)) + 1
           end as 현재나이
           -- extract(year from sysdate) - ( substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1990 else 2000 end ) + 1 AS 현재나이
    from employees
    
    
    create table tbl_members
    (userid    varchar2(20)
    ,passwd    varchar2(20)
    ,name      varchar2(20)
    ,addr      varchar2(100)
    );
    
    insert into tbl_members(userid, passwd, name, addr)
    values('kimys','abcd','김유신','서울');
    
    insert into tbl_members(userid, passwd, name, addr)
    values('young2','abcd','이영이','서울');
    
    insert into tbl_members(userid, passwd, name, addr)
    values('leesa','abcd','이에리사','서울');
    
    insert into tbl_members(userid, passwd, name, addr)
    values('park','abcd','박이남','서울');
    
    insert into tbl_members(userid, passwd, name, addr)
    values('leebon','abcd','이본','서울');
    
    commit;
    
    select *
    from tbl_members;
    
    select count(*)  -- 5행
    from tbl_members;
    
    select *
    from tbl_members
    where userid='kimys' and passwd='abcd';
    
    select count(*)  -- 1행
    from tbl_members
    where userid='kimys' and passwd='abcd';
    
    select count(*)  -- 0행
    from tbl_members
    where userid='superman' and passwd='abcd';
    
    select *
    from tbl_members
    where userid='kimys' and passwd='1234';
    
    select count(*)  -- 0행
    from tbl_members
    where userid='kimys' and passwd='1234';
    
    select case( select count(*)
                 from tbl_members
                 where userid='superman' and passwd='1234' )
           when 1 then '로그인성공'
           else( case( select count(*)
                 from tbl_members
                 where userid='superman' )
                 when 1 then '암호가 틀립니다'
                 else '아이디가 존재하지 않습니다'
                 end
                 )
           end AS LOGIN결과
    from dual;
    
    select decode((select count(*)
                   from tbl_members
                   where userid='kimys' and passwd='abcd'), '1', '로그인성공'
                                                               , decode((select count(*)
                                                                         from tbl_members
                                                                         where userid='kimys'), '1', '암호가 틀립니다'
                                                                                                   , '아이디가 존재하지 않습니다')) AS LOGIN결과
    from dual;
    
    
    create table tbl_board         
    (boardno       number          -- 글번호
    ,subject       varchar2(4000)  -- 글제목
    ,content       varchar2(4000) -- 글내용
    ,userid        varchar2(40)    -- 글쓴이의 ID  
    ,registerday   date            -- 작성일자
    ,readcount     number(10)      -- 조회수               
    );
    
    insert into tbl_board(boardno, subject, content, userid, registerday, readcount)
     values(1, '안녕하세요', '글쓰기 연습입니다', 'leess', sysdate, 0);
     -- sysdate 는 현재시각을 말한다. 
     
     insert into tbl_board(boardno, subject, content, userid, registerday, readcount)
     values(2, '반갑습니다', '모두 취업대박 나십시오', 'eomjh', sysdate, 0);
      
     insert into tbl_board(boardno, subject, content, userid, registerday, readcount)
     values(3, '건강하세요', '로또 1등을 기원합니다', 'leess', sysdate, 0);
      
     insert into tbl_board(boardno, subject, content, userid, registerday, readcount)
     values(4, '기쁘고 감사함이 넘치는 좋은하루되세요 ', '늘 행복하세요', 'emojh', sysdate, 0);
    
     insert into tbl_board(boardno, subject, content, userid, registerday, readcount)
     values(5, '오늘도 좋은하루되세요', '늘 감사합니다', 'hongkd', sysdate, 0);
    
     insert into tbl_board(boardno, subject, content, userid, registerday, readcount)
     values(6, '좋은 하루 되시고 건강하시고 부자되시고 늘 행복하세요', '맛있는 점심 드세요', 'leess', sysdate, 0);
    
     commit;
     
     select *
     from tbl_board;
    
-- 제목이 16 글자보다 크면 16+...으로 출력
-- subject 컬럼의 값의 길이가 16보다 크면 subject 컬럼의 값중 16글자만 보여주고 뒤에 ... 으 붙여서 보여라.
    select boardno
         , subject
         , case
           when length(subject)>16 then substr(subject, 1, 16) || '...'
           else subject
           end AS 기사제목
    from tbl_board
    order by 1 desc;
    
    -- 기사제목에 건강이 있는 행 추출
    select *
    from tbl_board
    where subject like '%건강%';
    
/*
문제 1. 
employees 테이블에서 커미션을 받는 사원들만 
사원번호, 사원명, 기본급여, 수당, 월급을 
사원번호로 오름차순 정렬후, 월급의 내림차순으로 정렬하여 나타내세요.

------------------------------------------------------
사원번호    사원명            기본급여 수당     월급
------------------------------------------------------
145	    John Russell	    14000	5600	19600
146	    Karen Partners	    13500	4050	17550
147	    Alberto Errazuriz	12000	3600	15600
148	    Gerald Cambrault	11000	3300	14300
149	    Eleni Zlotkey	    10500	2100	12600
150	    Peter Tucker	    10000	3000	13000
151	    David Bernstein	    9500	2375	11875
152	    Peter Hall	        9000	2250	11250
153	    Christopher Olsen	8000	1600	9600
154	    Nanette Cambrault	7500	1500	9000
155	    Oliver Tuvault	    7000	1050	8050
156	    Janette King	    10000	3500	13500
157	    Patrick Sully	    9500	3325	12825
158	    Allan McEwen	    9000	3150	12150
159	    Lindsey Smith	    8000	2400	10400
160	    Louise Doran	    7500	2250	9750
161	    Sarath Sewall	    7000	1750	8750
162	    Clara Vishney	    10500	2625	13125
163	    Danielle Greene	    9500	1425	10925
164	    Mattea Marvins	    7200	720	    7920
165	    David Lee	        6800	680	    7480
166	    Sundar Ande	        6400	640	    7040
167	    Amit Banda	        6200	620	    6820
168	    Lisa Ozer	        11500	2875	14375
169	    Harrison Bloom	    10000	2000	12000
170	    Tayler Fox	        9600	1920	11520
171	    William Smith	    7400	1110	8510
172	    Elizabeth Bates	    7300	1095	8395
173	    Sundita Kumar	    6100	610	    6710
174	    Ellen Abel	        11000	3300	14300
175	    Alyssa Hutton	    8800	2200	11000
176	    Jonathon Taylor	    8600	1720	10320
177	    Jack Livingston	    8400	1680	10080
178	    Kimberely Grant	    7000	1050	8050
179	    Charles Johnson	    6200	620	    6820
*/
    
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , salary AS 기본급여
         , salary * commission_pct AS 수당
         , nvl(salary + (salary*commission_pct), salary) AS 월급
    from employees
    where commission_pct is not null;
    order by 1, 5 desc;

/*
문제 2. 
employees 테이블에서 커미션이 없는 사원들중 남자직원들만 
부서번호, 사원명, 주민번호, 기본급여를 
부서번호로 오름차순 정렬후, 사원명의 오름차순으로 정렬하여 나타내세요.

-------------------------------------------------------
부서번호    사원명             주민번호        기본급여
-------------------------------------------------------
30	    Alexander Khoo	    6110151234567	3100
30	    Guy Himuro	        7810151234567	2600
30	    Karen Colmenares	7909151234567	2500
30	    Shelli Baida	    6009301234567	2900
50	    Adam Fripp	        7009151234567	8200
50	    Curtis Davies	    7510121234567	3100
50	    Douglas Grant	    7511171234567	2600
50	    Irene Mikkilineni	9406251234567	2700
50	    James Marlow	    0010153234567	2500
50	    Jean Fleaur	        6510191234567	3100
50	    Joshua Patel	    7310011234567	2500
50	    Kelly Chung	        9511151234567	3800
50	    Kevin Feeney	    9710181234567	3000
50	    Kevin Mourgos	    8110191234567	5800
50	    Ki Gee	            0503253234567	2400
50	    Laura Bissot	    8507251234567	3300
50	    Martha Sullivan	    6510221234567	2500
50	    Mozhe Atkinson	    6511111234567	2800
50	    Nandita Sarchand	8512131234567	4200
50	    Payam Kaufling	    7111011234567	7900
50	    Peter Vargas	    7710061234567	2500
50	    Renske Ladwig	    9510021234567	3600
50	    Samuel McCain	    0910183234567	3200
50	    Sarah Bell	        0510133234567	4000
50	    Shanta Vollman	    8010131234567	6500
50	    Stephen Stiles	    9610041234567	3200
50	    Timothy Gates	    8510161234567	2900
60	    Alexander Hunold	7510151234567	9000
60	    David Austin	    6510151234567	4800
60	    Diana Lorentz	    0803153234567	4200
60	    Valli Pataballa	    6009201234567	4800
70	    Hermann Baer	    7803251234567	10000
90	    Neena Kochhar	    8510151234567	17000
90	    Steven King	        6010151234567	24000
100	    Daniel Faviet	    8810151234567	9000
100	    Jose Manuel Urman	6610151234567	7800
100	    Luis Popp	        6710151234567	6900
*/
    
    select department_id AS 부서번호
         , first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
         , salary AS 기본급여
    from employees
    where commission_pct is null and substr(jubun,7,1)=1 or substr(jubun,7,1)=3
    order by 1, 2;
  
/*
문제 3. 
employees 테이블에서 부서번호 30,50,60,80,100 번 부서에 근무하지 않는 사원들만 
부서번호, 사원명, 월급을 
부서번호로 오름차순 정렬후, 월급의 내림차순으로 정렬하여 나타내세요.

---------------------------------------
부서번호     사원명             월급
---------------------------------------
10	     Jennifer Whalen	  4400
20	     Michael Hartstein	  13000
20	     Pat Fay	          6000
40	     Susan Mavris	      6500
70	     Hermann Baer	      10000
90	     Steven King	      24000
90	     Neena Kochhar	      17000
90	     Lex De Haan	      17000
110	     Shelley Higgins	  12008
110	     William Gietz	      8300
(null)	 Kimberely Grant	  8050
*/
  
    select department_id AS 부서번호
         , first_name || ' ' || last_name AS 사원명
         , nvl(salary + (salary*commission_pct), salary) AS 월급
    from employees
    where nvl(department_id, -9999) not in(30,50,60,80,100)
    order by 1, 3 desc;

/*
문제 4. 
employees 테이블에서 부서번호가 존재하는 사원들중 월급이 8000 이상 8999 이하인 사원들만 
부서번호, 사원명, 월급을 
부서번호로 오름차순 정렬후, 월급의 내림차순으로 정렬하여 나타내세요.

------------------------------------------
부서번호        사원명            월급
------------------------------------------
50	        Adam Fripp	        8200
50	        Matthew Weiss	    8000
80	        Sarath Sewall	    8750
80	        William Smith	    8510
80	        Elizabeth Bates	    8395
80	        Oliver Tuvault	    8050
100	        John Chen	        8200
110	        William Gietz	    8300
*/
    
    select department_id AS 부서번호
         , first_name || ' ' || last_name AS 사원명
         , nvl(salary + (salary*commission_pct), salary) AS 월급
    from employees
    where department_id is not null and
          8000 <= nvl(salary + (salary*commission_pct), salary) and
          nvl(salary + (salary*commission_pct), salary) <= 8999
    order by 1, 3 desc;

/*
문제 5. 
employees 테이블에서 3월과 9월에 태어난 남자 사원들만 
사원명, 주민번호를 
사원명의 오름차순으로 정렬하여 나타내세요.

----------------------------------
사원명               주민번호
----------------------------------
Adam Fripp	        7009151234567
Diana Lorentz	    0803153234567
Ellen Abel	        1209103234567
Hermann Baer	    7803251234567
Karen Colmenares    7909151234567
Ki Gee	            0503253234567
Shelli Baida	    6009301234567
Valli Pataballa	    6009201234567
*/
    
    select first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
    from employees
    where (substr(jubun,4,1)='3' or substr(jubun,4,1)='9') and
          (substr(jubun,7,1)='1' or substr(jubun,7,1)='3')
    order by 1;
  
/*
문제 6. 
employees 테이블에서 부서번호 30번, 50번에 근무하는 사원들만 
사원명, 주민번호, 성별을 나타내세요.
성별은 '남' 또는 '여'라고 나타낸다.

----------------------------------------------------
부서번호    사원명             주민번호        성별
----------------------------------------------------
30	    Den Raphaely        6709152234567	여
30	    Alexander Khoo      6110151234567	남
30	    Shelli Baida	    6009301234567	남
30	    Sigal Tobias	    6110152234568	여
30	    Guy Himuro	        7810151234567	남
30	    Karen Colmenares	7909151234567	남
50	    Matthew Weiss	    7702152234567	여
50	    Adam Fripp	        7009151234567	남
50	    Payam Kaufling	    7111011234567	남
50	    Shanta Vollman	    8010131234567	남
50	    Kevin Mourgos	    8110191234567	남
50	    Julia Nayer	        9012132234567	여
50	    Irene Mikkilineni	9406251234567	남
50	    James Landry	    9408252234567	여
50	    Steven Markle	    9204152234567	여
50	    Laura Bissot	    8507251234567	남
50	    Mozhe Atkinson	    6511111234567	남
50	    James Marlow	    0010153234567	남
50	    TJ Olson	        0005254234567	여
50	    Jason Mallin	    0110194234567	여
50	    Michael Rogers	    0412154234567	여
50	    Ki Gee	            0503253234567	남
50	    Hazel Philtanker	9510012234567	여
50	    Renske Ladwig	    9510021234567	남
50	    Stephen Stiles	    9610041234567	남
50	    John Seo	        9610052234567	여
50	    Joshua Patel	    7310011234567	남
50	    Trenna Rajs	        7310092234567	여
50	    Curtis Davies	    7510121234567	남
50	    Randall Matos	    7612012234567	여
50	    Peter Vargas	    7710061234567	남
50	    Winston Taylor	    8310012234567	여
50	    Jean Fleaur	        6510191234567	남
50	    Martha Sullivan	    6510221234567	남
50	    Girard Geoni	    6510232234567	여
50	    Nandita Sarchand	8512131234567	남
50	    Alexis Bull	        8510182234567	여
50	    Julia Dellinger	    7510192234567	여
50	    Anthony Cabrio	    8512192234567	여
50	    Kelly Chung	        9511151234567	남
50	    Jennifer Dilly	    7509302234567	여
50	    Timothy Gates	    8510161234567	남
50	    Randall Perkins	    9510192234567	여
50	    Sarah Bell	        0510133234567	남
50	    Britney Everett	    0810194234567	여
50	    Samuel McCain	    0910183234567	남
50	    Vance Jones	        1010134234567	여
50	    Alana Walsh	        9510032234567	여
50	    Kevin Feeney	    9710181234567	남
50	    Donald OConnell	    9810162234567	여
50	    Douglas Grant	    7511171234567	남

*/

    select department_id AS 부서번호
         , first_name || ' ' || last_name AS 사원명
         , jubun AS 주민번호
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS 성별
    from employees
    where department_id = 30 or department_id = 50

/*
문제 7. 
employees 테이블에서 부서번호 30번, 50번에 근무하는 사원들만 
사원명, 주민번호, 성별을 나타내세요.
성별은 '남' 또는 '여'라고 나타낸다. 그리고 주민번호는 생년월일만 기재해주고 나머지는 마스킹('*')처리해서 보여준다.

------------------------------------------------------------
부서번호        사원명             주민번호            성별
------------------------------------------------------------
30	        Den Raphaely	    670915*******	여
30	        Alexander Khoo	    611015*******	남
30	        Shelli Baida	    600930*******	남
30	        Sigal Tobias	    611015*******	여
30	        Guy Himuro	        781015*******	남
30	        Karen Colmenares    790915*******	남
50	        Matthew Weiss	    770215*******	여
50	        Adam Fripp	        700915*******	남
50	        Payam Kaufling	    711101*******	남
50	        Shanta Vollman	    801013*******	남
50	        Kevin Mourgos	    811019*******	남
50	        Julia Nayer	        901213*******	여
50	        Irene Mikkilineni   940625*******	남
50	        James Landry	    940825*******	여
50	        Steven Markle	    920415*******	여
50	        Laura Bissot	    850725*******	남
50	        Mozhe Atkinson	    651111*******	남
50	        James Marlow	    001015*******	남
50	        TJ Olson	        000525*******	여
50	        Jason Mallin	    011019*******	여
50	        Michael Rogers	    041215*******	여
50	        Ki Gee	            050325*******	남
50	        Hazel Philtanker    951001*******	여
50	        Renske Ladwig	    951002*******	남
50	        Stephen Stiles	    961004*******	남
50	        John Seo	        961005*******	여
50	        Joshua Patel	    731001*******	남
50	        Trenna Rajs	        731009*******	여
50	        Curtis Davies	    751012*******	남
50	        Randall Matos	    761201*******	여
50	        Peter Vargas	    771006*******	남
50	        Winston Taylor	    831001*******	여
50	        Jean Fleaur	        651019*******	남
50	        Martha Sullivan	    651022*******	남
50	        Girard Geoni	    651023*******	여
50	        Nandita Sarchand    851213*******	남
50	        Alexis Bull	        851018*******	여
50	        Julia Dellinger	    751019*******	여
50	        Anthony Cabrio	    851219*******	여
50	        Kelly Chung	        951115*******	남
50	        Jennifer Dilly	    750930*******	여
50	        Timothy Gates	    851016*******	남
50	        Randall Perkins	    951019*******	여
50	        Sarah Bell	        051013*******	남
50	        Britney Everett	    081019*******	여
50	        Samuel McCain	    091018*******	남
50	        Vance Jones	        101013*******	여
50	        Alana Walsh	        951003*******	여
50	        Kevin Feeney	    971018*******	남
50	        Donald OConnell	    981016*******	여
50	        Douglas Grant	    751117*******	남
*/

    select department_id AS 부서번호
         , first_name || ' ' || last_name AS 사원명
         , substr(jubun,1,6) || '*******' AS 주민번호
         -- rpad(substr(jubun,1,6), lentgh(jubun), '*') AS 주민번호
         , case substr(jubun,7,1) when '1' then '남' when '3' then '남' else '여' end AS 성별
    from employees
    where department_id = 30 or department_id = 50

/*
문제 8. 
employees 테이블에서 90번 부서에 근무하는 사원들만 아래와 같이
사원명, 공개연락처, 비공개연락처를 나타내세요.
여기서 비공개연락처란? 국번을 * 로 마스킹처리 한것을 말한다.

---------------------------------------------
사원명          공개연락처      비공개연락처
---------------------------------------------
Steven King	    515.123.4567	515.***.4567
Neena Kochhar	515.123.4568	515.***.4568
Lex De Haan	    515.123.4569	515.***.4569
*/

    -- 비공개연락처는 phone_number 컬럼에서 국번만 '*'로 변경한다.
    -- 국번만 발췌해야한다.
    -- 국번만 발췌 => phone_number 컬럼에서 최초로 . 이 나오는 위치 그 다음부터 두번째로 . 이 나오는 위치 그 앞까지만 발췌를 하면 된다.
    select first_name || ' ' || last_name AS 사원명
         , phone_number AS 공개연락처
         , substr(phone_number,1,instr(phone_number,'.',1)) || translate(substr(phone_number,instr(phone_number,'.',1)+1,3),'0123456789','**********') || substr(phone_number,instr(phone_number,'.',-1)) AS 비공개연락처
    from employees
    where department_id = 90;

/*
문제 9. 
employees 테이블에서 80번 부서에 근무하는 사원들만 아래와 같이
사원명, 공개연락처, 비공개연락처를 나타내세요.
여기서 비공개연락처란? 첫번째 국번과 마지막 개별번호를 * 로 마스킹처리 한것을 말한다.

---------------------------------------------------------------
사원명               공개연락처               비공개연락처
---------------------------------------------------------------
John Russell	    011.44.1344.429268	    011.**.1344.******
Karen Partners	    011.44.1344.467268	    011.**.1344.******
Alberto Errazuriz   011.44.1344.429278	    011.**.1344.******
Gerald Cambrault    011.44.1344.619268	    011.**.1344.******
Eleni Zlotkey	    011.44.1344.429018	    011.**.1344.******
Peter Tucker	    011.44.1344.129268	    011.**.1344.******
David Bernstein	    011.44.1344.345268	    011.**.1344.******
Peter Hall	        011.44.1344.478968	    011.**.1344.******
Christopher Olsen   011.44.1344.498718	    011.**.1344.******
Nanette Cambrault   011.44.1344.987668	    011.**.1344.******
Oliver Tuvault	    011.44.1344.486508	    011.**.1344.******
Janette King	    011.44.1345.429268	    011.**.1345.******
Patrick Sully	    011.44.1345.929268	    011.**.1345.******
Allan McEwen	    011.44.1345.829268	    011.**.1345.******
Lindsey Smith	    011.44.1345.729268	    011.**.1345.******
Louise Doran	    011.44.1345.629268	    011.**.1345.******
Sarath Sewall	    011.44.1345.529268	    011.**.1345.******
Clara Vishney	    011.44.1346.129268	    011.**.1346.******
Danielle Greene     011.44.1346.229268	    011.**.1346.******
Mattea Marvins	    011.44.1346.329268	    011.**.1346.******
David Lee	        011.44.1346.529268	    011.**.1346.******
Sundar Ande	        011.44.1346.629268	    011.**.1346.******
Amit Banda	        011.44.1346.729268	    011.**.1346.******
Lisa Ozer	        011.44.1343.929268	    011.**.1343.******
Harrison Bloom	    011.44.1343.829268	    011.**.1343.******
Tayler Fox	        011.44.1343.729268	    011.**.1343.******
William Smith	    011.44.1343.629268	    011.**.1343.******
Elizabeth Bates	    011.44.1343.529268	    011.**.1343.******
Sundita Kumar	    011.44.1343.329268	    011.**.1343.******
Ellen Abel	        011.44.1644.429267	    011.**.1644.******
Alyssa Hutton	    011.44.1644.429266	    011.**.1644.******
Jonathon Taylor	    011.44.1644.429265	    011.**.1644.******
Jack Livingston	    011.44.1644.429264	    011.**.1644.******
Charles Johnson	    011.44.1644.429262	    011.**.1644.******
*/  

    select first_name || ' ' || last_name AS 사원명
         , phone_number AS 공개연락처
         , substr(phone_number, 1, instr(phone_number,'.',1)) ||
           translate(substr(phone_number,instr(phone_number,'.',1)+1,2),'0123456789','**********') ||
           substr(phone_number,instr(phone_number,'.',1,2),instr(phone_number,'.',1,3)-instr(phone_number,'.',1,2)) ||
           translate(substr(phone_number,instr(phone_number,'.',-1)), '0123456789', '**********') AS 비공개연락처
    from employees
    where department_id = 80;
    
    /*
    select first_name || ' ' || last_name AS 사원명
     , phone_number AS 공개연락처
     , substr(phone_number,1,instr(phone_number,'.',1,1)) 
    || lpad('*',instr(phone_number,'.',1,2)-instr(phone_number,'.',1,1)-1,'*') 
    || substr(phone_number,instr(phone_number,'.',1,2), instr(phone_number,'.',1,3)-instr(phone_number,'.',1,2))
    || translate( substr(phone_number,instr(phone_number,'.',1,3)), '0123456789','**********')  AS 비공개연락처
from employees
where department_id = 80;
    */

/*
문제 10. (난이도 상)
employees 테이블에서 80번, 90번 부서에 근무하는 사원들만 아래와 같이
부서번호, 사원명, 공개연락처, 비공개연락처를 나타내세요.
여기서 비공개연락처란? 첫번째 국번과 마지막 개별번호를 * 로 마스킹처리 한것을 말한다.

------------------------------------------------------------------------------
부서번호        사원명              공개연락처               비공개연락처
------------------------------------------------------------------------------  
80	        John Russell	    011.44.1344.429268	    011.**.1344.******
80	        Karen Partners	    011.44.1344.467268	    011.**.1344.******
80	        Alberto Errazuriz   011.44.1344.429278	    011.**.1344.******
80	        Gerald Cambrault    011.44.1344.619268	    011.**.1344.******
80	        Eleni Zlotkey	    011.44.1344.429018	    011.**.1344.******
80	        Peter Tucker	    011.44.1344.129268	    011.**.1344.******
80	        David Bernstein	    011.44.1344.345268	    011.**.1344.******
80	        Peter Hall	        011.44.1344.478968	    011.**.1344.******
80	        Christopher Olsen   011.44.1344.498718	    011.**.1344.******
80	        Nanette Cambrault   011.44.1344.987668	    011.**.1344.******
80	        Oliver Tuvault	    011.44.1344.486508	    011.**.1344.******
80	        Janette King	    011.44.1345.429268	    011.**.1345.******
80	        Patrick Sully	    011.44.1345.929268	    011.**.1345.******
80	        Allan McEwen	    011.44.1345.829268	    011.**.1345.******
80	        Lindsey Smith	    011.44.1345.729268	    011.**.1345.******
80	        Louise Doran	    011.44.1345.629268	    011.**.1345.******
80	        Sarath Sewall	    011.44.1345.529268	    011.**.1345.******
80	        Clara Vishney	    011.44.1346.129268	    011.**.1346.******
80	        Danielle Greene	    011.44.1346.229268	    011.**.1346.******
80	        Mattea Marvins	    011.44.1346.329268	    011.**.1346.******
80	        David Lee	        011.44.1346.529268	    011.**.1346.******
80	        Sundar Ande	        011.44.1346.629268	    011.**.1346.******
80	        Amit Banda	        011.44.1346.729268	    011.**.1346.******
80	        Lisa Ozer	        011.44.1343.929268	    011.**.1343.******
80	        Harrison Bloom	    011.44.1343.829268	    011.**.1343.******
80	        Tayler Fox	        011.44.1343.729268	    011.**.1343.******
80	        William Smith	    011.44.1343.629268	    011.**.1343.******
80	        Elizabeth Bates	    011.44.1343.529268	    011.**.1343.******
80	        Sundita Kumar	    011.44.1343.329268	    011.**.1343.******
80	        Ellen Abel	        011.44.1644.429267	    011.**.1644.******
80	        Alyssa Hutton	    011.44.1644.429266	    011.**.1644.******
80	        Jonathon Taylor	    011.44.1644.429265	    011.**.1644.******
80	        Jack Livingston	    011.44.1644.429264	    011.**.1644.******
80	        Charles Johnson	    011.44.1644.429262	    011.**.1644.******
90	        Steven King	        515.123.4567	    515.***.****
90	        Neena Kochhar	    515.123.4568	    515.***.****
90	        Lex De Haan	        515.123.4569	    515.***.****
*/

    select department_id AS 부서번호
         , first_name || ' ' || last_name AS 사원명
         , phone_number AS 공개연락처
         , substr(phone_number, 1, instr(phone_number,'.',1,1)) 
        || lpad('*', instr(phone_number,'.',1,2)-instr(phone_number,'.',1,1)-1, '*')
        || case 
           when instr(phone_number,'.',1,3) > 0 
                then substr(phone_number, instr(phone_number,'.',1,2), instr(phone_number,'.',1,3)-instr(phone_number,'.',1,2))
           else ''
           end
        || translate(substr(phone_number, instr(phone_number,'.',-1,1)), '0123456789', '**********')
        AS 비공개연락처
    from employees
    where department_id in (80,90)
    order by department_id;
  
 -- ////////////////////////////////////////////////////////////////////////
 
    -- 5.3 rank 등수구하기, dense_rank 서열구하기
    
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         , rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) AS 월급등수 -- 공동 등수가 있으면 다음 등수 스킵
         , dense_rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) AS 월급서열 -- 스킵X
    from employees;
    
    
    select department_id AS 부서번호
         , employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         
         , rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) AS 월급전체등수
         , dense_rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) AS 월급전체서열
         
         , rank() over(partition by department_id order by nvl(salary + (salary*commission_pct), salary) desc) AS "부서내 월급등수"
         , dense_rank() over(partition by department_id order by nvl(salary + (salary*commission_pct), salary) desc) AS "부서내 월급서열"
    from employees
    order by 1;
    
    /*
        employees 테이블에서 월급에 대한 전체등수가 1등 부터 10등까지인 사원들만
        사원번호, 사원명, 월급, 등수를 나타내세요.
    */
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         , rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) AS 월급등수
    from employees;
    where rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) between 1 and 10;
    -- 오류!!!! rank() 와 dense_rank() 는 where 절에 사용불가하다.
    -- 해결책은 inline view 를 사용하면 된다(alias 를 where 절에 넣어준다).
    
    select *
    from
    (
    select employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , nvl(salary + (salary*commission_pct), salary) AS 월급
         , rank() over(order by nvl(salary + (salary*commission_pct), salary) desc) AS 월급등수
    from employees
    ) V
    where 월급등수 between 1 and 10;
    
    -- 5.4 lag, lead (게시판에서 특정글을 조회할때 많이 사용한다) --
    select *
    from tbl_board;
    
    select boardno, subject, content
    from tbl_board;
    /*
    ------------------------------------------------------------------------------------------
    앞글번호    앞글제목   현재글번호   현재글제목   현재글내용                 다음글번호   다음글제목
    ------------------------------------------------------------------------------------------
    null        null        1       	안녕하세요	글쓰기 연습입니다          2     반갑습니다
    1           안녕하세요   2	        반갑습니다	모두 취업대박 나십시오      3     건강하세요
    2           반갑습니다   3        	건강하세요	로또 1등을 기원합니다      4     기쁘고 감사함이 넘치는 좋은하루되세요
    ......
    5           오늘도 좋은하루되세요 6  	좋은 하루 되시고 건강하시고 부자되시고 늘 행복하세요	null    null
    */
    
    select lag(boardno, 1) over(order by boardno asc)
         , boardno, subject, content
         , lead(boardno, 1) over(order by boardno asc)
    from tbl_board;
    
    select lag(boardno, 1) over(order by boardno desc) -- 이전 글번호(lag(값을 가져올 컬럼명, 1 앞의 행) over(정렬 기준))
         , lag(subject) over(order by boardno desc) -- 이전 글제목, (, 1) 은 생략할 수 있다.
         , boardno, subject, content
         , lead(boardno, 1) over(order by boardno desc) -- 다음 글번호(lead(값을 가져올 컬럼명, 1 뒤의 행) over(정렬 기준))
         , lead(subject) over(order by boardno desc) -- 다음 글제목, (, 1) 은 생략할 수 있다.
    from tbl_board;
    
    /*
        4번글 클릭 시 다음과 같이 나오도록 해보세요.
          ------------------------------------------------------------------------------------------
         앞글번호    앞글제목   현재글번호   현재글제목   현재글내용                 다음글번호   다음글제목
            ------------------------------------------------------------------------------------------
        5	오늘도 좋은하루되세요	4	기쁘고 감사함이 넘치는 좋은하루되세요 	늘 행복하세요	3	건강하세요
    */
    select *
    from
    (
    select lag(boardno, 1) over(order by boardno desc) AS prevboardno
         , lag(subject) over(order by boardno desc) AS prevsubject
         , boardno, subject, content
         , lead(boardno, 1) over(order by boardno desc) AS nextboardno
         , lead(subject) over(order by boardno desc) AS nextsubject
    from tbl_board
    ) V
    where boardno = 4;
    
    -- 5.5 greatest , least : 나열된 값에서 제일 큰 , 작은 값을 뽑아오는 것
    select greatest(10, 90, 100, 80)
         , least(10, 90, 100, 80)
    from dual;
    
    select greatest('김유신', '윤봉길', '허준', '고수')
         , least('김유신', '윤봉길', '허준', '고수')
    from dual;
    
    --===============================================================================================================--
    
    -- ***** >>>> 그룹함수(집계함수) <<<< ***** --
    
    /*
        1. sum      -- 합계
        2. avg      -- 평균
        3. max      -- 최대값
        4. min      -- 최소값
        5. count    -- select 되어서 나온 결과물의 행의 갯수
        6. variance -- 분산
        7. stddev   -- 표준편차
        
        분산    : 표준편차의 제곱승 (평균에서 떨어진 정도)
        표준편차 : 분산의 제곱근 (평균과의 차액)
        
        >>> 주식투자 <<<
        평균 50 편차가 적음 -- 안정투자
        평균 50 편차가 큼   -- 투기성투자(위험을 안고서 투자)
        
        분산과 표준편차는 어떤 의사결정시 도움이 되는 지표이다.
    */
    
    --- !!!! 중요중요중요중요중요 그룹함수(집계함수)에서는 null 이 있으면 무조건 null 은 제외시킨 후 연산을 한다!!!!
    --- 그룹함수(집계함수)를 사용하면 말 그대로 1개의 결과값만 나온다.
    select salary, max(salary) -- 오류(결과의 갯수가 다르기 때문에 함께 쓸 수 없다)
    from employees;
    
    select sum(nvl(salary*commission_pct, 0))
         , sum(salary*commission_pct) -- null 값이 있으면 제외하고 연산한다
    from employees;
    
    select salary, commission_pct, department_id
    from employees;
    
    select count(salary), count(commission_pct), count(department_id)
    from employees;
    --      107             35                      106 / null 값을 제외한 갯수
    
    select sum(salary), avg(salary), max(salary), min(salary), count(salary)
         , variance(salary), stddev(salary)
    from employees;
    
    select count(*)
    from employees; -- 테이블 행의 수 ==> 모든 컬럼 값이 null 인 행은 없기 때문에 테이블 전체로 지정하면 테이블 행의 갯수가 반환된다.
    
    --- employees 테이블에서 기본급여(salary)의 평균치를 구하세요.
    select sum(salary), count(salary)
         , sum(salary)/count(salary)
         , avg(salary)
    from employees;
    
    --- employees 테이블에서 수당(salary * commission_pct)의 평균치를 구하세요.
    select sum(salary * commission_pct), count(salary * commission_pct)
         , sum(salary * commission_pct)/count(salary * commission_pct)
         , avg(salary * commission_pct)
    from employees;
    -- null 제외이므로 이 평균은 수당을 받는 사원들만을 평균 계산한 것이다.
    
    select avg(salary * commission_pct)
         , sum(salary * commission_pct)/count(salary * commission_pct) -- 수당을 받는 사원들만 평균
         
         , avg(nvl(salary * commission_pct, 0))
         , sum(salary * commission_pct)/count(*) -- 전체 평균
    from employees;
    
    -- null , 0 을 구분하자! (null, 1, 3, 5) (0, 1, 3, 5) => 최소값 : 1 != 0, 주의하자!
    
    --- **** employees 테이블에서 부서번호별 인원수를 나타내세요 **** ---
    select department_id AS 부서번호
         , count(*) AS 인원수 -- 각 부서에 몇명이 있는지
    from employees
    group by department_id
    order by 1;
    
    --- **** employees 테이블에서 부서번호별 인원수를 나타내세요.
    --       또한 모든 사원들의 총인원수도 나타내세요 **** ---
    select department_id AS 부서번호
         , count(*) AS 인원수
    from employees
    group by rollup(department_id); -- 실제 부서번호가 null 이거나 부서번호 그룹화하지 않은 null
    
    select grouping(department_id) -- department_id 컬럼의 값을 가지고 group을 지었을때 grouping(department_id) 값이 0 이라면 해당 department_id 컬럼은 실제 데이터값임을 알려주는 것이고, grouping(department_id) 값이 1 이라면 해당 department_id 컬럼은 실제 데이터가 아니라 group을 짓지 않은 전체라는 뜻이다.
         , department_id AS 부서번호
         , count(*) AS 인원수
    from employees
    group by rollup(department_id);
    
    select decode(grouping(department_id), 0, to_char(department_id), '전체') AS 부서번호
         , count(*) AS 인원수
    from employees
    group by rollup(department_id);
    
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , count(*) AS 인원수
    from employees
    group by rollup(department_id);
    
    
    /*
        employees 테이블
        -----------
        성별  인원수
        -----------
        남   56
        여   51
        전체  107 -- 추가
    */
    -- 1
    select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS 성별
         , count(*) AS 인원수
    from employees
    group by case when substr(jubun,7,1) in('1','3') then '남' else '여' end
    order by 1;
    -- 2
    select gender AS 성별
         , sum(genderno) AS 인원수
    from
    (
    select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS gender
         , count(*) AS genderno
    from employees
    group by substr(jubun,7,1)
    order by 1
    ) V
    group by gender
    order by 1;
    -- 전체 추가
    select decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
    from
    (
    select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS gender
    from employees
    ) V
    group by rollup(gender)
    
    --- **** employees 테이블에서 성별 인원수 퍼센티지를 나타내세요 **** ---
        ---------------------
        성별  인원수 퍼센티지(%)(소수점 한자리까지)
        ---------------------
        남   56      52.3
        여   51      47.7
        전체 -- 추가
        
    select gender AS 성별
         , count(*) AS 인원수
         , round(count(*)/(select count(*) from employees) * 100, 1) AS "퍼센티지(%)" -- 전체 인원 수는 employees 테이블의 행의 갯수이기 때문에 select문을 이용하여 구한다.
    from
    (
    select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS gender
    from employees -- 처음부터 그룹화하지 않고 주민번호를 이용해 성별 칼럼을 만들어 해당 뷰를 이용해 인원 수와 퍼센티지를 구한다.
    ) V
    group by gender
    order by 1;
    -- 전체 추가
    select decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*)/(select count(*) from employees) * 100, 1) AS "퍼센티지(%)" -- 전체 인원 수는 employees 테이블의 행의 갯수이기 때문에 select문을 이용하여 구한다.
    from
    (
    select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS gender
    from employees -- 처음부터 그룹화하지 않고 주민번호를 이용해 성별 칼럼을 만들어 해당 뷰를 이용해 인원 수와 퍼센티지를 구한다.
    ) V
    group by rollup(gender)
    
    ----------------------------------------------------------------------------------------------------------------
    -- employees 테이블에서 부서번호별 기본급여의 합계를 나타내세요.
    -- 또한 모든 부서에 대한 기본급여의 총합계도 나타내세요.
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , sum(salary) AS 기본급여합계
    from employees
    group by rollup(department_id);
    
    -- employees 테이블에서 부서번호별 기본급여의 평균을 나타내세요.
    select department_id AS 부서번호, trunc(avg(salary)) AS 기본급여평균
    from employees
    group by department_id
    order by department_id;
    
    -- employees 테이블에서 부서번호별 기본급여의 최대값을 나타내세요.
    select department_id AS 부서번호, max(salary) AS 기본급여최대값
    from employees
    group by department_id
    order by department_id;
    
    -- employees 테이블에서 부서번호별 기본급여의 최소값을 나타내세요.
    select department_id AS 부서번호, min(salary) AS 기본급여최대값
    from employees
    group by department_id
    order by department_id;
    
    -- [퀴즈] employees 테이블에서 연령대별로 인원수와 퍼센티지(%)를 나타내뇌
    --        전체사원수도 나오도록 하세요...
    
    -------------------------------
    연령대     인원수     퍼센티지(%)
    -------------------------------
    0
    10
    ...       ...       ...
    전체       107       100
    
    select decode(grouping(age_group), 0, to_char(age_group), '전체') AS 연령대
         , count(*) AS 인원수
         , round((count(*) / (select count(*) from employees) * 100), 1) AS "퍼센티지(%)"
    from
    (
    select trunc((extract(year from sysdate) - (substr(jubun,1,2) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1), -1) AS age_group
    from employees
    ) V
    group by rollup(age_group);
    
    ---- **** inline view 를 with 절을 사용하여 나타낼수 있다. **** ----
    --- employees 테이블에서 성별, 인원수를 나타내세요. ---
    /*
        employees 테이블
        -----------
        성별  인원수
        -----------
        남   56
        여   51
    */
    
    with V as (
        select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) -- inline view
    
    select gender AS 성별
         , count(*) AS 인원수
    from V
    group by gender
    order by 2 desc; -- 같이 묶어서 실행
    
    /*
        -----------
        성별  인원수
        -----------
        남   56
        여   51
        전체  107
    */
    
    with V as (
        select case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    )
    
    select decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
    from V
    group by rollup(gender)
    
    -------------------------------
    연령대     인원수     퍼센티지(%)
    -------------------------------
    0
    10
    ...       ...       ...
    전체       107       100
    
    with V as(
        select trunc((extract(year from sysdate) - (to_number(substr(jubun,1,2)) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1), -1) AS age_group
        from employees
    )
    
    select decode(grouping(age_group), 0, to_char(age_group), '전체') AS 연령대
         , count(*) AS 인원수
         , round((count(*) / (select count(*) from employees) * 100), 1) AS "퍼센티지(%)"
    from V
    group by rollup(age_group);
    
    
    --- *** 그룹을 지을때 1차로 그룹을 지은 다음에 거기서 다시한번 2차로 또 그룹을 지을수 있다. *** ---
    ----------------------
    부서번호    성별  인원수
    ----------------------
        10      남
        10      여
        20      남
        20      여
        30      남
        30      여
        ......
        전체      남   56
        전체      여   51
        전체      전체 107
        
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
    from
    (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) V
    group by rollup(department_id, gender); -- 1차 그룹: 부서번호, 2차 그룹: 성별
    
    
    with V as (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    )
    
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
    from V
    group by rollup(department_id, gender);
    
    -------------------------------------
    부서번호    성별  인원수     퍼센티지(%)
    -------------------------------------
        10      남
        10      여
        20      남
        20      여
        30      남
        30      여
        ......
        전체      남   56
        전체      여   51
        전체      전체 107      100
        
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from
    (
    select department_id
         , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
    from employees
    ) V
    group by rollup(department_id, gender);
    
    with V as(
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    )
    
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from V
    group by rollup(department_id, gender);
    
    
    ----- >>>>> 요약값(rollup, cube, grouping sets) <<<<< ------
  /*
      1. rollup(a,b,c) == grouping sets( (a,b,c),(a,b),(a),() ) 
    
            group by rollup(department_id, gender)
         == group by grouping sets( (department_id, gender), (department_id), () )
  
      2. cube(a,b,c) == grouping sets( (a,b,c),(a,b),(b,c),(a,c),(a),(b),(c),() ) -- 모든 경우의 수, 3개 그룹 -> 모든 2개 경우의 그룹 -> 모든 1개 경우의 그룹 -> 그룹 짓지 않는 전체
 
            group by cube(department_id, gender)
         == group by grouping sets( (department_id, gender), (department_id), (gender), () )
  */
  
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from
    (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) V
    group by rollup(department_id, gender);
    
    --- 또는
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from
    (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) V
    group by grouping sets((department_id, gender), (department_id), ());  -- 1. 동일 부서 내에서 성별끼리 그룹 2. 부서번호끼리 그룹 3. 그룹짓지 않은 전체 ==> roll up 의 방식(그룹이란 같은 데이터값을 같는 것끼리 묶는 것임을 생각)
    
    
    --- *** cube *** ---
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from
    (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) V
    group by cube(department_id, gender)
    order by 1,2;
    
    --- 또는
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from
    (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) V
    group by grouping sets((department_id, gender), (department_id), (gender), ());
    
    
    --- grouping sets --- 원하는 것만 그룹지을 수 있다
    select decode(grouping(department_id), 0, nvl(to_char(department_id), '인턴'), '전체') AS 부서번호
         , decode(grouping(gender), 0, gender, '전체') AS 성별
         , count(*) AS 인원수
         , round(count(*) / (select count(*) from employees) * 100, 1) AS "퍼센티지(%)"
    from
    (
        select department_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
        from employees
    ) V
    group by grouping sets((department_id), (gender), ());
    
    
    ---- *** having 그룹함수 조건절 *** ----
    --- group by 절을 사용하여 그룹함수의 값을 나타내었을 때 그룹함수의 값이 특정 조건에 해당하는 것만 추출하고자 할때는
    --- where 절을 사용하는 것이 아니라 having 그룹함수 조건절을 사용해야 한다.
    
    -- employees 테이블에서 10명 이상 근무하는 부서번호와 그 인원수를 나타내세요.
    select department_id, count(*)
    from employees
    where count(*) >= 10
    group by department_id; -- 오류(어떤 그룹의 결과 개수인지 문장 구조 순서상 알 수 없기 때문에)
    
    select department_id AS 부서번호
         , count(*) AS 인원수
    from employees
    group by department_id
    having count(*) >= 10 -- 그룹함수(count)는 그룹이 지어진 다음에 쓸 수 있다
    order by 2;
    
    -- employees 테이블에서 부서번호별로 월급의 합계를 나타내었을 때
    -- 부서번호별 월급의 합계가 50000 이상인 부서에 대해서만
    -- 부서번호, 월급의 합계를 나타내세요.
    select department_id AS 부서번호, sum(mon_salary) AS "월급의 합계"
    from
    (
    select department_id, nvl(salary + (salary*commission_pct), salary) AS mon_salary
    from employees
    ) V
    group by department_id
    having sum(mon_salary) >= 50000;
    

             ---- *** !!!! 누적에 대해서 알아봅니다. !!!! *** ----
 /*
   --  sum(누적되어야할 컬럼명) over(order by 누적되어질 기준이 되는 컬럼명 asc[desc]) -- 정렬 기준에 따라 누적합계가 달라진다.
    
   --  sum(누적되어야할 컬럼명) over(partition by 그룹화 되어질 컬럼명 
                                  order by 누적되어질 기준이 되는 컬럼명 asc[desc])  
 */
            
 create table tbl_panmae
 (panmaedate  date
 ,jepumname   varchar2(20)
 ,panmaesu    number
 );

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-2), '새우깡', 10);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-2)+1, '새우깡', 15); 

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-2)+2, '감자깡', 20);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-2)+3, '새우깡', 10);
 
 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-2)+3, '새우깡', 3);
 
 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-1), '고구마깡', 7);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-1)+1, '새우깡', 8); 

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-1)+2, '감자깡', 10);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( add_months(sysdate,-1)+3, '감자깡', 5);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate - 4, '허니버터칩', 30);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate - 3, '고구마깡', 15);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate - 2, '고구마깡', 10);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate - 1, '허니버터칩', 20);


 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '새우깡', 10);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '새우깡', 10);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '감자깡', 5);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '허니버터칩', 15);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '고구마깡', 20);

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '감자깡', 10); 

 insert into tbl_panmae(panmaedate, jepumname, panmaesu)
 values( sysdate, '새우깡', 10);

 commit;
 
 select *
 from tbl_panmae;
 
    select to_char(panmaedate, 'yyyy-mm-dd hh24:mi:ss') AS panmaedate, panmaesu
    from tbl_panmae
    where jepumname = '새우깡';
    
    ---------------------------------------
    판매일자        일별판매량   일별누적판매량
    ---------------------------------------
    2020-06-18      10          10
    2020-06-19      15          25
    2020-06-21      13          38
    2020-07-19      8           46
    2020-08-18      30          76
    
    select to_char(panmaedate, 'yyyy-mm-dd') AS 판매일자
         , sum(panmaesu) AS 일별판매량
         , sum(sum(panmaesu)) over(order by to_char(panmaedate, 'yyyy-mm-dd') asc) AS 일별누적판매량 -- 개별 판매량이 아닌 그룹화된 일별 판매량이 누적되어야 하므로 sum(sum(panmaesu))
    from tbl_panmae
    where jepumname = '새우깡'
    group by to_char(panmaedate, 'yyyy-mm-dd');
    
    --- *** tbl_panmae 테이블에서 모든 제품에 대한 일별판매량과 일별누적판매량을 나타내세요 *** ---
    -------------------------------------------------
    제품명     판매일자        일별판매량   일별누적판매량
    -------------------------------------------------
    
    select jepumname AS 제품명
         , to_char(panmaedate, 'yyyy-mm-dd') AS 판매일자
         , sum(panmaesu) AS 일별판매량
      -- , sum(sum(panmaesu)) over (order by jepumname asc, to_char(panmaedate, 'yyyy-mm-dd') asc) AS 일별누적판매량 -- 이는 정렬은 하되 제품별로 누적을 끊지 않고 전체 누적을 한다.
         , sum(sum(panmaesu)) over (partition by jepumname order by to_char(panmaedate, 'yyyy-mm-dd') asc) AS 일별누적판매량 -- 이는 제품별 전체 누적이 아닌 제품별 누적으로 파티션을 나눈다.
    from tbl_panmae
    group by jepumname, to_char(panmaedate, 'yyyy-mm-dd');
    
    
  ---------------------------------------------------------------------------------
  
  ---- *** 아래처럼 나오도록 하세요 *** ----
  
  --------------------------------------------------------------
  전체사원수     10대미만   10대   20대  30대  40대  50대  60대
  --------------------------------------------------------------
    107	            2     14	21	  19	21	  18	12
  
  --- 오라클 11g 이전에는 아래와 같이 구했다. 
  select count(*) as "전체사원수"
       , sum( decode(V.AGELINE, 0, 1) )  as "10대미만"
       , sum( decode(V.AGELINE, 10, 1) ) as "10대"
       , sum( decode(V.AGELINE, 20, 1) ) as "20대"
       , sum( decode(V.AGELINE, 30, 1) ) as "30대"
       , sum( decode(V.AGELINE, 40, 1) ) as "40대"
       , sum( decode(V.AGELINE, 50, 1) ) as "50대"
       , sum( decode(V.AGELINE, 60, 1) ) as "60대"
   from 
   (
     select trunc( extract(year from sysdate) - (to_number(substr(jubun, 1, 2)) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 , -1) as AGELINE 
     from employees
   ) V;
  
  -- **** PIVOT ==> Oracle 11g부터 제공하는 것으로써, 행을 열로 변환하고자 할 때 사용하는 방법으로서 기존의 GROUP BY 와 집계함수(MAX, SUM 등), DECODE 나 CASE 를 사용하는 방법 대신 좀 더 간결하게 해준다.
   --      1. PIVOT 절은 그룹함수가 적용될 컬럼을 정의하는 것으로서 마치 GROUP BY가 들어간 쿼리에서 SELECT SUM(SALARY), AVG(SALARY), COUNT(SALARY) 구절과 같다.
   --      2. PIVOT FOR 절은 피봇의 기준의 되는 컬럼을 정의하는 것으로서 마치 GROUP BY 절에 뒤따르는 컬럼과 같은 역할로 이해하면 된다.
   --         SELECT 절의 SUM(SALARY), AVG(SALARY), COUNT(SALARY) 가 PIVOT 절의 역할이라면, GROUP BY DEPARTMENT_ID 는 PIVOT FOR의 역할이다.
   --      3. PIVOT IN 절은 PIVOT FOR 절에서 정의한 컬럼에서 필터링을 정의하는 것으로서 마치 SQL 중 WHERE DEPARTMENT_ID IN(10, 20)은 PIVOT IN 절의 역할이다.
   --         또한 PIVOT IN 절은 Subquery 는 포함 할 수 없으나 Alias 정의는 가능하다.

    --------------------------------------------
    10대미만   10대   20대  30대  40대  50대  60대
    --------------------------------------------
        2	  14	 21    19	 21   18    12
   
   with V as (
     select trunc( extract(year from sysdate) - (to_number(substr(jubun, 1, 2)) + case when substr(jubun,7,1) in('1','2') then 1900 else 2000 end) + 1 , -1) as AGELINE 
     from employees
   )
-- select "10대미만", "20대"
   select * -- *은 PIVOT IN에서 정의한 그룹 전체를 컬럼
   from V
   PIVOT(COUNT(AGELINE)  -- 그룹함수
         FOR AGELINE -- FOR 그룹
         IN(0 AS "10대미만", 10 AS "10대", 20 AS "20대", 30 AS "30대", 40 AS "40대", 50 AS "50대", 60 AS "60대"));  -- 보여줄(메모리에 올릴) 그룹 나열
         
         
  ----------------------------------------------------------------------------------
  select department_id AS 부서번호
       , count(*) AS 인원수 
  from employees
  where department_id in (30,60)
  group by department_id;
  
  -------------------------------------------------------
  
  ----------------------------
    부서번호30      부서번호60
  ----------------------------
       6              5
  
  select department_id
       , case department_id when 30 then 1 end
       , case department_id when 60 then 1 end
  from employees
  where department_id in (30,60);
  
  --- 오라클 11g 이전에는 아래와 같이 구했다. 
  select sum(case department_id when 30 then 1 end) AS 부서번호30
       , sum(case department_id when 60 then 1 end) AS 부서번호60
  from employees
  where department_id in (30,60);
  
  -- 오라클 11g 에서는 아래와 같이 pivot 을 사용하여 나타낼수 있다.
  with V as (select department_id 
             from employees
             where department_id in (30,60))
  select 부서번호30, 부서번호60           
  from V
  pivot( count(department_id)
         for department_id
         in(30 as 부서번호30, 60 as 부서번호60) );
         
         
    ----- **** PIVOT 예제) 아래처럼 나오도록 하세요 **** -----
    
    -------------------------------------------------------
     직종ID       남자평균급여      여자평균급여      평균급여
    -------------------------------------------------------

    -- PIVOT 을 사용하지 않는 방법 --
    select job_id AS 직종ID
         , nvl(to_char(round(avg(decode(gender, '남', salary))), '999,999'), ' ') AS 남자평균급여 -- 여성일 경우 null 값이므로 평균 계산 시 제외된다, ''은 null, ' '이 공백
         , nvl(to_char(round(avg(decode(gender, '여', salary))), '999,999'), ' ') AS 여자평균급여
         , to_char(round(avg(salary)), '999,999') AS 평균급여
    from
    (
        select job_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
             , salary
        from employees
    ) V
    group by job_id;
    
    -- === [과제] NULL 을 공백으로 처리하세요 ===
    select job_id AS 직종ID
         , nvl(to_char(round(avg(decode(gender, '남', salary))), '99,999'), ' ') AS 남자평균급여 -- 공백은 문자이므로 통일 위해 형변환 필요, ''은 null, ' '이 공백
         , nvl(to_char(round(avg(decode(gender, '여', salary))), '99,999'), ' ') AS 여자평균급여
         , to_char(round(avg(salary)), '99,999') AS 평균급여
    from
    (
        select job_id
             , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
             , salary
        from employees
    ) V
    group by job_id;
    
    -- PIVOT 을 사용하여 구하는 방법 --
    with V as (select job_id
                    , case when substr(jubun,7,1) in('1','3') then '남' else '여' end AS GENDER
                    , salary
               from employees)
    
    select job_id AS 직종ID, trunc(남자평균급여) AS 남자평균급여, trunc(여자평균급여) AS 여자평균급여
    from V
    pivot(avg(salary) -- 아래의(for gender) 남 및 여 열에 보여질 데이터 값을 정의한다.
          for gender  -- 남, 여로 보여지는 행을 남, 여 열로 바꾸려고 한다.
          in('남' AS 남자평균급여, '여' AS 여자평균급여)) -- 열로 보여줄 데이터를 필터링한다.
          
    --- *** UNPIVOT ==> 열을 행으로 변경하고자 할 때 사용하는 것으로서,
    --                  열을 행으로 변경하고자 하는 컬럼명과 데이터 영역을 선정해야 한다.
    
    select first_name || ' ' || last_name AS ENAME
         , SALARY
         , (salary * commission_pct) AS COMM
    from employees;
    
    with V as (select first_name || ' ' || last_name AS ENAME
                    , SALARY
                    , (salary * commission_pct) AS COMM
               from employees)
    select ename, colname, datavalue           
    from V
    unpivot(DATAVALUE           -- 데이터 영역의 컬럼명을 지정해주는 것
            for COLNAME         -- 열 영역의 컬럼명을 지정해주는 것
            in(salary, comm));  -- 데이터 영역으로 들어올 컬럼명르 지정해주는 것, NULL 은 표현되지 않음.
            

    ------ !!! 중요 JOIN 은 면접에 가면 무조건 물어봅니다. !!! ------
            ------ ==== **** JOIN **** ==== ------
/*
    JOIN(조인)은 테이블(뷰)과 테이블(뷰)을 합치는 것을 말하는데
    행(ROW)과 행(ROW)을 합치는 것이 아니라, 컬럼(COLUMN)과 컬럼(COLUMN)을 합치는 것을 말한다.
    위에서 말한 행(ROW)과 행(ROW)을 합치는 것은 UNION 연산자를 사용하는 것이다.
    
    Q. INNER JOIN 과 OUTER JOIN 의 차이점에 대해서 말해보세요.
    Q. JOIN 과 UNION의 차이점에 대해서 말해보세요.
    
    A = {1, 2, 3} 원소가 3개
    B = {a, b}    원소가 2개
    
    A ⊙ B = { (1,a), (1,b)
               (2,a), (2,b)
               (3,a), (3,b) } -- 집합 A와 B의 원소 조합의 모든 경우의 수
    데카르트(수학) ==> 원소의 곱 : 3*2 = 6개(모든 경우의 수)
    --> 수학에서 말하는 데카르트곱을 데이터베이스에서는 Catersian Product 라고 부른다.
    
    JOIN => 1. SQL 1992 CODE 방식 --> 테이블(뷰)과 테이블(뷰) 사이에 콤마(,)를 찍어주는 것.
                                     데이터베이스 밴더(회사) 제품마다 문법이 조금씩 다르다.
         => 2. SQL 1999 CODE 방식(ANSI, 표준) --> 테이블(뷰)과 테이블(뷰) 사이에 JOIN 이라는 명령어를 넣어주는 것.
                                                 ANSI(표준화) SQL
*/

    select *
    from employees;
    
    select count(*)
    from employees; -- 107개 행
    
    select *
    from departments;
    
    select count(*)
    from departments; -- 27개 행
    
    select *
    from employees , departments; --> SQL 1992 CODE 방식
    
    select count(*)
    from employee*s , departments; --> SQL 1992 CODE 방식
                                   -- 2889개 행
                                   
    select 107*27 -- 2889 ==> 모든 경우의 수, 모든 직원이 10번 부서부터 마지막 부서까지의 경우의 수 모두 적용
    from dual;
    
    select *
    from employees cross join departments; --> SQL 1999 CODE 방식, Catersian Product
    
    select count(*)
    from employee*s cross join departments; --> SQL 1999 CODE 방식
                                   -- 2889개 행
                                   
    -- cross join 은 프로야구를 예를 들면 10개팀이 있는데
    -- 각 팀당 경기를 몇번해야 하는지 구할 때 쓰인다. 1팀당 모든 팀과 경기를 펼쳐야 한다.
    -- cross join 은 그룹함수로 나온 1개의 행을 가지고 어떤 데이터 값을 얻으려고 할때 사용한다.
    
    -- 사원번호  사원명  부서번호  기본급여  전체사원의평균급여  평균급여와의차액
    -- 위와 같이 나오도록 구하세요.
    select trunc(avg(salary)) AS AVGSAL
    from employees; -- 6461, 1개 행
    
    select employee_id, first_name || ' ' || last_name, department_id, salary
    from employees; -- 이 테이블 옆에 평균급여 컬럼을 찍어줘야 한다, 하지만 행 갯수가 다르므로 그냥 결합X, 107개 행
    
    -- 107 * 1 ==> 107
    -- 콤마
    select employee_id AS 사원번호, ename AS 사원명, department_id AS 부서번호, salary AS 기본급여, avgsal AS 전체사원의평균급여, salary - avgsal AS 평균급여와의차액
    from
    (
    select employee_id, first_name || ' ' || last_name AS ENAME, department_id, salary
    from employees
    ) A
    ,
    (
    select trunc(avg(salary)) AS AVGSAL
    from employees
    ) B;
    
    -- cross join
    select employee_id AS 사원번호, ename AS 사원명, department_id AS 부서번호, salary AS 기본급여, avgsal AS 전체사원의평균급여, salary - avgsal AS 평균급여와의차액
    from
    (
    select employee_id, first_name || ' ' || last_name AS ENAME, department_id, salary
    from employees
    ) A
    cross join
    (
    select trunc(avg(salary)) AS AVGSAL
    from employees
    ) B;
    
    
    ---- **** EQUI JOIN **** ----
    -- 부서번호  부서명  사원번호  사원명  기본급여
    -- 위와 같이 나오도록 하세요
    
    /*
        부서번호        부서명         사원번호  사원명  기본급여
        -------        -----         -----------------------
        departments    departments          employees
        employees
    */
    
    select *
    from employees , departments
    where employees.department_id = departments.department_id -- 조인조건절: 두 테이블을 합칠 때 기준이 되는 조건
    order by employees.employee_id asc;
    
    select *
    from employees E , departments D -- 별칭
    where E.department_id = D.department_id
    order by E.employee_id asc;
    
    select *
    from employees E , departments D
    where employees.department_id = departments.department_id -- 별칭 부여 시 원래 테이블명은 사용할 수 없다 => 오류!!
    order by E.employee_id asc;
    
    select department_id AS 부서번호 -- 두 테이블 모두에 속해 있다. 
         , department_name AS 부서명 -- 부서 테이블에만 있다, 중복된 컬럼이 아닐 경우는 상관X
         , employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E , departments D
    where E.department_id = D.department_id
    order by E.employee_id asc;
    -- column ambiguously defined(애매한 컬럼 정의)
    
    select E.department_id AS 부서번호 -- 중복된 컬럼은 반드시 테이블 하나를 지정해주어야 한다.
         , department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E , departments D
    where E.department_id = D.department_id
--  order by employee_id asc; -- 사원 테이블에만 있으므로 E. 생략 가능
    order by D.department_id asc, employee_id; -- 1992 CODE 방식
    -- 부서번호가 없는 Kimberely는 빠져 있다.
    
    -- employees 테이블에서 사원들이 실제 근무하고 있는 부서번호를 나타내세요
    select distinct department_id
    from employees;
    -- select 바로 다음에 distinct 를 사용하면 select 되어진 행 중에 중복된 행 값이 있으면
    -- 중복을 제거해주고 한번만 보여주게끔 해주는 것이다.
    
    select *
    from departments; -- 부서번호가 10~110 120~270
    
    select E.department_id AS 부서번호
         , department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E , departments D
    where E.department_id(+) = D.department_id  -- (+)가 없는 쪽 테이블의 모든 행들을 출력해준 다음에 조인조건절로 매핑시킨다.
    order by D.department_id asc, employee_id;
    
    select E.department_id AS 부서번호
         , department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E , departments D
    where E.department_id = D.department_id(+)
    order by D.department_id asc, employee_id;
    
    -- 1999 CODE 방식
    ---- *** INNER JOIN(내부조인) *** ----
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E inner join departments D
    on E.department_id = D.department_id  -- 조인조건절
    order by D.department_id asc, employee_id;
    
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E join departments D  -- **** inner 는 생략이 가능 ****
    on E.department_id = D.department_id
    order by D.department_id asc, employee_id;
    
    
    ---- *** OUTER JOIN(외부조인) *** ----
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E left outer join departments D  -- LEFT는 명령어를 기준으로 왼쪽 테이블에 있는 모든 행들을 출력해준 다음 조인조건절로 매핑시킨다.
    on E.department_id = D.department_id
    order by D.department_id, employee_id;
    
    -- OUTER 는 생략가능하다.
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E left join departments D
    on E.department_id = D.department_id
    order by D.department_id, employee_id;
    
    
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E right outer join departments D  -- RIGHT는 명령어를 기준으로 오른쪽 테이블에 있는 모든 행들을 출력해준 다음 조인조건절로 매핑시킨다.
    on E.department_id = D.department_id
    order by D.department_id, employee_id;
    
    -- OUTER 는 생략가능하다.
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E right join departments D
    on E.department_id = D.department_id
    order by D.department_id, employee_id;
    
    
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E full outer join departments D  -- FULL은 명령어를 기준으로 양쪽 테이블에 있는 모든 행들을 출력해준 다음 조인조건절로 매핑시킨다.
    on E.department_id = D.department_id
    order by D.department_id, employee_id;
    
    -- OUTER 는 생략가능하다.
    select E.department_id AS 부서번호, department_name AS 부서명, employee_id AS 사원번호, first_name || ' ' || last_name AS 사원명, salary AS 기본급여
    from employees E full join departments D  -- FULL은 명령어를 기준으로 양쪽 테이블에 있는 모든 행들을 출력해준 다음 조인조건절로 매핑시킨다.
    on E.department_id = D.department_id
    order by D.department_id, employee_id;
    
    
    -- SQL 1999 CODE 방식은
    -- 1. 모든 경우의 수(Catersian Product) ==> CROSS JOIN
    -- 2. NULL 은 제외한 조인 ==> (INNER) JOIN
    -- 3. NULL 까지 보여주는 조인 ==> LEFT (OUTER) JOIN, RIGHT (OUTER) JOIN, FULL (OUTER) JOIN
    
    -- 부서번호  사원번호  사원명  기본급여  부서평균급여  평균급여와의차액
    -- 위와 같이 나오도록 구하세요.
    
/*
    부서번호별  평균급여         부서번호  사원번호  사원명  기본급여
    ------------------        ---------------------------------
        10      ...             10      1122    홍길동   3700
        20      ...             10      1133    이순신   3000
        30      ...             20      1144    엄정화   5000
        ..      ...             ..      ....     ...    ....
        
            V                           employees E
            
        조인조건절 ==> V.부서번호 = E.부서번호
*/

    select department_id, trunc(avg(salary)) AS AVGSAL
    from employees
    group by department_id;
    
    select E.department_id AS 부서번호
         , employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , salary AS 기본급여
         , avgsal AS 부서평균급여
         , salary - avgsal AS 부서평균급여와의차액
    from employees E join
    (
    select nvl(department_id, -9999) AS department_id, trunc(avg(salary)) AS AVGSAL
    from employees
    group by department_id
    ) V
    on nvl(E.department_id, -9999) = V.department_id -- left join으로는 조인조건절 null = null 을 매핑할 수 없다(null 값을 기준으로 매핑하여 null 값이 아닌 값을 보이고자할 때는 nvl())
    order by 1, 4 desc;
    
    -- [퀴즈] 부서번호  사원번호  사원명  기본급여  부서평균급여  부서평균급여와의차액  부서내급여등수  전체급여등수
    -- 위와 같이 나오도록 구하세요.
    /*
        부서번호  부서평균급여 / 사원번호  사원명  기본급여  평균급여  급여차액
               V                            employees E
    */
    
    select E.department_id AS 부서번호
         , employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , salary AS 기본급여
         , avgsal AS 부서평균급여
         , salary - avgsal AS 부서평균급여와의차액
         , rank() over(partition by E.department_id order by salary desc) AS 부서내급여등수
         , rank() over(order by salary desc) AS 전체급여등수
    from employees E join
    (
    select nvl(department_id, -9999) AS department_id, round(avg(salary)) AS AVGSAL
    from employees
    group by department_id
    ) V
    on nvl(E.department_id, -9999) = V.department_id
    order by 1, 7;
    
    -- [퀴즈] 부서번호가 10, 20, 30, 40, 50번 부서의 근무하는 사원들을 대상으로
    --        부서번호  사원번호  사원명  기본급여  부서평균급여  부서평균급여와의차액  부서내급여등수  전체급여등수
    --        위와 같이 나오도록 구하세요.
    
    select E.department_id AS 부서번호
         , employee_id AS 사원번호
         , first_name || ' ' || last_name AS 사원명
         , salary AS 기본급여
         , avgsal AS 부서평균급여
         , salary - avgsal AS 부서평균급여와의차액
         , rank() over(partition by E.department_id order by salary desc) AS 부서내급여등수
         , rank() over(order by salary desc) AS 전체급여등수
    from employees E join
    (
    select nvl(department_id, -9999) AS department_id, round(avg(salary)) AS AVGSAL
    from employees
    group by department_id
    ) V
    on nvl(E.department_id, -9999) = V.department_id
    where E.department_id between 10 and 50  -- where절은 조인조건절 다음에 온다, but 조건에 맞지 않는 데이터도 메모리에 올라가고 이후 걸러내기 때문에 메모리 낭비
    order by 1, 7;
    
    -- 2번 방법(권장)
    select E.department_id AS 부서번호
         , employee_id AS 사원번호
         , ename AS 사원명
         , salary AS 기본급여
         , avgsal AS 부서평균급여
         , salary - avgsal AS 부서평균급여와의차액
         , rank() over(partition by E.department_id order by salary desc) AS 부서내급여등수
         , rank() over(order by salary desc) AS 전체급여등수
    from
    (
        select department_id, employee_id, first_name || ' ' || last_name AS ENAME, salary
        from employees
        where department_id between 10 and 50
    ) E join
    (
        select department_id, round(avg(salary)) AS AVGSAL
        from employees
        where department_id between 10 and 50
        group by department_id
    ) V
    on E.department_id = V.department_id
    order by 1, 7;
    -- join 할 때는 필요한 조건과 컬럼만 뽑아서 합쳐 부하를 줄인다.
    
    
        ----- **** NON-EQUI JOIN **** -----
    -- 어떤 컬럼의 값이 특정 범위에 속할 때 사용하는 JOIN 이다.
    
    -- 소득세율 지표 관련 테이블을 생성한다. 
  create table tbl_taxindex
  (lowerincome   number       -- 연봉의 최저
  ,highincome    number       -- 연봉의 최대
  ,taxpercent    number(2,2)  -- 세율  -0.99 ~ 0.99 
  );
  -- 데이터 타입이 숫자인 것만 받고자 할 경우에는 number 타입을 사용한다.
  -- number       --> 숫자가 무제한으로 들어온다.
  -- number(4)    --> 4자리 수 의미: 숫자가 ~9999 ~ 9999 까지만 들어온다.
  -- number(5)    --> 5자리: 숫자가 ~99999 ~ 99999 까지만 들어온다.
  -- number(3,1)  --> 3자리 중 소수부 1자리: -99.9 ~ 99.9 까지만 들어온다.
  -- number(4,2)  --> 4자리 중 소수부 2자리: -99.99 ~ 99.99 까지만 들어온다.
  -- number(2,2)  --> 2자리 중 소수부 2자리: -0.99 ~ 0.99 까지만 들어온다.

  insert into tbl_taxindex(lowerincome,highincome,taxpercent)
  values(1, 99999, 0.02);

  insert into tbl_taxindex(lowerincome,highincome,taxpercent)
  values(100000, 149999, 0.05);

  insert into tbl_taxindex(lowerincome,highincome,taxpercent)
  values(150000, 199999, 0.08);

  insert into tbl_taxindex(lowerincome,highincome,taxpercent)
  values(200000, 10000000000000000, 0.1);

  commit;
  
  select *
  from tbl_taxindex;
  
  ------------------------------------
   사원번호  사원명  연봉  세율  소득세액
  ------------------------------------
   1001     홍길동 50000 0.02  50000*0.02
   1002     엄정화 250000 0.08 250000*0.08
   
   select employee_id AS 사원번호
        , first_name || ' ' || last_name AS 사원명
        , to_char(nvl(salary+(salary*commission_pct), salary)*12, '999,999') AS 연봉
        , taxpercent AS 세율
        , to_char(nvl(salary+(salary*commission_pct), salary)*12 * taxpercent, '99,999.9') AS 소득세액
   from employees E , tbl_taxindex T  -- SQL 1992 CODE
   where nvl(salary+(salary*commission_pct), salary)*12 between lowerincome and highincome -- 조인조건절, 테이블 값이 다른 테이블 컬럼의 값 사이에 있을 때 non-equi join
   order by 1;
   
   -- SQL 1999 CODE
   select employee_id AS 사원번호
        , first_name || ' ' || last_name AS 사원명
        , to_char(nvl(salary+(salary*commission_pct), salary)*12, '999,999') AS 연봉
        , taxpercent AS 세율
        , to_char(nvl(salary+(salary*commission_pct), salary)*12 * taxpercent, '99,999.9') AS 소득세액
   from employees join tbl_taxindex T
   on nvl(salary+(salary*commission_pct), salary)*12 between lowerincome and highincome
   order by 1;
   
   
        ----- **** SELF JOIN(자기조인) **** -----
    /*
        자기자신의 테이블(뷰)을 자기자신의 테이블(뷰)과 JOIN 시키는 것을 말한다.
        이때 반드시 테이블(뷰)에 대한 alias를 달리 주어서 실행해야 한다.
    */
    -------------------------------------------------------
     사원번호  사원명          이메일   급여  직속상관번호  직속상관명
     -------------------------------------------------------
     100    Steven King	    SKING   24000     null    null
     102    Lex	De Haan	    LDEHAAN 17000     100     Steven King
     103	Alexander Hunold AHUNOLD 9000     102     Lex De Haan
     104	Bruce Ernst	    BERNST   6000     103     Alexander Hunold
     
        first_name || ' ' || last_name   manager_id   first_name || ' ' || last_name -- 컬럼명은 같은데 보여주는 데이터는 다를 때 SELF JOIN
                                         employee_id -- 두 컬럼의 값으로 매핑
     
     -- SQL 1992 CODE
     select E1.employee_id AS 사원번호                          -- E1
          , E1.first_name || ' ' || E1.last_name AS 사원명      -- E1
          , E1.email AS 이메일                                 -- E1
          , E1.salary AS 급여                                  -- E1
          , E2.employee_id AS 직속상관번호                      -- E2, E1이면 manager_id
          , E2.first_name || ' ' || E2.last_name AS 직속상관명  -- E2
     from employees E1 , employees E2
     where E1.manager_id = E2.employee_id(+)
     order by E1.employee_id;
     
     -- SQL 1999 CODE
     select E1.employee_id AS 사원번호                          -- E1
          , E1.first_name || ' ' || E1.last_name AS 사원명      -- E1
          , E1.email AS 이메일                                 -- E1
          , E1.salary AS 급여                                  -- E1
          , E2.employee_id AS 직속상관번호                      -- E2, E1이면 manager_id
          , E2.first_name || ' ' || E2.last_name AS 직속상관명  -- E2
     from employees E1 left join employees E2
     on E1.manager_id = E2.employee_id
     order by E1.employee_id;
     

    -- [퀴즈] --
   create table tbl_authorbook
   (bookname       varchar2(100)
   ,authorname     varchar2(20)
   ,loyalty        number(5)
   );
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('자바프로그래밍','최은지',1000);
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('로빈슨크루소','이영경',800);
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('로빈슨크루소','최은지',500);
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('조선왕조실록','안세형',2500);
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('그리스로마신화','박지현',1200);
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('그리스로마신화','이지은',1300);
   
   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('그리스로마신화','박수빈',1700);

   insert into tbl_authorbook(bookname, authorname, loyalty)
   values('어린왕자','김동휘',1800);
   
   commit;
   
   select *
   from tbl_authorbook;
   
   /*
        tbl_authorbook 테이블에서 공저(도서명은 동일하지만 작가명이 다른 도서)로 지어진
        도서정보를 나타내세요(SELF JOIN 을 사용해서 풀이)
   */
   -------------------------------
    도서명     작가명     로얄티
    ------------------------------
    로빈슨크루소	이영경	800
    로빈슨크루소	최은지	500
    그리스로마신화	박지현	1200
    그리스로마신화	이지은	1300
    그리스로마신화	박수빈	1700
    
    select distinct B1.bookname AS 도서명
                  , B1.authorname AS 작가명
                  , B1.loyalty AS 로얄티
    from tbl_authorbook B1 join tbl_authorbook B2
    on B1.bookname = B2.bookname and B1.authorname != B2.authorname
    order by 1;
